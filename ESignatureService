package com.apptivo.view.dao.servlet.v6.service;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.print.PageFormat;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.UUID;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.imageio.IIOImage;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;
import javax.imageio.stream.ImageOutputStream;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;
import org.apache.lucene.search.join.ScoreMode;
import org.apache.pdfbox.io.MemoryUsageSetting;
import org.apache.pdfbox.multipdf.PDFMergerUtility;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.encryption.InvalidPasswordException;
import org.apache.pdfbox.pdmodel.font.PDType0Font;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.printing.PDFPageable;
import org.apache.pdfbox.rendering.ImageType;
import org.apache.pdfbox.rendering.PDFRenderer;
import org.apache.pdfbox.text.PDFTextStripper;
import org.apache.pdfbox.text.TextPosition;
import org.apache.pdfbox.tools.imageio.ImageIOUtil;
import org.apache.pdfbox.util.Matrix;
import org.codehaus.jackson.map.ObjectMapper;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.search.SearchRequestBuilder;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.update.UpdateRequestBuilder;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.engine.VersionConflictEngineException;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.InnerHitBuilder;
import org.elasticsearch.index.query.NestedQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.RangeQueryBuilder;
import org.elasticsearch.script.ScriptType;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.elasticsearch.search.aggregations.AggregationBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.bucket.filter.InternalFilter;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.metrics.TopHits;
import org.elasticsearch.search.aggregations.metrics.TopHitsAggregationBuilder;
import org.elasticsearch.search.sort.FieldSortBuilder;
import org.elasticsearch.search.sort.SortBuilders;
import org.elasticsearch.search.sort.SortOrder;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import com.apptivo.app.esign.blockchain.BlockchainService;
import com.apptivo.app.service.BaseElasticService;
import com.apptivo.cases.service.CasesElasticService;
import com.apptivo.common.services.AppEncryptionService;
import com.apptivo.model.acis.constants.AcisConstants.MESSAGE_PROPERTIES;
import com.apptivo.model.dao.billingservice.BillingServicesDAO;
import com.apptivo.model.dao.common.AppBaseDAO;
import com.apptivo.model.dao.common.AppSessionDAO;
import com.apptivo.model.dao.common.AppSettingsDAO;
import com.apptivo.model.dao.common.CommonDAO;
import com.apptivo.model.dao.common.DocumentDAO;
import com.apptivo.model.dao.common.EmailDAO;
import com.apptivo.model.dao.common.FirmDAO;
import com.apptivo.model.dao.common.MessageTemplateDAO;
import com.apptivo.model.dao.common.NotesDAO;
import com.apptivo.model.dao.es.ESAPIUtil;
import com.apptivo.model.dao.es.ESConstants;
import com.apptivo.model.dao.es.ElasticSearchDAO;
import com.apptivo.model.dao.esign.ESignConstants;
import com.apptivo.model.dao.fin.EstimatesDAO;
import com.apptivo.model.dao.hr.EmployeeDAO;
import com.apptivo.model.dao.login.LoginDAO;
import com.apptivo.model.ejb.common.IdxPhoneNumber;
import com.apptivo.model.framework.tracking.AppExceptionService;
import com.apptivo.model.index.athena.IdxFirmESignDocument;
import com.apptivo.model.index.billingservice.IdxQuotaBalance;
import com.apptivo.model.index.cf.IdxCfToken;
import com.apptivo.model.index.collaboration.IdxAppIntegrationRequest;
import com.apptivo.model.index.collaboration.IdxEmailDeliverability;
import com.apptivo.model.index.collaboration.IdxEmailsConfiguration;
import com.apptivo.model.index.common.IdxAutoReminder;
import com.apptivo.model.index.common.IdxAutoReminderConfigLine;
import com.apptivo.model.index.common.IdxCustomAtributeValue;
import com.apptivo.model.index.common.IdxCustomAttribute;
import com.apptivo.model.index.common.IdxDocument;
import com.apptivo.model.index.common.IdxEmailSignatureTemplate;
import com.apptivo.model.index.common.IdxEmailTemplate;
import com.apptivo.model.index.common.IdxFirm;
import com.apptivo.model.index.common.IdxFirmBaseData;
import com.apptivo.model.index.common.IdxFirmBranding;
import com.apptivo.model.index.common.IdxFirmCustomer;
import com.apptivo.model.index.common.IdxFirmEmpContact;
import com.apptivo.model.index.common.IdxFolder;
import com.apptivo.model.index.common.IdxLabel;
import com.apptivo.model.index.common.IdxLookup;
import com.apptivo.model.index.common.IdxObject;
import com.apptivo.model.index.common.IdxSmplObj;
import com.apptivo.model.index.common.IdxStatus;
import com.apptivo.model.index.crm.IdxCase;
import com.apptivo.model.index.crm.IdxContact;
import com.apptivo.model.index.crm.IdxContract;
import com.apptivo.model.index.crm.IdxContractsConfiguration;
import com.apptivo.model.index.crm.IdxCustomer;
import com.apptivo.model.index.crm.IdxCustomersConfiguration;
import com.apptivo.model.index.esign.IdxDocChangeRequest;
import com.apptivo.model.index.esign.IdxESignConfiguration;
import com.apptivo.model.index.esign.IdxESignDocRevisions;
import com.apptivo.model.index.esign.IdxESignDocument;
import com.apptivo.model.index.esign.IdxESignSigner;
import com.apptivo.model.index.esign.IdxEsignAttribute;
import com.apptivo.model.index.esign.IdxEsignDocumentPage;
import com.apptivo.model.index.esign.IdxObjectSign;
import com.apptivo.model.index.esign.IdxReassign;
import com.apptivo.model.index.fin.IdxEsignature;
import com.apptivo.model.index.fin.IdxEsignatureHistory;
import com.apptivo.model.index.fin.IdxEstimate;
import com.apptivo.model.index.fin.IdxEstimateConfiguration;
import com.apptivo.model.index.fin.IdxWorkOrder;
import com.apptivo.model.index.fin.IdxWorkOrdersConfiguration;
import com.apptivo.model.index.hr.IdxComUser;
import com.apptivo.model.index.hr.IdxEmployee;
import com.apptivo.model.index.hr.IdxRole;
import com.apptivo.model.index.hr.IdxRolePrivilege;
import com.apptivo.model.index.scm.IdxOrder;
import com.apptivo.model.index.scm.IdxOrdersConfiguration;
import com.apptivo.model.index.settings.common.IdxActionPrivilege;
import com.apptivo.model.index.settings.common.IdxConfiguration;
import com.apptivo.model.index.settings.common.IdxHomeConfiguration;
import com.apptivo.model.index.trigger.IdxCriteriaCondition;
import com.apptivo.model.index.trigger.IdxCriteriaGroup;
import com.apptivo.model.index.trigger.IdxCriteriaSet;
import com.apptivo.model.index.trigger.IdxTriggerAction;
import com.apptivo.model.index.trigger.IdxTriggerUpdateAttribute;
import com.apptivo.model.thirdparty.elasticsearch.helper.IdxFirmPlanHistory;
import com.apptivo.model.thirdparty.elasticsearch.helper.IdxPdfTemplate;
import com.apptivo.model.thirdparty.elasticsearch.helper.IdxPdfTemplateConfiguration;
import com.apptivo.model.thirdparty.elasticsearch.helper.IdxReminderLine;
import com.apptivo.model.thirdparty.elasticsearch.helper.IdxUserSession;
import com.apptivo.view.cf.service.CfTokenService;
import com.apptivo.view.common.actions.UpdateAttributeAction;
import com.apptivo.view.dao.actioncenter.ESignEventActionDAO;
import com.apptivo.view.dao.servlet.v6.bg.PrepareDocPagesThread;
import com.apptivo.view.dao.servlet.v6.bg.SignDocSentDateThread;
import com.apptivo.view.platform.create.RegistrationDAO;
import com.apptivo.view.service.actioncenter.ESignEventActionService;
import com.apptivo.view.service.common.FirmEmpContactService;
import com.apptivo.view.service.fin.EstimateService;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.sirahu.apptivo.common.AppException;
import com.sirahu.apptivo.common.application.ApplicationProperties;
import com.sirahu.apptivo.common.helper.NumberHelper;
import com.sirahu.apptivo.common.http.AppHttpClient;
import com.sirahu.apptivo.common.logging.MessageLogger;
import com.sirahu.apptivo.common.util.AppSendMailUtil;
import com.sirahu.apptivo.common.util.AppUtil;
import com.sirahu.apptivo.common.util.DateUtil;
import com.sirahu.apptivo.common.util.HttpUtil;
import com.sirahu.apptivo.common.utils.AppEncryptionUtil;
import com.sirahu.apptivo.model.framework.util.AppConstants;
import com.sirahu.apptivo.model.framework.util.AppGoogleUtil;
import com.sirahu.apptivo.model.framework.util.EmailUtil;
import com.sirahu.apptivo.model.framework.util.ObjectConstants;
import com.sirahu.apptivo.model.framework.util.OrderConstants;
import com.sirahu.apptivo.model.helper.UserData;
import com.sirahu.apptivo.thirdparty.email.AppCommonUtil;
import com.sirahu.apptivo.view.application.AppUserConfiguration;
import com.sirahu.apptivo.view.dao.actions.ContractsElasticService;
import com.sirahu.apptivo.view.dao.actions.OrdersActions;
import com.sirahu.apptivo.view.dao.service.EstimateElasticService;
import com.sirahu.apptivo.view.dao.service.PdfTemplateService;
import com.sirahu.apptivo.view.dao.service.ProcessTriggerService;
import com.sirahu.apptivo.view.dao.service.WorkOrdersElasticService;
import com.sirahu.apptivo.view.dao.v5.CommonUtil;
import com.sirahu.apptivo.view.framework.util.AppFileUtil;
import com.sirahu.apptivo.view.framework.util.AppHttpUtil;
import java.util.regex.Matcher;


/**
 * This class contains the methods to save and retrieve the esign app
 * configuration
 * 
 * @author Veenu Dheepithi
 *
 */

public class ESignatureService extends BaseElasticService {

	private static final MessageLogger logger = MessageLogger.getLogger(ESignatureService.class);
	private static ESignatureService instance;

	static {
		instance = new ESignatureService();
	}

	private ESignatureService() {

	}

	public static ESignatureService getInstance() {
		return instance;
	}

	/**
	 * This method used to get the Sign Admin Firm ID.
	 *
	 * - Staging    - 243075 - apptivodb5
	 * - Production - 258049 - apptivodb5
	 *
	 * @return
	 */
	public Long getSignFirmId() {
		final String signFirmId = AppBaseDAO.getInstance().getEnvProperty(AppConstants.SIGN_FIRM_ID, AppConstants.YES);
		if(signFirmId != null) {
			return Long.valueOf(signFirmId);
		}
		return 0L;
	}

	/**
	 * Method to get the Esignature Configuration
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public IdxESignConfiguration getConfigData(final Long firmId, final UserData userData) {
		final Long userId = userData.getUserId();

		IdxESignConfiguration configuration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

		if (configuration == null) {
			configuration = getDefaultConfigData(firmId, userData);
		}

		boolean isSettingsNeedsToIndex = mergeConfig(firmId, userData, configuration);

		logger.info(firmId, "ESignatureService:getConfigData:configuration:" + configuration);
		if (isSettingsNeedsToIndex) {
			AppBaseDAO.getInstance().indexCommonSettingsPack(firmId, configuration,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, userId,
					userData.getFullName());
		}
		return configuration;
	}

	/**
	 * This method used to merge configuration based on the version.
	 *
	 * @param firmId
	 * @param userData
	 * @param configuration
	 * @return
	 */
	public boolean mergeConfig(final Long firmId, final UserData userData, final IdxESignConfiguration configuration) {
		Boolean isSettingsNeedsToIndex = false;

		boolean isNeedToUpdateCOnfig = needToUpdateConfigData(configuration);
		if (!isNeedToUpdateCOnfig) {
			return false;
		}

		configuration.setConfigVersionNumber(ESignConstants.CURRENT_ESIGN_CONFIG_VERSION);

		if (!AppUtil.checkListisNullOrNot(configuration.getSignatureTypes())) {
			setSignatureTypes(configuration);
			isSettingsNeedsToIndex = true;
		}

		if (!AppUtil.checkListisNullOrNot(configuration.getDocumentStatuses())) {
			setDocumentStatuses(configuration);
			isSettingsNeedsToIndex = true;
		}

		if (!AppUtil.checkListisNullOrNot(configuration.getEmailTemplates())) {
			setEmailTemplates(configuration, firmId, userData);
			isSettingsNeedsToIndex = true;
		}
		
		if(!AppUtil.checkStringNullOrNot(configuration.getAccessLevel())) {
			setDefaultAccessLevel(configuration);
			isSettingsNeedsToIndex = true;
		}

		if (!AppUtil.checkStringNullOrNot(configuration.getIsLegalDisclosureEnab())) {
			setLegalPolicyContent(configuration, firmId, userData);
			isSettingsNeedsToIndex = true;
		}

		if(!AppUtil.checkListisNullOrNot(configuration.getPrivilegeSettings())) {
			setDefaultPrivilegeSettings(configuration);
			isSettingsNeedsToIndex = true;
		}

		// Adding up New Email Templates
		if (AppUtil.checkListisNullOrNot(configuration.getEmailTemplates())) {
			final List<String> existEmailTemplates = new ArrayList<>();

			for(final IdxEmailTemplate emailTemplate : configuration.getEmailTemplates()) {
				existEmailTemplates.add(emailTemplate.getMessageType());
			}
			addEmailTemplatesByMessageType(firmId, userData, configuration, existEmailTemplates);
			isSettingsNeedsToIndex = true;
		}

		if (!AppUtil.checkListisNullOrNot(configuration.getReminderLines())) {
			setDefaultReminder(configuration, firmId, userData);
			isSettingsNeedsToIndex = true;
		}

		if (!AppUtil.checkListisNullOrNot(configuration.getTemplateCategories())) {
			setTemplateCategories(configuration);
			setStandardTemplates(firmId, userData);
			isSettingsNeedsToIndex = true;
		}

		if (!AppUtil.checkListisNullOrNot(configuration.getSignerAuth())) {
			setSignerAuthentication(configuration);
			isSettingsNeedsToIndex = true;
		}

		// Adding Void Document Statuses
		if (AppUtil.checkListisNullOrNot(configuration.getDocumentStatuses())) {
			boolean isVoidStatusExist = false;
			for(IdxLookup taskStatus : configuration.getDocumentStatuses()) {
				if(ESignConstants.ESIGN_DOCUMENT_STATUS_VOID.equalsIgnoreCase(taskStatus.getLookupCode())) {
					isVoidStatusExist = true;
				}
			}

			if(!isVoidStatusExist) {
				Long statusId = Long.valueOf(configuration.getDocumentStatuses().size());
				final IdxLookup idxStatus = new IdxLookup(statusId,
						ESignConstants.ESIGN_DOCUMENT_STATUS_VOID.toUpperCase(),
						ESignConstants.ESIGN_DOCUMENT_STATUS_VOID, "This status will indicate on void",
						AppConstants.YES, "#ea603b", null);
				configuration.getDocumentStatuses().add(idxStatus);
			}
		}
		// Adding Legal Disclosure Content
		if (!AppUtil.checkListisNullOrNot(configuration.getLdc())) {
			setLegalDisclosureContent(configuration);
			isSettingsNeedsToIndex = true;
		}

		return isSettingsNeedsToIndex;
	}

	/**
	 * This method used to check the configuration data is updated or not.
	 *
	 * @param configuration
	 * @return
	 */
	private boolean needToUpdateConfigData (final IdxESignConfiguration configuration) {
		return configuration.getConfigVersionNumber() == null
				|| configuration.getConfigVersionNumber().intValue() < ESignConstants.CURRENT_ESIGN_CONFIG_VERSION;
	}

	/**
	 * This method used to get default configuration data for Sign.co
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public IdxESignConfiguration getDefaultConfigData(final Long firmId, final UserData userData) {

		final IdxESignConfiguration configuration = new IdxESignConfiguration();
		configuration.setFirmId(firmId);
		configuration.setAppName("Sign");
		configuration.setFieldNamePlural("Sign");
		configuration.setFieldNameSingular("Sign");
		configuration.setIsATagEnabled(AppConstants.NO);

		setDocumentStatuses(configuration);
		setSignatureTypes(configuration);
		setEmailTemplates(configuration, firmId, userData);
		setDefaultAccessLevel(configuration);
		setLegalPolicyContent(configuration, firmId, userData);
		setDefaultPrivilegeSettings(configuration);
		setDefaultReminder(configuration, firmId, userData);
		setTemplateCategories(configuration);
		setStandardTemplates(firmId, userData);
		setSignerAuthentication(configuration);
		setLegalDisclosureContent(configuration);
		return configuration;
	}

	/**
	 * This method used to set the document statuses.
	 * 
	 * @param configuration
	 */
	public void setDocumentStatuses(final IdxESignConfiguration configuration) {
		final List<IdxLookup> documentStatuses = new ArrayList<>();

		Long statusId = 1L;
		IdxLookup idxStatus = new IdxLookup(statusId, "NEED_MY_SIGNATURE", "Need My Signature",
				"This status will indicate on pending for my signature", AppConstants.YES, "#904fab", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, ESignConstants.ESIGN_DOCUMENT_STATUS_SENT.toUpperCase(),
				ESignConstants.ESIGN_DOCUMENT_STATUS_SENT, "This status will indicate on sent", AppConstants.YES,
				"#0fa9db", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, "IN_PROGRESS", "In-Progress", "This status will indicate on in-progress",
				AppConstants.YES, "#ffcd00", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.toUpperCase(),
				ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED, "This status will indicate on completed",
				AppConstants.YES, "#32c387", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, ESignConstants.ESIGN_DOCUMENT_STATUS_DECLINED.toUpperCase(),
				ESignConstants.ESIGN_DOCUMENT_STATUS_DECLINED, "This status will indicate on declined",
				AppConstants.YES, "#e74a3b", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, ESignConstants.ESIGN_DOCUMENT_STATUS_EXPIRED.toUpperCase(),
				ESignConstants.ESIGN_DOCUMENT_STATUS_EXPIRED, "This status will indicate on expired", AppConstants.YES,
				"#b74b32", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, ESignConstants.ESIGN_DOCUMENT_STATUS_DRAFT.toUpperCase(),
				ESignConstants.ESIGN_DOCUMENT_STATUS_DRAFT, "This status will indicate on draft", AppConstants.YES,
				"#a0a0a0", null);
		documentStatuses.add(idxStatus);

		statusId++;
		idxStatus = new IdxLookup(statusId, ESignConstants.ESIGN_DOCUMENT_STATUS_VOID.toUpperCase(),
				ESignConstants.ESIGN_DOCUMENT_STATUS_VOID, "This status will indicate on void", AppConstants.YES,
				"#ea603b", null);
		documentStatuses.add(idxStatus);

		configuration.setDocumentStatuses(documentStatuses);
	}

	/**
	 * set the SignatureTypes properties
	 * 
	 * @param configuration
	 */
	public void setSignatureTypes(final IdxESignConfiguration configuration) {
		final List<IdxLookup> signatureTypes = new ArrayList<>();

		Long signatureTypeId = 1L;
		IdxLookup signatureType = new IdxLookup(signatureTypeId, "MY_SIGNATURES", "My Signatures", null,
				AppConstants.YES, null, null);
		signatureTypes.add(signatureType);

		signatureTypeId++;
		signatureType = new IdxLookup(signatureTypeId, "TYPE", "Type", null, AppConstants.YES, null, null);
		signatureTypes.add(signatureType);

		signatureTypeId++;
		signatureType = new IdxLookup(signatureTypeId, "DRAW", "Draw", null, AppConstants.YES, null, null);
		signatureTypes.add(signatureType);

		signatureTypeId++;
		signatureType = new IdxLookup(signatureTypeId, "UPLOAD", "Upload", null, AppConstants.YES, null, null);
		signatureTypes.add(signatureType);

		signatureTypeId++;
		signatureType = new IdxLookup(signatureTypeId, "SMART_PHONE", "Smart Phone", null, AppConstants.YES, null,
				null);
		signatureTypes.add(signatureType);

		configuration.setSignatureTypes(signatureTypes);
	}

	/**
	 * This method used to set the default email templates for sign.co
	 * 
	 * @param configuration
	 * @param firmId
	 * @param userData
	 */
	public void setEmailTemplates(final IdxESignConfiguration configuration, final Long firmId, UserData userData) {
		final List<IdxEmailTemplate> idxEmailTemplates = new ArrayList<>();

		final String emailTemplateData = AppFileUtil.getInstance()
				.readFileFromClassPath(ESignConstants.EMAIL_TEMPLATE_FILE_PATH);
		try {
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final JSONParser parser = new JSONParser();
			final JSONArray emailTemplates = (JSONArray) parser.parse(emailTemplateData);
			for (int i = 0; i < emailTemplates.size(); i++) {
				final IdxEmailTemplate idxEmailTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class,
						emailTemplates.get(i).toString());
				idxEmailTemplate
						.setId(AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_MESSAGE_ID));
				idxEmailTemplate.setFirmId(firmId);

				idxEmailTemplate.setCreatedBy(userData.getUserId());
				idxEmailTemplate.setCreatedByName(userData.getFullName());
				idxEmailTemplate.setCreationDate(currentDate);

				idxEmailTemplate.setLastUpdatedBy(userData.getUserId());
				idxEmailTemplate.setLastUpdatedByName(userData.getFullName());
				idxEmailTemplate.setLastUpdateDate(currentDate);

				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
						idxEmailTemplate.getId(), AppUtil.convertToJson(idxEmailTemplate));

				idxEmailTemplate
						.setCustomMessage(idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1]);
				idxEmailTemplate.setWidgets("");
				idxEmailTemplates.add(idxEmailTemplate);
			}
			configuration.setEmailTemplates(idxEmailTemplates);
		} catch (ParseException exception) {
			logger.error(firmId, "ESignatureService:setEmailTemplates:Parseexception:", exception);
		} catch (Exception exception){
			logger.error(firmId, "ESignatureService:setEmailTemplates:exception:", exception);
		}
	}

	/**
	 * This method used to add the email template based on missing template names
	 *
	 * @param firmId
	 * @param userData
	 * @param configuration
	 * @param existingTemplates
	 */
	public void addEmailTemplatesByMessageType(final Long firmId, UserData userData, final IdxESignConfiguration configuration,
			final List<String> existingTemplates) {
		final String emailTemplateData = AppFileUtil.getInstance()
				.readFileFromClassPath(ESignConstants.EMAIL_TEMPLATE_FILE_PATH);
		try {
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final JSONParser parser = new JSONParser();
			final JSONArray emailTemplates = (JSONArray) parser.parse(emailTemplateData);
			for (int i = 0; i < emailTemplates.size(); i++) {
				final IdxEmailTemplate idxEmailTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class,
						emailTemplates.get(i).toString());
				if (!existingTemplates.contains(idxEmailTemplate.getMessageType())) {
					idxEmailTemplate.setId(
							AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_MESSAGE_ID));
					idxEmailTemplate.setFirmId(firmId);

					idxEmailTemplate.setCreatedBy(userData.getUserId());
					idxEmailTemplate.setCreatedByName(userData.getFullName());
					idxEmailTemplate.setCreationDate(currentDate);

					idxEmailTemplate.setLastUpdatedBy(userData.getUserId());
					idxEmailTemplate.setLastUpdatedByName(userData.getFullName());
					idxEmailTemplate.setLastUpdateDate(currentDate);

					ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
							idxEmailTemplate.getId(), AppUtil.convertToJson(idxEmailTemplate));

					idxEmailTemplate
							.setCustomMessage(idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1]);
					idxEmailTemplate.setWidgets("");
					configuration.getEmailTemplates().add(idxEmailTemplate);
				}
			}
		} catch (ParseException exception) {
			logger.error(firmId, "ESignatureService:addEmailTemplatesByMessageType:exception:", exception);
		}
	}
	
	/**
	 * This method used to set the default access level
	 *
	 * @param configuration
	 */
	public void setDefaultAccessLevel(final IdxESignConfiguration configuration) {
		configuration.setAccessLevel(AppConstants.COM_ACCESS_TYPE_EMPLOYEE);
		configuration.setEditAccessLevel(AppConstants.COM_ACCESS_TYPE_EMPLOYEE);

		configuration.setViewSecurityExceptionList(new ArrayList<>());
	}

	/**
	 * THis method used to set the legal Policy.
	 *
	 * @param configuration
	 * @param firmId
	 * @param userData
	 */
	public void setLegalPolicyContent(final IdxESignConfiguration configuration, final Long firmId,
			final UserData userData) {
		final String legalPolicyContent = AppFileUtil.getInstance()
				.readFileFromClassPath(ESignConstants.LEGAL_POLICY_FILE_PATH);
		try {
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final JSONParser parser = new JSONParser();
			final JSONArray legalPolicy = (JSONArray) parser.parse(legalPolicyContent);
			for (int i = 0; i < legalPolicy.size(); i++) {

				final IdxEmailTemplate idxLegalPolicy = AppUtil.convertFromJson(IdxEmailTemplate.class,
						legalPolicy.get(i).toString());
				idxLegalPolicy
						.setId(AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_MESSAGE_ID));
				idxLegalPolicy.setFirmId(firmId);

				idxLegalPolicy.setCreatedBy(userData.getUserId());
				idxLegalPolicy.setCreatedByName(userData.getFullName());
				idxLegalPolicy.setCreationDate(currentDate);

				idxLegalPolicy.setLastUpdatedBy(userData.getUserId());
				idxLegalPolicy.setLastUpdatedByName(userData.getFullName());
				idxLegalPolicy.setLastUpdateDate(currentDate);

				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
						idxLegalPolicy.getId(), AppUtil.convertToJson(idxLegalPolicy));
			}

			configuration.setLegalDisclosureEnab(AppConstants.YES);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:setLegalPolicyContent:exception:", exception);
		}
	}

	/**
	 * This method used to set the default Privilege Settings.
	 *
	 * @param configuration
	 */
	public void setDefaultPrivilegeSettings(final IdxESignConfiguration configuration) {
		final IdxActionPrivilege actionPrivilege = new IdxActionPrivilege(AppConstants.STR_CHAT_WIDGET_ACTION_CODE,
				"Support Chat", "", "", AppConstants.YES);
		configuration.getPrivilegeSettings().add(actionPrivilege);
	}

	/**
	 * This method used to set the default remainder in configuration.
	 *
	 * @param configuration
	 * @param firmId
	 * @param userData
	 */
	public void setDefaultReminder(final IdxESignConfiguration configuration, final Long firmId,
			final UserData userData) {
		final List<IdxReminderLine> reminderLines = new ArrayList<>();

		final IdxReminderLine reminderLine1 = createReminder(configuration, firmId, userData, 1);

		reminderLines.add(reminderLine1);

		final IdxReminderLine reminderLine2 = createReminder(configuration, firmId, userData, 3);

		reminderLines.add(reminderLine2);

		configuration.setReminderLines(reminderLines);
	}

	/**
	 * This method used to create reminder based on day interval.
	 *
	 * @param configuration
	 * @param firmId
	 * @param userData
	 * @param dayInterval
	 * @return
	 */
	public IdxReminderLine createReminder(final IdxESignConfiguration configuration, final Long firmId,
			final UserData userData, final Integer dayInterval) {
		final String emailTemplateId = configuration.getEmailTemplateByMessageType(ESignConstants.DOCUMENT_EXPIRATION)
				.getId().toString();

		IdxReminderLine reminderLine = new IdxReminderLine();
		reminderLine.setDaysBeforeAfterCheckDate(dayInterval);
		reminderLine.setEmailTemplateId(emailTemplateId);
		reminderLine.setIsEnabled(AppConstants.YES);
		reminderLine.setReminderSendOption(AppConstants.REMINDER_TYPE_AUTO);

		IdxAutoReminderConfigLine reminderConfigLine = new IdxAutoReminderConfigLine();

		reminderConfigLine.setFirmId(firmId);
		reminderConfigLine.setAutoReminderConfigLineId(
				AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_AUTO_REMINDER_CONFIG_LINE_ID));
		reminderConfigLine.setMessageTemplateId(Long.valueOf(reminderLine.getEmailTemplateId()));
		reminderConfigLine.setDaysBeforeAfterCheckDate(reminderLine.getDaysBeforeAfterCheckDate().longValue());
		reminderConfigLine.setReminderSendOption(reminderLine.getReminderSendOption());
		reminderConfigLine.setObjectId(ObjectConstants.OBJECT_ESIGN_DOCUMENT);
		reminderConfigLine.setEnabled(reminderLine.getIsEnabled());
		ElasticSearchDAO.getInstance().setCommonProperties(reminderConfigLine, userData.getUserId());
		ElasticSearchDAO.getInstance().createDocument(firmId, IdxAutoReminderConfigLine.class,
				ObjectConstants.OBJECT_REMAINDER_CONFIG_LINE, reminderConfigLine.getAutoReminderConfigLineId(),
				AppUtil.convertToJson(reminderConfigLine));

		reminderLine.setId(reminderConfigLine.getAutoReminderConfigLineId());
		return reminderLine;
	}

	/**
	 * This method used to set the template categories in configuration.
	 *
	 * @param configuration
	 */
	public void setTemplateCategories(final IdxESignConfiguration configuration) {
		final List<IdxLookup> categories = new ArrayList<>();

		IdxLookup category = new IdxLookup(1L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD,
				"Business Formation");
		categories.add(category);

		category = new IdxLookup(2L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD,
				"Business Operations");
		categories.add(category);

		category = new IdxLookup(3L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD, "Employment");
		categories.add(category);

		category = new IdxLookup(4L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD, "Financial");
		categories.add(category);

		category = new IdxLookup(5L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD, "Government Form");
		categories.add(category);

		category = new IdxLookup(6L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD, "Real Estate");
		categories.add(category);

		category = new IdxLookup(7L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD, "Sworn Statement");
		categories.add(category);

		category = new IdxLookup(8L, null, null, AppConstants.YES, null, AppConstants.STR_STANDARD,
				"Will & Estate Planning");
		categories.add(category);

		configuration.setTemplateCategories(categories);
	}

	/**
	 * This method used to set the standard templates from seeded json
	 *
	 * @param firmId
	 * @param userData
	 */
	public void setStandardTemplates(final Long firmId, final UserData userData) {
		final String standardTemplateData = AppFileUtil.getInstance()
				.readFileFromClassPath(ESignConstants.STANDARD_TEMPLATE_FILE_PATH);
		try {
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final JSONParser parser = new JSONParser();
			final JSONArray standardTemplates = (JSONArray) parser.parse(standardTemplateData);
			for (int i = 0; i < standardTemplates.size(); i++) {
				try {
				final IdxEmailTemplate standardTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class,
						standardTemplates.get(i).toString());
				standardTemplate
						.setId(AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_MESSAGE_ID));
				standardTemplate.setFirmId(firmId);

				standardTemplate.setCreatedBy(userData.getUserId());
				standardTemplate.setCreatedByName(userData.getFullName());
				standardTemplate.setCreationDate(currentDate);

				standardTemplate.setLastUpdatedBy(userData.getUserId());
				standardTemplate.setLastUpdatedByName(userData.getFullName());
				standardTemplate.setLastUpdateDate(currentDate);

				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
						standardTemplate.getId(), AppUtil.convertToJson(standardTemplate));
				} catch(Exception exception) {
					logger.info(firmId, "ESignatureService:setStandardTemplates:template:index:" + i);
					logger.error(firmId, "ESignatureService:setStandardTemplates:exception in template:", exception);
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:setStandardTemplates:exception:", exception);
		}
	}

	/**
	 * This method used to set the signer Authentication in ESign Configuration.
	 *
	 * @param configuration
	 */
	public void setSignerAuthentication(final IdxESignConfiguration configuration) {
		final List<IdxLookup> signerAuth = new ArrayList<>();

		Long signerAuthId = 1L;
		IdxLookup signerAuthentication = new IdxLookup(signerAuthId, ESignConstants.SIGNER_AUTH_EMAIL.toUpperCase(),
				ESignConstants.SIGNER_AUTH_EMAIL, null, AppConstants.NO, null, null);
		signerAuth.add(signerAuthentication);

		signerAuthId++;
		signerAuthentication = new IdxLookup(signerAuthId, ESignConstants.SIGNER_AUTH_PASSCODE.toUpperCase(),
				ESignConstants.SIGNER_AUTH_PASSCODE, null, AppConstants.NO, null, null);
		signerAuth.add(signerAuthentication);

		signerAuthId++;
		signerAuthentication = new IdxLookup(signerAuthId, ESignConstants.SIGNER_AUTH_PHONE.toUpperCase(),
				ESignConstants.SIGNER_AUTH_PHONE, null, AppConstants.NO, null, null);
		signerAuth.add(signerAuthentication);

		configuration.setSignerAuth(signerAuth);
	}

	/**
	 * This method used to set the Legal Disclosure Content in IdxESignConfiguration.
	 *
	 * @param configuration
	 */
	public void setLegalDisclosureContent(final IdxESignConfiguration configuration) {
		final List<IdxLookup> ldc = new ArrayList<>();
		final IdxLookup ld = new IdxLookup();
		ld.setId(1L);
		ld.setIsEnabled(AppConstants.YES);
		ld.setMmc(ESignConstants.MODAL_MESSAGE_DEFAULT_CONTENT);
		ld.setMal(ESignConstants.MODAL_ACTION_LABEL_DEFAULT_LABEL);
		ldc.add(ld);
		configuration.setLdc(ldc);
	}

	/**
	 * This method used to update the ESignDocument.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 */
	public void updateESignDocument(final Long firmId, final IdxESignDocument idxESignDocument) {
		ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT,
				idxESignDocument.geteSignDocumentId(), AppUtil.convertToJson(idxESignDocument));
	}

	/**
	 * This method used to createESignDocument PDF pages, signers list
	 *
	 * @param userData
	 * @param fileName
	 * @param pdfBytes
	 * @param eSignAttributes
	 * @param signerData
	 * @param associatedObject
	 * @param signType
	 * @param isSequential
	 * @param fa
	 * @param isResend
	 * @param brandId
	 *
	 * @return
	 */
	public IdxESignDocument createESignDocumentWithPDFBytes(UserData userData, String fileName, byte[] pdfBytes,
			Map<String, JSONObject> eSignAttributes, String signerData, IdxObject associatedObject, String signType,
			Boolean isSequential, final String fa, final Boolean isResend, final String brandId) {
		final Long firmId = userData.getFirmId();
		final Long userId = userData.getUserId();
		final Long objectId = associatedObject.getObjectId();
		final Long objectRefId = associatedObject.getObjectRefId();
		
		final IdxESignDocument eSignDocument = new IdxESignDocument();
		final String currentDate = DateUtil.getEsDateFormat().format(new Date());
		eSignDocument.seteSignDocumentId(
				AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_DOCUMENT_ID));
		eSignDocument.setCreatedBy(userId);
		eSignDocument.setLastUpdatedBy(userId);
		eSignDocument.setCreationDate(currentDate);
		eSignDocument.setLastUpdateDate(currentDate);
		eSignDocument.setCreatedByName(userData.getFullName());
		eSignDocument.setLastUpdatedByName(userData.getFullName());
		eSignDocument.setFirmId(firmId);
		eSignDocument.setSignType(signType);
		eSignDocument.setIsSequential(isSequential);
		eSignDocument.setObjectStatus(AppConstants.OBJECT_STATUS_ACTIVE);

		final String revId = eSignDocument.geteSignDocumentId().toString() + "_o";
		final String documentData = AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(pdfBytes);
		final IdxESignDocRevisions idxESignDocRevision = saveESignDocRevision(firmId,
				ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId, documentData);

		// Saving File content and saving the hashcode.
		final String fileData = writeFile(firmId, eSignDocument.getCreatedBy(), eSignDocument.geteSignDocumentId(),
				documentData);
		saveToBlockChain(firmId, idxESignDocRevision.getId(), userData.getFullName(), fileData);
		deleteFileIfExists(firmId, fileData);

		eSignDocument.setSource(ESignConstants.SOURCE_APPTIVO);
		eSignDocument.setFileExt(ESignConstants.FILE_EXT_PDF);
		
		final IdxObject senderDetails = new IdxObject();
		senderDetails.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
		senderDetails.setObjectRefId(userData.getEmployeeId());
		senderDetails.setObjectRefName(userData.getFullName());
		senderDetails.setEmailId(userData.getEmailId());
		senderDetails.setSourceRefId(userData.getUserId().toString());
		eSignDocument.setSenderDetails(senderDetails);

		eSignDocument.getAssignees().add(senderDetails);

		// Prepare signers list for eSignDocument.
		final List<IdxESignSigner> idxESignSigners = new ArrayList<>();
		try {
			final JSONParser parser = new JSONParser();
			final JSONArray eSigners = (JSONArray) parser.parse(signerData);
			for (int eSignerIndex = 0; eSignerIndex < eSigners.size(); eSignerIndex++) {
				final JSONObject eSigner = (JSONObject) eSigners.get(eSignerIndex);
				final IdxESignSigner idxESignSigner = AppUtil.convertFromJson(IdxESignSigner.class,
						eSigner.toJSONString());
				idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_NEW.toUpperCase());
				idxESignSigner.setSignerActions(ESignConstants.SIGNER_ACTION_NEED_SIGN);
				idxESignSigner.seteSignSignerId(
						AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_SIGNER_ID));
				idxESignSigners.add(idxESignSigner);
			}
			eSignDocument.setSigners(idxESignSigners);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:createESignDocumentWithPDFBytes:exception:", exception);
		}

		associatedObject.setObjectRefName(fileName);
		final String objectRefNumber = updateAssociateObject(firmId, objectId, objectRefId,
				eSignDocument.geteSignDocumentId(), signType, null, null);
		if (objectRefNumber != null) {
			associatedObject.setSourceRefId(objectRefNumber);
			final String docName = getDocumentNameESign(firmId, objectId, objectRefNumber);
			if (docName != null) {
				eSignDocument.setDocumentName(docName);
			}
		}
		eSignDocument.setAssociatedObject(associatedObject);

		// Setting File Attachments details
		if (AppUtil.checkStringNullOrNot(fa)) {
			final List<IdxObject> fas = new Gson().fromJson(fa, new TypeToken<List<IdxObject>>() {
			}.getType());
			eSignDocument.setFa(fas);
		}

		// Setting isResend value
		eSignDocument.setIsResend(isResend);

		// Setting brand Id
		eSignDocument.setbId(brandId);

		// Updating document status based on the signers and sign type.
		setDocumentStatusBySignType(eSignDocument, false);

		// prepare each pages base64 and it's respective eSign attributes.
		prepareESignDocumentPage(firmId, userId, eSignDocument, eSignAttributes, documentData);

		updateESignDocument(firmId, eSignDocument);
		
		return eSignDocument;
	}

	/**
	 * This method used to check the inputValue is in range of min and max.
	 *
	 * @param inputValue
	 * @param minValueInclusive
	 * @param maxValueInclusive
	 * @return
	 */
	public boolean inRange(final Double inputValue, final Double minValueInclusive, final Double maxValueInclusive) {
		boolean isRange = false;
		if (inputValue >= minValueInclusive && inputValue <= maxValueInclusive) {
			isRange = true;
		}
		return isRange;
	}

	/**
	 * This method used to calculate the page dimension for PDF document
	 *
	 * @param idxESignDocument
	 */
	public void calculatePDFPageDimension(final IdxESignDocument idxESignDocument) {
		final Double width = idxESignDocument.getDocumentPages().get(0).getWidth();
		final Double height = idxESignDocument.getDocumentPages().get(0).getHeight();

		if(inRange(width, ESignConstants.PORTRAIT_A4_WIDTH - 10D, ESignConstants.PORTRAIT_A4_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_A4_HEIGHT - 10D, ESignConstants.PORTRAIT_A4_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.A4);
		} else if(inRange(width, ESignConstants.PORTRAIT_LETTER_WIDTH - 10D, ESignConstants.PORTRAIT_LETTER_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_LETTER_HEIGHT - 10D, ESignConstants.PORTRAIT_LETTER_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.LETTER);
		} else if(inRange(width, ESignConstants.PORTRAIT_TABLOID_WIDTH - 10D, ESignConstants.PORTRAIT_TABLOID_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_TABLOID_HEIGHT - 10D, ESignConstants.PORTRAIT_TABLOID_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.TABLOID);
		} else if(inRange(width, ESignConstants.PORTRAIT_LEGAL_WIDTH - 10D, ESignConstants.PORTRAIT_LEGAL_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_LEGAL_HEIGHT - 10D, ESignConstants.PORTRAIT_LEGAL_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.LEGAL);
		} else if(inRange(width, ESignConstants.PORTRAIT_EXECUTIVE_WIDTH - 10D, ESignConstants.PORTRAIT_EXECUTIVE_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_EXECUTIVE_HEIGHT - 10D, ESignConstants.PORTRAIT_EXECUTIVE_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.EXECUTIVE);
		} else if(inRange(width, ESignConstants.PORTRAIT_FOLIO_WIDTH - 10D, ESignConstants.PORTRAIT_FOLIO_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_FOLIO_HEIGHT - 10D, ESignConstants.PORTRAIT_FOLIO_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.FOLIO);
		} else if(inRange(width, ESignConstants.PORTRAIT_A3_WIDTH - 10D, ESignConstants.PORTRAIT_A3_WIDTH + 10D)
				&& inRange(height, ESignConstants.PORTRAIT_A3_HEIGHT - 10D, ESignConstants.PORTRAIT_A3_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.A3);
		} else if(inRange(width, ESignConstants.LANDSCAPE_A4_WIDTH - 10D, ESignConstants.LANDSCAPE_A4_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_A4_HEIGHT - 10D, ESignConstants.LANDSCAPE_A4_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.A4);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_LETTER_WIDTH - 10D, ESignConstants.LANDSCAPE_LETTER_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_LETTER_HEIGHT - 10D, ESignConstants.LANDSCAPE_LETTER_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.LETTER);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_TABLOID_WIDTH - 10D, ESignConstants.LANDSCAPE_TABLOID_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_TABLOID_HEIGHT - 10D, ESignConstants.LANDSCAPE_TABLOID_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.TABLOID);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_LEGAL_WIDTH - 10D, ESignConstants.LANDSCAPE_LEGAL_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_LEGAL_HEIGHT - 10D, ESignConstants.LANDSCAPE_LEGAL_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.LEGAL);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_EXECUTIVE_WIDTH - 10D, ESignConstants.LANDSCAPE_EXECUTIVE_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_EXECUTIVE_HEIGHT - 10D, ESignConstants.LANDSCAPE_EXECUTIVE_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.EXECUTIVE);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_EXECUTIVE_1_WIDTH - 10D, ESignConstants.LANDSCAPE_EXECUTIVE_1_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_EXECUTIVE_1_HEIGHT - 10D, ESignConstants.LANDSCAPE_EXECUTIVE_1_HEIGHT + 10D)){
			idxESignDocument.getAssociatedObject().setType(ESignConstants.EXECUTIVE);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_FOLIO_WIDTH - 10D, ESignConstants.LANDSCAPE_FOLIO_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_FOLIO_HEIGHT - 10D, ESignConstants.LANDSCAPE_FOLIO_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.FOLIO);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_FOLIO_1_WIDTH - 10D, ESignConstants.LANDSCAPE_FOLIO_1_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_FOLIO_1_HEIGHT - 10D, ESignConstants.LANDSCAPE_FOLIO_1_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.FOLIO);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		} else if(inRange(width, ESignConstants.LANDSCAPE_A3_WIDTH - 10D, ESignConstants.LANDSCAPE_A3_WIDTH + 10D)
				&& inRange(height, ESignConstants.LANDSCAPE_A3_HEIGHT - 10D, ESignConstants.LANDSCAPE_A3_HEIGHT + 10D)) {
			idxESignDocument.getAssociatedObject().setType(ESignConstants.A3);
			idxESignDocument.getAssociatedObject().setLandscape(true);
		}
	}

	/**
	 * This method used to create pdf's page base64 and eSign attributes of
	 * respective pages.
	 * 
	 * @param firmId
	 * @param userId
	 * @param eSignDocument
	 * @param eSignAttributes
	 */
	public Map<String, Object> prepareESignDocumentPage(Long firmId, Long userId, final IdxESignDocument eSignDocument,
			final Map<String, JSONObject> eSignAttributes, final String documentData) {
		final Map<String, Object> result = new HashMap<>();
		
		try {
			// PDF temporary file location.
			final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId
					+ "_" + userId + "_" + eSignDocument.geteSignDocumentId() + "_" + System.currentTimeMillis()
					+ AppConstants.PDF_FILE_EXTENSION;
//			final String inputPDFName = eSignDocument.getFirmId() + "_" + eSignDocument.geteSignDocumentId()
//					+ AppConstants.PDF_FILE_EXTENSION;
			logger.info(firmId, "ESignatureService:prepareESignDocumentPage:inputPDFName:" + inputPDFName);

			// PDF pages image temporary file location.
			final String inputPNGName = ApplicationProperties.getProperty(AppConstants.IMAGE_BASE_PATH) + "/" + firmId
					+ "_" + userId + "_" + eSignDocument.geteSignDocumentId() + "_" + System.currentTimeMillis();
//			final String inputPNGName = eSignDocument.getFirmId() + "_" + eSignDocument.geteSignDocumentId();
			logger.info(firmId, "ESignatureService:prepareESignDocumentPage:inputPNGName:" + inputPNGName);

			Long attrUniqueId = 0L;

			// Preparing the Visibility condition
			final Map<Long, IdxCriteriaSet> criteriaByAttr = new HashMap<>();

			// Creating a PDF from PDF base 64 - documentData.
			final File createdInputPDF = new File(inputPDFName);
			byte[] decodedPDF = Base64.decodeBase64(documentData.split(",")[1]);
			FileUtils.writeByteArrayToFile(createdInputPDF, decodedPDF);
			final Path createInputPDF = Paths.get(inputPDFName);

			// Loading the PDF document and iterating each pages.
			final PDDocument document = PDDocument.load(createdInputPDF);

			int dpi = ESignConstants.DPI_144;
			// For PDFForm, making the form fields as read-only and check box as non viewable
			final PDAcroForm pdAcroForm = document.getDocumentCatalog().getAcroForm();
			if (pdAcroForm != null && !pdAcroForm.getFields().isEmpty()) {
				dpi = ESignConstants.DPI_180;
			}

			final PDFRenderer pdfRenderer = new PDFRenderer(document);
			for (int page = 0; page < document.getNumberOfPages(); ++page) {
				final Long pageNumber = page + 1L;

				// Preparing the eSignAttributes from PDF with eSignLabels.
				final Map<String, String> eSignAttrMap = new HashMap<>();
				final IdxEsignDocumentPage documentPage = new IdxEsignDocumentPage();

				// Converting PDF pages to a image.
				final BufferedImage bim = pdfRenderer.renderImageWithDPI(page, dpi, ImageType.RGB);
				ImageIOUtil.writeImage(bim, inputPNGName + "_" + pageNumber + AppConstants.JPEG_FILE_EXTENSION , dpi);

				// Setting PDF page image's base64 and page number.
				final Path createInputPng = Paths.get(inputPNGName + "_" + pageNumber + AppConstants.JPEG_FILE_EXTENSION);
				final File file = new File(inputPNGName + "_" + pageNumber + AppConstants.JPEG_FILE_EXTENSION);
				
				FileInputStream fileInputStreamReader = null;
				
				try
				{
					fileInputStreamReader = new FileInputStream(file);
					
					byte[] bytes = new byte[(int) file.length()];
					
					int readedBytes = fileInputStreamReader.read(bytes);
					if (readedBytes > -1) {
						documentPage.setPageNumber(pageNumber.intValue());
						documentPage.setDocumentData(AppConstants.BASE64_PREFIX_JPEG + Base64.encodeBase64String(bytes));
						documentPage.seteSignAttributes(documentPage.geteSignAttributes());
	
						// Calculating the page dimension (points to pixels conversion) using PageFormat.
	
						//For Reference
						// final PDPage currentPage = document.getPage(page);
						// final PDRectangle currentPageMedia = currentPage.getMediaBox();
	
						final PDFPageable pdfPageable = new PDFPageable(document);
						final PageFormat pageFormat = pdfPageable.getPageFormat(page);
						documentPage.setWidth(Double.valueOf(pageFormat.getWidth() * ESignConstants.PAGE_RATIO));
						documentPage.setHeight(Double.valueOf(pageFormat.getHeight() * ESignConstants.PAGE_RATIO));
					}
					
					Files.delete(createInputPng);
				} finally
				{
					if(fileInputStreamReader != null)
					{
						fileInputStreamReader.close();
					}
				}

				// Setting the eSignAttributes based on the labels in PDF Template (Estimate, WorkOrder and Contracts).
				if (AppUtil.checkMapIsNullOrNot(eSignAttributes)) {

					// Getting locations of eSign attributes
					final PDFTextStripper stripper = new PDFTextStripper() {
						@Override
						protected void writeString(String string, List<TextPosition> textPositions) {
							if (AppUtil.checkStringNullOrNot(string) && string.contains("_s_")) {
								/// In PDF,
								// For Signature, Text, Initial, Name, Date
								// - labels id       - 1_s_lb
								// - placeHolder id  - 1_s_ph
								// For Radio
								// label id     - 1_s_lb
								// Options id   - 1_s_0 / 1_s_1

								// string - 0_s_lb Signature 1
								final String[] attrArr = string.trim().split(" ");

								final String[] attrId = attrArr[0].trim().split("_");

								final JSONObject attrObj = eSignAttributes.get(attrId[0]);
								if (attrObj != null) {
									final String attrType = (String) attrObj.get(ESignConstants.ATTR_TYPE);

									TextPosition text = textPositions.get(textPositions.size() - 1);
									if("lb".equals(attrId[2])) {
										text = textPositions.get(0);
									}

									Double locXRatio = Double.valueOf(text.getXDirAdj())
											- ESignConstants.DEFAULT_ATTR_LOCX_RATIO.get(attrType);
									Double locYRatio = Double.valueOf(text.getYDirAdj())
											- ESignConstants.DEFAULT_ATTR_LOCY_RATIO.get(attrType);

									if(eSignAttrMap.get(attrId[0]) == null) {
										eSignAttrMap.put(attrId[0], AppUtil.convertToJson(new IdxEsignAttribute()));
									}

									final IdxEsignAttribute idxESignAttribute = AppUtil.convertFromJson(IdxEsignAttribute.class,
											eSignAttrMap.get(attrId[0]));

									idxESignAttribute.setHeight(ESignConstants.DEFAULT_ATTR_HEIGHT.get(attrType));
									idxESignAttribute.setWidth(ESignConstants.DEFAULT_ATTR_WIDTH.get(attrType));

									if ("lb".equals(attrId[2])) {
										final IdxLabel al = new IdxLabel();
										al.setLocX((text.getXDirAdj() * ESignConstants.PAGE_RATIO)
												+ ESignConstants.DEFAULT_ATTR_LB_LOCX_RATIO.get(attrType));
										al.setLocY((text.getYDirAdj() * ESignConstants.PAGE_RATIO)
												- ESignConstants.DEFAULT_ATTR_LB_LOCY_RATIO.get(attrType));
										al.setLabelName((String) attrObj.get(ESignConstants.ATTR_LABEL));
										al.setAlign((String) attrObj.get(ESignConstants.ATTR_ALIGN));
										al.setIlb((Boolean) attrObj.get(ESignConstants.ATTR_BOLD));
										al.setIli((Boolean) attrObj.get(ESignConstants.ATTR_ITALIC));
										al.setLfs((String) attrObj.get(ESignConstants.ATTR_FONTSIZE));
										al.setIlu((Boolean) attrObj.get(ESignConstants.ATTR_UNDERLINE));
										al.setLf((String) attrObj.get(ESignConstants.ATTR_FONT));
										

										// Setting the font color based on the color format
										final String attrFont = (String) attrObj.get(ESignConstants.ATTR_FONTCOLOR);
										setLabelFontColor(firmId, attrFont.trim(), al);

										idxESignAttribute.setAl(al);
									} else if("ph".equals(attrId[2])) {
										idxESignAttribute.setLocationX(locXRatio * ESignConstants.PAGE_RATIO);
										idxESignAttribute.setLocationY(locYRatio * ESignConstants.PAGE_RATIO);
									} else if(attrId[2].matches("[0-9]+")) {
										final List<String> labels = (List<String>) attrObj.get(ESignConstants.ATTR_OPTIONS);
										final List<IdxLabel> idxLbs = idxESignAttribute.getLb();

										// Initializing the labels array
										if(idxLbs.isEmpty()) {
											for(int i =0; i < labels.size(); i++) {
												idxLbs.add(new IdxLabel());
											}
										}

										final int lbIndex = Long.valueOf(attrId[2]).intValue();

										final IdxLabel idxLabel = new IdxLabel();
										idxLabel.setLocX(ESignConstants.PAGE_RATIO);
										idxLabel.setLocY(locYRatio * ESignConstants.PAGE_RATIO);
										idxLabel.setLabelName(labels.get(lbIndex));

										idxLbs.set(lbIndex, idxLabel);

										if (lbIndex > 0) {
											idxESignAttribute.setHeight(idxLabel.getLocY() + 20);
										}

										idxESignAttribute.setLb(idxLbs);
									}
									
									idxESignAttribute.setSignatureType(attrType);
									idxESignAttribute.setUniqueId((Long) attrObj.get(AppConstants.ID));

									if(attrObj.get(ESignConstants.ATTR_IS_MANDATORY) == null) {
										idxESignAttribute.setReq(true);
									} else {
										idxESignAttribute.setReq((boolean) attrObj.get(ESignConstants.ATTR_IS_MANDATORY));
									}	

									if(attrObj.get(ESignConstants.ATTR_NUMOFCOLS) == null) {
										idxESignAttribute.setCl(1L);
									} else {
										idxESignAttribute.setCl((Long) attrObj.get(ESignConstants.ATTR_NUMOFCOLS));
									}

									final IdxCriteriaSet criteriaSet = (IdxCriteriaSet) attrObj.get(ESignConstants.VC);
									if (criteriaSet != null) {
										criteriaByAttr.put(idxESignAttribute.getUniqueId(), criteriaSet);
									}

									idxESignAttribute.seteSignSigner(eSignDocument
											.getESignSignerByAttributeId((String) attrObj.get(ESignConstants.ATTR_WHO)));
									if (ESignConstants.TYPE_NAME
											.equalsIgnoreCase(idxESignAttribute.getSignatureType())) {
										idxESignAttribute
												.setValue(idxESignAttribute.geteSignSigner().getObjectRefName());
										idxESignAttribute.setIsCompleted(true);
									}
									eSignAttrMap.put(attrId[0], AppUtil.convertToJson(idxESignAttribute));
								}
							}
						}
					};
					stripper.setSortByPosition(false);
					stripper.setStartPage(pageNumber.intValue());
					stripper.setEndPage(pageNumber.intValue());
					stripper.getText(document);
				}

				for (Map.Entry<String, String> eSignAttributesStr : eSignAttrMap.entrySet()) {
					final IdxEsignAttribute idxESignAttribute = AppUtil.convertFromJson(IdxEsignAttribute.class,
							eSignAttributesStr.getValue());
					if(idxESignAttribute.getUniqueId() == null) {
						idxESignAttribute.setUniqueId(attrUniqueId++);
					}

					idxESignAttribute.setPageNumber(pageNumber);
					documentPage.geteSignAttributes().add(idxESignAttribute);
				}
				eSignDocument.getDocumentPages().add(documentPage);
			}

			eSignDocument.setVc(prepareVcForESign(firmId, criteriaByAttr));

			document.close();
			Files.delete(createInputPDF);

			if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(eSignDocument.getAssociatedObject().getObjectId())) {
				calculatePDFPageDimension(eSignDocument);
			}
			eSignDocument.setTotalPages((long) eSignDocument.getDocumentPages().size());

			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		} catch (InvalidPasswordException exception) {
			logger.error(firmId, "ESignatureService:prepareESignDocumentPage:InvalidPasswordException:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_PASS_PROTECTED);
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:prepareESignDocumentPage:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_RUN_TIME_EXCEPTION);
		}
		
		return result;
	}
	
	/**
	 * This method used to return attribute details based on uniqueId
	 * We pass PDF sting to this method its check if sting equal to attribute unique id it return that attribute details 
	 * @param eSignAttributes
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Object> getESignAttr(final Map<Long, List<JSONObject>> eSignAttributes, final String uniqueId) {
		Map<String, Object> result = new HashMap<>();
		for (Map.Entry<Long, List<JSONObject>> entry : eSignAttributes.entrySet()) {
			if (AppUtil.checkListisNullOrNot(entry.getValue())) {
				for (int i = 0; i < entry.getValue().size(); i++) {
					Long attrIndex = (Long) entry.getValue().get(i).get(AppConstants.ID);
					// check PDF string with attribute uniqueId
					if (uniqueId.equalsIgnoreCase(attrIndex.toString() + "_sign")) {
						String attrType = entry.getValue().get(i).get(ESignConstants.ATTR_TYPE).toString();
						if (ESignConstants.TYPE_ESIGNATURE.equalsIgnoreCase(attrType)) {
							attrType = ESignConstants.TYPE_SIGNATURE;
						}
						
						List<String> attrOption = (List<String>) entry.getValue().get(i).get(ESignConstants.ATTR_OPTIONS);
						
						Boolean isMandatory = false;
						isMandatory = (Boolean) entry.getValue().get(i).get(ESignConstants.ATTR_IS_MANDATORY);
						if (isMandatory == null) {
							isMandatory = true;
						}

						IdxCriteriaSet idxCriteriaSet = null;
						idxCriteriaSet = (IdxCriteriaSet) entry.getValue().get(i).get(ESignConstants.VC);
						
						String objectName = null;
						objectName = entry.getValue().get(i).get(ESignConstants.ATTR_WHO).toString();

						result.put(ESignConstants.ATTR_TYPE, attrType);
						result.put(ESignConstants.ATTR_OPTIONS, attrOption);
						result.put(ESignConstants.ATTR_IS_MANDATORY, isMandatory);
						result.put(AppConstants.ID, attrIndex);
						result.put(ESignConstants.VC, idxCriteriaSet);
						result.put(ESignConstants.ATTR_WHO, objectName);

						entry.getValue().remove(i);
						break;
					}
				}
			}
		}
		return result;
	}
	
	/**
	 * This method used to prepare the Visibility condition for ESign
	 * @param criteriaMap
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public String prepareVcForESign(final Long firmId, final Map<Long, IdxCriteriaSet> criteriaMap) {
		try {
			final Map<String, List<JSONObject>> result = new HashMap<>();
			final JSONObject cd = new JSONObject();
			final JSONObject attrId = new JSONObject();
			for (Map.Entry<Long, IdxCriteriaSet> entry : criteriaMap.entrySet()) {
				if (entry.getValue() != null) {
					JSONObject conditionObj = null;
					IdxCriteriaSet criteriaSet = entry.getValue();
					for (int s = 0; s < criteriaSet.getConditionSets().size(); s++) {
						final IdxCriteriaSet idxCriteriaSet = criteriaSet.getConditionSets().get(s);
						for (int g = 0; g < idxCriteriaSet.getGroups().size(); g++) {
							final IdxCriteriaGroup group = idxCriteriaSet.getGroups().get(g);
							boolean grpJnCond = group.isJoinCondition();
							for (int c = 0; c < group.getConditions().size(); c++) {
								final IdxCriteriaCondition condition = group.getConditions().get(c);
								conditionObj = new JSONObject();

								final JSONObject drAttr = new JSONObject();
								drAttr.put("id", condition.getAttribute().getId());
								drAttr.put("type", condition.getAttribute().getType());
								conditionObj.put("drAttr", drAttr);

								String opt = condition.getCondition();
								if ("=".equals(opt)) {
									opt = "Is equal to";
								} else if ("<>".equals(opt)) {
									opt = "Is not equal to";
								}
								final JSONObject drOpt = new JSONObject();
								drOpt.put("name", opt);
								conditionObj.put("drOpt", drOpt);

								if ("text".equalsIgnoreCase(condition.getAttribute().getType())) {
									final JSONObject drVal = new JSONObject();
									drVal.put("value", condition.getValue());
									conditionObj.put("drVal", drVal);
								} else if ("Is equal to".equals(opt) || "Is not equal to".equals(opt)) {
									final JSONObject drVal = new JSONObject();
									drVal.put("value", condition.getOptionValue().getOptionValue());
									conditionObj.put("drVal", drVal);
								}

								if (c == 0) {
									conditionObj.put("jnCnd", grpJnCond);
								} else {
									conditionObj.put("jnCnd", true);
								}

								List<JSONObject> conditions = result.get(entry.getKey().toString());
								if (conditions == null) {
									conditions = new ArrayList<>();
								}
								conditions.add(conditionObj);
								result.put(entry.getKey().toString(), conditions);
							}
						}
					}
					attrId.put(entry.getKey(), result.get(entry.getKey().toString()));
				}
			}
			cd.put("cd", attrId);
			return cd.toString();
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:prepareVcForESign:exception:", exception);
		}
		return null;
	}

	/**
	 * This method used to calculate the total pages of document
	 *
	 * @param firmId
	 */
	public Map<String, Object> calculateTotalPages(final Long firmId, final String filePath) {
		final Map<String, Object> result = new HashMap<>();

		try {
			final File createdInputPDF = new File(filePath);

			if (filePath.contains(AppConstants.PNG_FILE_EXTENSION)
					|| filePath.contains(AppConstants.JPG_FILE_EXTENSION)
					|| filePath.contains(AppConstants.JPEG_FILE_EXTENSION)) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				result.put(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES, 1L);
			} else {
				final PDDocument document = PDDocument.load(createdInputPDF);
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				result.put(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES, (long) document.getNumberOfPages());

				document.close();
			}
		} catch (InvalidPasswordException exception) {
			logger.error(firmId, "ESignatureService:calculateTotalPages:InvalidPasswordException:exception:",
					exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_PASS_PROTECTED);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:calculateTotalPages:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_RUN_TIME_EXCEPTION);
		}
		return result;
	}

	/**
	 * This method used to get the document redirection URL.
	 * 
	 * Example: https://app.sign.co/app/ng/sign.jsp#/sg/document?id=<DOCUMENT_ID>
	 * 
	 * @param firmId
	 * @param eSignDocumentId
	 * @param timeZoneId
	 * @param objectId
	 * @param dateFormat
	 * @return
	 */
	public String getDocumentRedirectionURL(final Long firmId, final Long eSignDocumentId, final String timeZoneId,
			final Long objectId, final String dateFormat) {
		IdxFirmESignDocument firmESignDocument = getFirmESignDocument(firmId, eSignDocumentId);
		logger.info(firmId, "ESignatureService:getDocumentRedirectionURL:firmESignDocument:" + firmESignDocument);

		if (firmESignDocument == null) {
			firmESignDocument = new IdxFirmESignDocument();

			firmESignDocument.setFirmESignDocumentId(UUID.randomUUID().toString());

			firmESignDocument.setFirmId(firmId);
			firmESignDocument.setDocumentId(eSignDocumentId);
			if(timeZoneId != null) {
				firmESignDocument.setTimeZoneId(timeZoneId);
			}
			if(objectId != null) {
				firmESignDocument.setObjectId(objectId);
			}
			if(dateFormat != null) {
				firmESignDocument.setDateFormat(dateFormat);
			}

			final String creationDate = DateUtil.getEsDateFormat().format(new Date());

			firmESignDocument.setCreationDate(creationDate);
			firmESignDocument.setLastUpdateDate(creationDate);

			ElasticSearchDAO.getInstance().indexDocument(AppConstants.ATHENA_INDEX_ID,
					ObjectConstants.OBJECT_FIRM_ESIGN_DOCUMENT, firmESignDocument.getFirmESignDocumentId(),
					AppUtil.convertToJson(firmESignDocument));
		}

		return AppBaseDAO.getInstance().getEnvProperty(ESignConstants.SIGN_BASE_URL, AppConstants.YES)
				+ ESignConstants.URL_PATH + "?" + ESignConstants.URL_ID_PARAM + "="
				+ firmESignDocument.getFirmESignDocumentId();
	}

	/**
	 * Getting eSignDocument by eSignSignerId.
	 * 
	 * @param firmId
	 * @param documentId
	 * @param signerId
	 * @return
	 */
	public IdxESignDocument getESignDocumentBySignerId(final Long firmId, final Long documentId, final Long signerId) {
		final IdxESignDocument idxEsignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);
		final boolean isValidDoc = validateDocBySignerId(idxEsignDocument, signerId);
		if (isValidDoc) {
			return idxEsignDocument;
		}
		return null;
	}

	/**
	 * This method used to validate the document by signer id.
	 *
	 * @param idxEsignDocument
	 * @param signerId
	 * @return
	 */
	public boolean validateDocBySignerId(final IdxESignDocument idxEsignDocument, final Long signerId) {
		boolean isValid = false;
		if (idxEsignDocument != null && ESignConstants.IN_PERSON_SIGN.equals(idxEsignDocument.getSignType())) {
			isValid = true;
		}
		if (idxEsignDocument != null && signerId != null) {
			if (signerId.equals(idxEsignDocument.getCreatedBy())) {
				isValid = true;
			}
			for (IdxESignSigner signer : idxEsignDocument.getSigners()) {
				if (signerId.equals(signer.geteSignSignerId())) {
					isValid = true;
				}
			}
		}
		return isValid;
	}

	/**
	 * This method used to generate the Audit Trail Content for PDF
	 * 
	 * @param idxESignDocument
	 * @param userTimezone
	 * @return
	 * @throws InterruptedException
	 */
	public byte[] generateAuditTrailContent(final IdxESignDocument idxESignDocument, final TimeZone userTimezone) {
		final Long firmId = idxESignDocument.getFirmId();
		try {
		final HashMap<String, Object> input = new HashMap<>();

		input.put(ESignConstants.DOC_NAME, idxESignDocument.getDocumentName());
		input.put(AppConstants.CREATED_BY, idxESignDocument.getCreatedByName());
		input.put(AppConstants.CREATION_DATE, idxESignDocument.getCreationDate());
		input.put(ESignConstants.IS_SEQUENTIAL, idxESignDocument.getIsSequential());
		input.put(ESignConstants.SIGNERS, idxESignDocument.getSignersList());

		//Preparing audit trail status based on document status.
		String status = idxESignDocument.getStatusName();
		if(ESignConstants.ESIGN_DOCUMENT_STATUS_NEW.equals(idxESignDocument.getStatusName())){
			status = "Needs Review";
		}
		else if(ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING.equals(idxESignDocument.getStatusName())){
			status = "In-Progress";
		}
		input.put(ESignConstants.STATUS_NAME,status);

		updateBrandingContent(firmId, idxESignDocument.getbId(), input);

		// For getting e-signature histories
		AppExceptionService.logThreadSleep(idxESignDocument.getFirmId(), null, null, AppConstants.DELAY.intValue());
		Thread.sleep(AppConstants.DELAY);

		input.put(ESignConstants.ESIGN_HISTORIES, getESignDocHistories(idxESignDocument.getFirmId(),
				idxESignDocument.geteSignDocumentId(), userTimezone));

		return PdfTemplateService.getInstance().getPDFData(idxESignDocument.getFirmId(), null, input,
				AppConstants.FTL_BASE_PATH, ESignConstants.AUDIT_TRAIL_FILE_NAME, null, null, false, null);
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:generateAuditTrailContent:exception:", exception);
		}
		return null;
	}

	/**
	 * This method used to generate the completed PDF with Audit trail content.
	 * 
	 * @param idxESignDocument
	 * @param pdfFileData
	 * @param userTimezone
	 * @return
	 * @throws Exception
	 */
	public void generateCompletedPDF(final IdxESignDocument idxESignDocument, final Map<String, String> pdfFileData,
			final TimeZone userTimezone) {
		
		FileInputStream fileInputStream = null;
		try {
			final String destFilePath = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
					+ idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId()
					+ "_completed_"	+ System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;
			final File destFile = new File(destFilePath);

			final String pdfFilePath = pdfFileData.get(AppConstants.FILE_PATH);
			final File pdfFile = new File(pdfFilePath);

			byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, userTimezone);

			final String auditTrailFilePath = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
					+ idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId() + "_"
					+ System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;

			final File auditTrailPdf = new File(auditTrailFilePath);
			FileUtils.writeByteArrayToFile(auditTrailPdf, auditTrailContent);

			final PDFMergerUtility pdfmerger = new PDFMergerUtility();

			// Setting the destination file
			pdfmerger.setDestinationFileName(destFilePath);

			// adding the source files
			pdfmerger.addSource(pdfFile);
			pdfmerger.addSource(auditTrailPdf);

			// Merging the two documents
			pdfmerger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());

			fileInputStream = new FileInputStream(destFilePath);
			byte[] byteInput = new byte[(int) destFile.length()];
			int numRead = fileInputStream.read(byteInput);
			logger.info(idxESignDocument.getFirmId(), "ESignatureService:prepareSignedPDFInBytes:numRead:"+ numRead);

			pdfFileData.put(AppConstants.FILE_PATH, destFilePath);
			pdfFileData.put(AppConstants.BYTES_CONTENT, Base64.encodeBase64String(byteInput));

			final Path auditTrailPDF = Paths.get(auditTrailFilePath);
			Files.deleteIfExists(auditTrailPDF);
		} catch (Exception exception) {
			logger.error(idxESignDocument.getFirmId(), "ESignatureService:generateCompletedPDF:exception:",
					exception);
		} finally
		{
			if(fileInputStream != null)
			{
				try {
					fileInputStream.close();
				} catch (IOException e) {
					logger.error(idxESignDocument.getFirmId(), "ESignatureService:generateCompletedPDF:IOException:e:", e);
				}
			}
		}
	}

	/**
	 * This method used to generate the pdf document from document pages 
	 *
	 * @param idxESignDocument
	 * @return
	 */
	public PDDocument updateDocumentData(final IdxESignDocument idxESignDocument) {
		final Long firmId = idxESignDocument.getFirmId();
		FileInputStream fileInputStreamReader = null;
		try {
			logger.info(firmId, "ESignatureService:updateDocumentData:start:");

			final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
					+ idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId() + "_Modified_"
					+ System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;
//			final String inputPDFName = idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId() 
//					+ AppConstants.PDF_FILE_EXTENSION;

			final File inputPDFFile = new File(inputPDFName);
			final Path createInputPDF = Paths.get(inputPDFName);

			final PDDocument document = new PDDocument();
			for (final IdxEsignDocumentPage documentPage : idxESignDocument.getDocumentPages()) {
				final PDPage page = new PDPage();
				final float pageWidth = BigDecimal.valueOf(documentPage.getWidth() / 1.5).floatValue();
				final float pageHeight = BigDecimal.valueOf(documentPage.getHeight() / 1.5).floatValue();
				final PDRectangle pdRectangle = new PDRectangle(pageWidth, pageHeight);
				page.setMediaBox(pdRectangle);

				final PDImageXObject pdImage = PDImageXObject.createFromByteArray(document,
						Base64.decodeBase64(documentPage.getDocumentData().split(",")[1]), null);
				BigDecimal width = BigDecimal.valueOf(documentPage.getWidth() / 1.5);
				BigDecimal height = BigDecimal.valueOf(documentPage.getHeight() / 1.5);

				final PDPageContentStream contents = new PDPageContentStream(document, page,
						PDPageContentStream.AppendMode.APPEND, false, true);
				contents.drawImage(pdImage, 0, 0, width.floatValue(), height.floatValue());
				contents.close();

				document.addPage(page);
			}
			document.save(new File(inputPDFName));

			// Updating PDF document data
			fileInputStreamReader = new FileInputStream(inputPDFFile);
			byte[] bytes = new byte[(int) inputPDFFile.length()];
			int readedBytes = fileInputStreamReader.read(bytes);
			if (readedBytes > -1) {
				final String revId = idxESignDocument.geteSignDocumentId().toString() + "_o";
				final String documentData = AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(bytes);
				final IdxESignDocRevisions idxESignDocRevisions = saveESignDocRevision(firmId,
						ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId, documentData);
				saveToBlockChain(firmId, idxESignDocRevisions.getId(), idxESignDocument.getCreatedByName(), inputPDFName);
			}

			Files.delete(createInputPDF);

			logger.info(firmId, "ESignatureService:updateDocumentData:completed:");
			return document;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateDocumentData:exception:", exception);
		} finally {
			if (fileInputStreamReader != null) {
				try {
					fileInputStreamReader.close();
				} catch (IOException e) {
					logger.error(firmId, "ESignatureService:updateDocumentData:IOException:e:", e);
				}
			}
		}
		return null;
	}

	/**
	 * This method used to prepare PDF bytes with eSigned data.
	 * 
	 * @param eSignDocument
	 * @return
	 */
	public Map<String, String> prepareSignedPDFInBytes(final IdxESignDocument eSignDocument) {
		final Map<String, String> result = new HashMap<>();
		FileInputStream fileInputStream = null;
		try {	
			final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
					+ eSignDocument.getFirmId() + "_" + eSignDocument.geteSignDocumentId() + "_"
					+ System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;
//			final String inputPDFName = eSignDocument.getFirmId() + "_" + eSignDocument.geteSignDocumentId() + "_"
//					+ AppConstants.PDF_FILE_EXTENSION;
			final Long firmId = eSignDocument.getFirmId();

			final Long associatedObjectId = eSignDocument.getAssociatedObject().getObjectId();

			final File createdInputPDF = new File(inputPDFName);

			// For Mobile Apps, we'll get the document data in IdxESignDocument.
			byte[] decodedPDF = null;
			if (eSignDocument.getDocumentData() != null) {
				decodedPDF = Base64.decodeBase64(eSignDocument.getDocumentData().split(",")[1]);
			} else {
				final String revId = eSignDocument.geteSignDocumentId().toString() + "_o";
				final IdxESignDocRevisions idxESignDocRev = getESignDocReviByObjRefId(firmId,
						ObjectConstants.OBJECT_ESIGN_DOCUMENT, revId);
				if(idxESignDocRev == null) {
					final Map<String, String> combinedPDFData = generateCombinedPdf(firmId, eSignDocument);
					if(combinedPDFData != null) {
						final IdxESignDocRevisions idxESignDocRevisions = saveESignDocRevision(firmId,
								ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId,
								combinedPDFData.get(ESignConstants.FILE_CONTENT));
						saveToBlockChain(firmId, idxESignDocRevisions.getId(), eSignDocument.getCreatedByName(),
								combinedPDFData.get(ESignConstants.FILE_NAME));
						deleteFileIfExists(firmId, combinedPDFData.get(ESignConstants.FILE_NAME));
						decodedPDF = Base64.decodeBase64(combinedPDFData.get(ESignConstants.FILE_CONTENT).split(",")[1]);
					}
				} else {
					decodedPDF = Base64.decodeBase64(idxESignDocRev.getDocData().split(",")[1]);
				}
			}

			FileUtils.writeByteArrayToFile(createdInputPDF, decodedPDF);

			final List<IdxEsignDocumentPage> idxESignDocumentPages = eSignDocument.getDocumentPages();
			PDDocument document = PDDocument.load(createdInputPDF);

			// For PDFForm, making the form fields as read-only and check box as non viewable
			final PDAcroForm pdAcroForm = document.getDocumentCatalog().getAcroForm();
			if (pdAcroForm != null && !pdAcroForm.getFields().isEmpty()) {
				final PDDocument modifiedDocument = updateDocumentData(eSignDocument);
				if(modifiedDocument != null) {
					document = modifiedDocument;
				}
			}

			for (int i = 0; i < document.getNumberOfPages(); i++) {
				final PDPage page = document.getPage(i);

				// For Reference
				// final PDRectangle mediaBox = page.getMediaBox();

				final PDFPageable pdfPageable = new PDFPageable(document);
				final PageFormat pageFormat = pdfPageable.getPageFormat(i);
				float mediaWidth = (float) pageFormat.getWidth();
				float mediaHeight = (float) pageFormat.getHeight();
				final int pageRotation = page.getRotation();

				for (IdxEsignAttribute eSignAttribute : idxESignDocumentPages.get(i).geteSignAttributes()) {
					if (eSignAttribute.isCompleted()) {
						final PDPageContentStream contents = new PDPageContentStream(document, page,
								PDPageContentStream.AppendMode.APPEND, false, true);
						Double locX = eSignAttribute.getLocationX() / ESignConstants.PAGE_RATIO;
						Double locY = mediaHeight - (eSignAttribute.getLocationY() / ESignConstants.PAGE_RATIO);

						// For E-sign we'll get locX and locY from ESignAttributes as Percentage.
						if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(associatedObjectId)) {
							// Calculating locX and locY based on the page rotation.
							if (pageRotation == 0) {
								// (0,0) at Bottom left - Ordinary docs
								locX = (eSignAttribute.getLocationX() * mediaWidth / 100) / 1;
								locY = mediaHeight - (eSignAttribute.getLocationY() * mediaHeight / 100) / 1;
							} else if (pageRotation == 90) {
								// (0,0) at Top left - Adobe Distiller docs
								locX = ((eSignAttribute.getLocationY() * mediaHeight / 100) / 1) + 20;
								locY = ((eSignAttribute.getLocationX() * mediaWidth / 100) / 1) + 20;
							} else if (pageRotation == 270) {
								// (0,0) at Bottom right - SOW doc
								locX = (mediaHeight - (eSignAttribute.getLocationY() * (mediaHeight) / 100) / 1) - 20;
								locY = (mediaWidth - (eSignAttribute.getLocationX() * (mediaWidth) / 100) / 1) + 20;
							}
						}

						// ESign - For Writing labels
						if (eSignAttribute.getAl() != null && eSignAttribute.getValue() != null) {
							writeLabel(firmId, document, eSignAttribute, contents, mediaHeight,eSignDocument.getAssociatedObject());
						}

						if (ESignConstants.TYPE_SIGNATURE.equalsIgnoreCase(eSignAttribute.getSignatureType())
								&& eSignAttribute.getValue() != null
								&& eSignAttribute.getValue().indexOf(AppConstants.BASE64) > -1) {
							drawSignature(firmId, document, eSignAttribute, associatedObjectId, locX, locY, contents,
									pageRotation);
						} else if (ESignConstants.TYPE_INITIALS.equalsIgnoreCase(eSignAttribute.getSignatureType())
								&& eSignAttribute.getValue() != null
								&& eSignAttribute.getValue().indexOf(AppConstants.BASE64) > -1) {
							drawInitial(firmId, document, eSignAttribute, locX, locY, contents, pageRotation, associatedObjectId);
						} else if (ESignConstants.TYPE_CHECKBOX.equalsIgnoreCase(eSignAttribute.getSignatureType())
								&& eSignAttribute.getValue() != null
								&& eSignAttribute.getValue().indexOf(AppConstants.BASE64) > -1) {
							drawCheckBox(firmId, document, eSignAttribute, locX, locY, contents, pageRotation);
						} else if (ESignConstants.TYPE_TEXT.equalsIgnoreCase(eSignAttribute.getSignatureType())
								&& eSignAttribute.getValue() != null) {
							drawText(firmId, eSignAttribute, locX.floatValue(), locY.floatValue(), contents,
									pageRotation, associatedObjectId);
						} else if (ESignConstants.TYPE_RADIO.equalsIgnoreCase(eSignAttribute.getSignatureType())
								&& eSignAttribute.getValue() != null) {
							drawRadio(firmId, document, eSignAttribute, associatedObjectId, locX.floatValue(),
									locY.floatValue(), contents,pageRotation);
						} else if ((ESignConstants.TYPE_NAME.equalsIgnoreCase(eSignAttribute.getSignatureType())
								|| ESignConstants.TYPE_DATE.equalsIgnoreCase(eSignAttribute.getSignatureType()))
								&& eSignAttribute.getValue() != null) {
							writeText(firmId, eSignAttribute, associatedObjectId, locX.floatValue(), locY.floatValue(),
									contents, pageRotation);
						}

						contents.close();
					}
				}
			}
			// To Resolve the security issue.
			// Caused by: java.lang.IllegalStateException:
			//	PDF contains an encryption dictionary, please remove it with setAllSecurityToBeRemoved() or
			// set a protection policy with protect()
			document.setAllSecurityToBeRemoved(true);

			document.save(createdInputPDF);

			document.close();

			fileInputStream = new FileInputStream(createdInputPDF);
			final byte[] byteInput = new byte[(int) createdInputPDF.length()];
			int numRead = fileInputStream.read(byteInput);

			logger.info("ESignatureService:prepareSignedPDFInBytes:numRead:"+ numRead);
			result.put(AppConstants.FILE_PATH, inputPDFName);
			result.put(AppConstants.BYTES_CONTENT, Base64.encodeBase64String(byteInput));
			return result;
		} catch (IOException exception) {
			logger.error("ESignatureService:prepareSignedPDFInBytes:exception:", exception);
		} finally
		{
			if(fileInputStream != null)
			{
				try {
					fileInputStream.close();
				} catch (IOException exception) {
					logger.error("ESignatureService:prepareSignedPDFInBytes:exception:", exception);
				}
			}
		}
		return null;
	}

	/**
	 * This method used to draw the signature in PDF.
	 * 
	 * @param firmId
	 * @param document
	 * @param eSignAttribute
	 * @param objectId
	 * @param imageLocX
	 * @param imageLocY
	 * @param contents
	 * @param pageRotation
	 */
	@SuppressWarnings("deprecation")
	public void drawSignature(final Long firmId, final PDDocument document, final IdxEsignAttribute eSignAttribute,
			final Long objectId, Double imageLocX, Double imageLocY, final PDPageContentStream contents,
			final int pageRotation) {
		try {
			final PDImageXObject pdImage = PDImageXObject.createFromByteArray(document,
					Base64.decodeBase64(eSignAttribute.getValue().split(",")[1]), null);

			int pdImageWidth = pdImage.getWidth();
			int pdImageHeight = pdImage.getHeight();
			final Long attrNumColums = eSignAttribute.getCl();

			BigDecimal imageWidth;
			BigDecimal imageHeight;

			// For ESign - Signature Positioning and Dimension Calculation.
			if (!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)) {
				if (pdImageWidth > pdImageHeight) {
					// Large Signatures
					imageWidth = BigDecimal.valueOf(eSignAttribute.getWidth() / ESignConstants.PAGE_RATIO);
					imageHeight = BigDecimal.valueOf(eSignAttribute.getHeight() / ESignConstants.PAGE_RATIO);
				} else {
					// Small Signatures
					imageHeight = BigDecimal.valueOf(eSignAttribute.getHeight() / ESignConstants.PAGE_RATIO);

					imageWidth = BigDecimal.valueOf(pdImageWidth).divide(new BigDecimal(pdImageHeight), 4,
							RoundingMode.HALF_EVEN);
					imageWidth = imageWidth.multiply(BigDecimal.valueOf(eSignAttribute.getHeight()));
					imageWidth = imageWidth.divide(BigDecimal.valueOf(ESignConstants.PAGE_RATIO), 4,
							RoundingMode.HALF_EVEN);

					// Calculating center location for Signature
					imageLocX += ((eSignAttribute.getWidth() - imageWidth.longValue()) / 2) - 35;
				}
				if(attrNumColums ==1){
					imageLocY -= 35;
				}
				else{
					imageLocY -= 30;
				}

			} else {
				// For Sign.co - Signature Positioning and Dimension Calculation.
				imageWidth = BigDecimal.valueOf(eSignAttribute.getWidth() / ESignConstants.PAGE_RATIO);
				imageHeight = BigDecimal.valueOf(eSignAttribute.getHeight() / ESignConstants.PAGE_RATIO);
				imageLocY -= imageHeight.doubleValue();
			}
			// Setting Rotation for Signature Attribute
			if (pageRotation == 0) {
				contents.drawImage(pdImage, imageLocX.floatValue(), imageLocY.floatValue(), imageWidth.floatValue(),
						imageHeight.floatValue());
			} else {
				final AffineTransform at = new AffineTransform(imageHeight.floatValue(), 0, 0, imageWidth.floatValue(),
						imageLocX.floatValue(), imageLocY.floatValue());
				at.rotate(Math.toRadians(pageRotation));
				contents.drawXObject(pdImage, at);
			}

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:drawSignature:exception:", exception);
		}
	}

	/**
	 * This method used to draw the initial in PDF.
	 * 
	 * @param firmId
	 * @param document
	 * @param eSignAttribute
	 * @param imageLocX
	 * @param imageLocY
	 * @param contents
	 * @param pageRotation
	 */
	@SuppressWarnings("deprecation")
	public void drawInitial(final Long firmId, final PDDocument document, final IdxEsignAttribute eSignAttribute,
			Double imageLocX, Double imageLocY, final PDPageContentStream contents, final int pageRotation, final Long associatedObjectId) {
		try {
			final PDImageXObject pdImage = PDImageXObject.createFromByteArray(document,
					Base64.decodeBase64(eSignAttribute.getValue().split(",")[1]), null);

			final BigDecimal imageHeight = BigDecimal.valueOf(eSignAttribute.getHeight() / ESignConstants.PAGE_RATIO);
			final BigDecimal imageWidth = BigDecimal.valueOf(eSignAttribute.getWidth() / ESignConstants.PAGE_RATIO);
			imageLocY -= imageHeight.doubleValue();
			final Long attrNumColums = eSignAttribute.getCl();

			if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(associatedObjectId) && attrNumColums != null && attrNumColums != 1) {
				imageLocY -= imageHeight.doubleValue() - 2;
			}
			// Setting Rotation for Initial attribute
			if (pageRotation == 0) {
				contents.drawImage(pdImage, imageLocX.floatValue(), imageLocY.floatValue(), imageWidth.floatValue(),
						imageHeight.floatValue());
			} else {
				final AffineTransform at = new AffineTransform(imageHeight.floatValue(), 0, 0, imageWidth.floatValue(),
						imageLocX.floatValue(), imageLocY.floatValue());
				at.rotate(Math.toRadians(pageRotation));
				contents.drawXObject(pdImage, at);
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:drawInitial:exception:", exception);
		}
	}

	/**
	 * This method used to draw the check box in PDF
	 *
	 * @param firmId
	 * @param document
	 * @param eSignAttribute
	 * @param imageLocX
	 * @param imageLocY
	 * @param contents
	 * @param pageRotation
	 */
	@SuppressWarnings("deprecation")
	public void drawCheckBox(final Long firmId, final PDDocument document, final IdxEsignAttribute eSignAttribute,
			Double imageLocX, Double imageLocY, final PDPageContentStream contents, final int pageRotation) {
		try {
			final PDImageXObject pdImage = PDImageXObject.createFromByteArray(document,
					Base64.decodeBase64(eSignAttribute.getValue().split(",")[1]), null);

			final BigDecimal imageHeight = BigDecimal.valueOf(eSignAttribute.getHeight() / ESignConstants.PAGE_RATIO);
			final BigDecimal imageWidth = BigDecimal.valueOf(eSignAttribute.getWidth() / ESignConstants.PAGE_RATIO);
			imageLocY -= imageHeight.doubleValue();

			// Setting Rotation for check box
			if (pageRotation == 0) {
				contents.drawImage(pdImage, imageLocX.floatValue(), imageLocY.floatValue(), imageWidth.floatValue(),
						imageHeight.floatValue());
			} else {
				final AffineTransform at = new AffineTransform(imageHeight.floatValue(), 0, 0, imageWidth.floatValue(),
						imageLocX.floatValue(), imageLocY.floatValue());
				at.rotate(Math.toRadians(pageRotation));
				contents.drawXObject(pdImage, at);
			}

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:drawCheckBox:exception:", exception);
		}
	}

	/**
	 * This method used to get the Pdf font style
	 *
	 * @param eSignAttribute
	 * @return
	 */
	public PDType1Font getPdfFontStyle(final IdxEsignAttribute eSignAttribute) {
		PDType1Font fontStyle = null;

		// Times Roman
		if (ESignConstants.TIMES_ROMAN.equals(eSignAttribute.getFont())) {
			fontStyle = PDType1Font.TIMES_ROMAN;
			if (eSignAttribute.isBold() && eSignAttribute.isItalic()) {
				fontStyle = PDType1Font.TIMES_BOLD_ITALIC;
			} else if (eSignAttribute.isBold()) {
				fontStyle = PDType1Font.TIMES_BOLD;
			} else if (eSignAttribute.isItalic()) {
				fontStyle = PDType1Font.TIMES_ITALIC;
			}
		}

		// Helvitica
		if (ESignConstants.HELVETICA.equals(eSignAttribute.getFont())) {
			fontStyle = PDType1Font.HELVETICA;
			if (eSignAttribute.isBold() && eSignAttribute.isItalic()) {
				fontStyle = PDType1Font.HELVETICA_BOLD_OBLIQUE;
			} else if (eSignAttribute.isBold()) {
				fontStyle = PDType1Font.HELVETICA_BOLD;
			} else if (eSignAttribute.isItalic()) {
				fontStyle = PDType1Font.HELVETICA_OBLIQUE;
			}
		}

		// Courier
		if (ESignConstants.COURIER.equals(eSignAttribute.getFont())) {
			fontStyle = PDType1Font.COURIER;
			if (eSignAttribute.isBold() && eSignAttribute.isItalic()) {
				fontStyle = PDType1Font.COURIER_BOLD_OBLIQUE;
			} else if (eSignAttribute.isBold()) {
				fontStyle = PDType1Font.COURIER_BOLD;
			} else if (eSignAttribute.isItalic()) {
				fontStyle = PDType1Font.COURIER_OBLIQUE;
			}
		}

		return fontStyle;
	}
	
	/**
	 * This method used to get the Pdf font style for label
	 * @param firmId
	 * @param document
	 * @param eSignAttribute
	 * @return
	 */
	public PDType0Font getPdfLabelFontStyle(final Long firmId, final PDDocument document,
			final IdxEsignAttribute eSignAttribute) {
		PDType0Font fontStyle = null;

		try {

			final String fontFileName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId
					+ "_" + System.currentTimeMillis() + "_";

			// CALIBRI
			if (ESignConstants.CALIBRI.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.CALIBRI + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_CALIBRI_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_CALIBRI_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_CALIBRI_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_CALIBRI), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Times Roman
			if (ESignConstants.TIMES_NEW_ROMAN.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.TIMES_NEW_ROMAN + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_NEW_ROMAN_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_NEW_ROMAN_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_NEW_ROMAN_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_NEW_ROMAN), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Helvitica
			if (ESignConstants.HELVETICA.equalsIgnoreCase(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.HELVETICA + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals( eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_HELVETICA_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_HELVETICA_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_HELVETICA_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_HELVETICA), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Courier New
			if (ESignConstants.COURIER_NEW.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.COURIER_NEW + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COURIER_NEW_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COURIER_NEW_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COURIER_NEW_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COURIER_NEW), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Nunito
			if (ESignConstants.NUNITO.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.NUNITO + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_NUNITO_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_NUNITO_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_NUNITO_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_NUNITO), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Geneva
			if (ESignConstants.GENEVA.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.GENEVA + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GENEVA_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GENEVA_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GENEVA_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GENEVA), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Trebuchet MS
			if (ESignConstants.TREBUCHET_MS.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.TREBUCHET_MS + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TREBUCHET_MS_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TREBUCHET_MS_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TREBUCHET_MS_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TREBUCHET_MS), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Impact
			if (ESignConstants.IMPACT.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.IMPACT + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_IMPACT_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_IMPACT_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_IMPACT_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_IMPACT), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Comic sans MS
			if (ESignConstants.COMIC_SANS_MS.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.COMIC_SANS_MS + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COMIC_SANS_MS_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COMIC_SANS_MS_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COMIC_SANS_MS_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_COMIC_SANS_MS), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Arial Black
			if (ESignConstants.ARIAL_BLACK.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.ARIAL_BLACK + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_BLACK_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_BLACK_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_BLACK_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_BLACK), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Tahoma
			if (ESignConstants.TAHOMA.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.TAHOMA + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TAHOMA_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TAHOMA_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TAHOMA_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TAHOMA), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Verdana
			if (ESignConstants.VERDANA.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.VERDANA + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_VERDANA_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_VERDANA_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_VERDANA_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_VERDANA), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Arial Black
			if (ESignConstants.TIMES.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.TIMES + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_TIMES), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Serif
			if (ESignConstants.SERIF.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.SERIF + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_SERIF_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())){
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_SERIF_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_SERIF_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_SERIF), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Arial
			if (ESignConstants.ARIAL.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.ARIAL + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_ARIAL), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}

			// Georgia
			if (ESignConstants.GEORGIA.equals(eSignAttribute.getAl().getLf())) {
				final File file = new File(fontFileName + ESignConstants.GEORGIA + ESignConstants.FILE_EXT_TTF);
				if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb()) && Boolean.TRUE.equals(eSignAttribute.getAl().getIli())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GEORGIA_BOLD_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIlb())) {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GEORGIA_BOLD), file);
					fontStyle = PDType0Font.load(document, file);
				} else if (Boolean.TRUE.equals(eSignAttribute.getAl().getIli()))
						{
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GEORGIA_ITALIC), file);
					fontStyle = PDType0Font.load(document, file);
				} else {
					FileUtils.copyURLToFile(new URL(ESignConstants.FONT_FAMILY_GEORGIA), file);
					fontStyle = PDType0Font.load(document, file);
				}
				file.deleteOnExit();
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getPdfLabelFontStyle:exception:", exception);
		}

		return fontStyle;
	}

	/**
	 * This API used to draw text in PDF.
	 * 
	 * @param firmId
	 * @param eSignAttribute
	 * @param imageLocX
	 * @param imageLocY
	 * @param contents
	 * @param pageRotation
	 */
	@SuppressWarnings("deprecation")
	public void drawText(final Long firmId, final IdxEsignAttribute eSignAttribute, Float imageLocX, Float imageLocY,
			final PDPageContentStream contents, final int pageRotation, final Long objectId) {
		try {
			imageLocX += 5.5f;
			imageLocY -= 13f;
			final Long attrNumColums = eSignAttribute.getCl();
			final Float fontSize = BigDecimal.valueOf(Long.valueOf(eSignAttribute.getFontSize()) / 1.3).floatValue();

			final PDType1Font fontStyle = getPdfFontStyle(eSignAttribute);

			final String[] attrValue = eSignAttribute.getValue().replace('', '\n').split("\n");

			float lineX = imageLocX;
			float lineY = imageLocY;

			int size = 0;
			for (String at : attrValue) {
				if (size <= at.replaceAll("\\u00a0", " ").length()) {
					size = at.trim().length();
				}
			}

			float maxWidth = (float) (imageLocX + (size * fontSize) / 2.1);

			for (String attr : attrValue) {
				attr = attr.replaceAll("\\u00a0", " ");

				contents.beginText();
				contents.setFont(fontStyle, fontSize);

				contents.setNonStrokingColor(eSignAttribute.getFontColor()[0], eSignAttribute.getFontColor()[1],
						eSignAttribute.getFontColor()[2]);

				if (ESignConstants.LEFT_ALIGN.equals(eSignAttribute.getAlign()) ) {
					if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)) {
						Float updatedImageLocY = ESignConstants.textOffsetByFont.get(eSignAttribute.getFont())
								.get(eSignAttribute.getFontSize());
						if (updatedImageLocY == null) {
							imageLocY += 10f;
						} else {
							imageLocY += updatedImageLocY;
						}
					} else if (attrNumColums != null && attrNumColums == 1) {
						imageLocY += 4f;
					} else {
						imageLocY += 10f;
					}
					contents.newLineAtOffset(imageLocX, imageLocY);
				} else if (ESignConstants.RIGHT_ALIGN.equals(eSignAttribute.getAlign())) {
					float x = imageLocX + (maxWidth
							- BigDecimal.valueOf(imageLocX + (attr.length() * fontSize) / 2.1).floatValue());
					contents.newLineAtOffset(x, imageLocY);
				} else if (ESignConstants.CENTER_ALIGN.equals(eSignAttribute.getAlign())) {
					float x = imageLocX
							+ (maxWidth - BigDecimal.valueOf(imageLocX + (attr.length() * fontSize) / 2.1).floatValue())
									/ 2;
					contents.newLineAtOffset(x, imageLocY);
				}

				// Setting Rotation for Text
				if (pageRotation == 90) {
					final Matrix matrix = Matrix.getRotateInstance(Math.toRadians(pageRotation), imageLocX - 20,
							imageLocY);
					contents.setTextMatrix(matrix);
				} else if (pageRotation == 270) {
					final Matrix matrix = Matrix.getRotateInstance(Math.toRadians(pageRotation), imageLocX + 10,
							imageLocY - 15);
					contents.setTextMatrix(matrix);
				}

				contents.showText(attr);
				contents.endText();
				if (ESignConstants.LEFT_ALIGN.equals(eSignAttribute.getAlign()) && eSignAttribute.isUndLn()) {
					contents.drawLine(lineX, lineY - 1,
							BigDecimal.valueOf(lineX + (attr.length() * fontSize) / 2.1).floatValue(), lineY - 1);
					lineY -= BigDecimal.valueOf(fontSize * 1.4).floatValue();
				}

				if (ESignConstants.RIGHT_ALIGN.equals(eSignAttribute.getAlign()) && eSignAttribute.isUndLn()) {
					lineX = imageLocX + (maxWidth
							- BigDecimal.valueOf(imageLocX + (attr.length() * fontSize) / 2.1).floatValue());
					contents.drawLine(lineX, lineY - 1,
							BigDecimal.valueOf(lineX + (attr.length() * fontSize) / 2.1).floatValue(), lineY - 1);
					lineY -= BigDecimal.valueOf(fontSize * 1.4).floatValue();
				}

				if (ESignConstants.CENTER_ALIGN.equals(eSignAttribute.getAlign()) && eSignAttribute.isUndLn()) {
					lineX = imageLocX
							+ (maxWidth - BigDecimal.valueOf(imageLocX + (attr.length() * fontSize) / 2.1).floatValue())
									/ 2;
					contents.drawLine(lineX, lineY - 1,
							BigDecimal.valueOf(lineX + (attr.length() * fontSize) / 2.1).floatValue(), lineY - 1);
					lineY -= BigDecimal.valueOf(fontSize * 1.4).floatValue();
				}
				// Calculating position for next line of the text
				if (pageRotation == 0) {
					imageLocY -= BigDecimal.valueOf(fontSize * 1.4).floatValue();
				} else if (pageRotation == 90) {
					imageLocX += BigDecimal.valueOf(fontSize * 1.4).floatValue();
				} else if (pageRotation == 270) {
					imageLocX -= BigDecimal.valueOf(fontSize * 1.4).floatValue();
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:drawText:exception:", exception);
		}
	}

	/**
	 * This method used to draw the radio in pdf
	 *
	 * @param firmId
	 * @param document
	 * @param eSignAttribute
	 * @param associatedObjectId
	 * @param imageLocX
	 * @param imageLocY
	 * @param contents
	 * @param pageRotation
	 */
	public void drawRadio(final Long firmId, final PDDocument document, final IdxEsignAttribute eSignAttribute,
			final Long associatedObjectId, final float imageLocX, float imageLocY, final PDPageContentStream contents,
			final int pageRotation) {
		try {
			final PDImageXObject radioCheckedImg = PDImageXObject.createFromByteArray(document,
					Base64.decodeBase64(ESignConstants.RADIO_CHECKED.split(",")[1]), null);

			final PDImageXObject radioUnCheckedImg = PDImageXObject.createFromByteArray(document,
					Base64.decodeBase64(ESignConstants.RADIO_UN_CHECKED.split(",")[1]), null);

			final int pdImageWidth = radioCheckedImg.getWidth();
			final int pdImageHeight = radioCheckedImg.getHeight();
			final Long attrNumColums = eSignAttribute.getCl();

			final BigDecimal imageWidth = BigDecimal.valueOf(pdImageWidth / ESignConstants.PAGE_RATIO);
			final BigDecimal imageHeight = BigDecimal.valueOf(pdImageHeight / ESignConstants.PAGE_RATIO);

			PDImageXObject pdImage = null;
			for (int i = 0; i < eSignAttribute.getLb().size(); i++) {
				final IdxLabel attrLabel = eSignAttribute.getLb().get(i);
				float labelLocX = BigDecimal.valueOf(attrLabel.getLocX() / ESignConstants.PAGE_RATIO).floatValue();
				float labelLocY = BigDecimal.valueOf(attrLabel.getLocY() / ESignConstants.PAGE_RATIO).floatValue();

				if (attrLabel.getLabelName().equals(eSignAttribute.getValue())) {
					pdImage = radioCheckedImg;
				} else {
					pdImage = radioUnCheckedImg;
				}

				// Calculating updated image location
				float updatedImageLocX = 0;
				float updatedImageLocY = 0;
				if (pageRotation == 0) {
					updatedImageLocX = imageLocX + labelLocX;
					updatedImageLocY = imageLocY - imageHeight.floatValue() - labelLocY;
				} else if (pageRotation == 90) {
					updatedImageLocX = (imageLocX + imageHeight.floatValue() + labelLocY) - 30;
					updatedImageLocY = imageLocY - imageWidth.floatValue() + labelLocX;
				} else if (pageRotation == 270) {
					updatedImageLocX = (imageLocX - imageWidth.floatValue() - labelLocY) + 20;
					updatedImageLocY = (imageLocY - imageHeight.floatValue() + labelLocX) - 15;
				}

				if(ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(associatedObjectId) && attrNumColums != null && attrNumColums != 1 && eSignAttribute.getAl() != null){
					updatedImageLocY = imageLocY -=15 ;
				}
				if(!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(associatedObjectId) && eSignAttribute.getAl() != null) {
					imageLocY -= i==0 ? 11 :15;
					updatedImageLocY = imageLocY;
				}

				// drawing checkBox
				contents.drawImage(pdImage, updatedImageLocX, updatedImageLocY, imageWidth.floatValue(),
						imageHeight.floatValue());

				// writing label for checkBox
				if (!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(associatedObjectId)
						&& eSignAttribute.getAl() != null) {
					contents.beginText();
					contents.setFont(PDType1Font.HELVETICA, 7F);
					contents.newLineAtOffset(updatedImageLocX + 15, updatedImageLocY + 4);
					final String attributeValue = attrLabel.getLabelName().replaceAll("", "\n");
					if (attributeValue != null && attributeValue.indexOf('\n') != -1) {
						contents.setLeading(12F);
						for (int charIndex = 0; charIndex < attributeValue.length(); charIndex++) {
							if (attributeValue.charAt(charIndex) == '\n') {
								contents.newLine();
								imageLocY -= 15;
							} else {
								contents.showText(Character.toString(attributeValue.charAt(charIndex)));
							}
						}
					} else {
						contents.showText(attributeValue);
					}
					contents.endText();
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:drawRadio:exception:", exception);
		}
	}

	/**
	 * This method used to draw text in PDF.
	 * 
	 * @param firmId
	 * @param eSignAttribute
	 * @param objectId
	 * @param locX
	 * @param locY
	 * @param contents
	 * @param pageRotation
	 */
	public void writeText(final Long firmId, final IdxEsignAttribute eSignAttribute, final Long objectId, float locX,
			float locY, final PDPageContentStream contents, final int pageRotation) {
		try {
			float offsetX = 5;
			float offsetY = 10;
			final Long attrNumColums = eSignAttribute.getCl();
			if (!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)
					&& ESignConstants.TYPE_DATE.equalsIgnoreCase(eSignAttribute.getSignatureType()) && attrNumColums != null && attrNumColums != 1) {
				offsetY = 4;
			}
			if (!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)
					&& ESignConstants.TYPE_NAME.equalsIgnoreCase(eSignAttribute.getSignatureType()) && attrNumColums != null && attrNumColums != 1) {
				offsetY = 2;
			}
			if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)
					&& ESignConstants.TYPE_DATE.equalsIgnoreCase(eSignAttribute.getSignatureType())) {
				offsetX = 5;
				offsetY = 13;
			}
			contents.beginText();
			contents.setFont(PDType1Font.HELVETICA, 8F);
			contents.newLineAtOffset(locX + offsetX, locY - offsetY);

			// Setting Rotation for Date and Name Attributes
			if (pageRotation == 90) {
				final Matrix matrix = Matrix.getRotateInstance(Math.toRadians(pageRotation), locX - 10, locY - 10);
				contents.setTextMatrix(matrix);
			} else if (pageRotation == 270) {
				final Matrix matrix = Matrix.getRotateInstance(Math.toRadians(pageRotation), locX + 10, locY - 25);
				contents.setTextMatrix(matrix);
			}

			final String attributeValue = eSignAttribute.getValue();
			if (attributeValue != null && attributeValue.indexOf('\n') != -1) {
				contents.setLeading(8F);
				for (int charIndex = 0; charIndex < attributeValue.length(); charIndex++) {
					if (attributeValue.charAt(charIndex) == '\n') {
						contents.newLine();
					} else {
						contents.showText(Character.toString(attributeValue.charAt(charIndex)));
					}
				}
			} else {
				contents.showText(attributeValue);
			}
			contents.endText();
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:writeText:exception:", exception);
		}
	}

	/**
	 * This method used to prepare the signature for associate object 
	 * - Estimate, Contracts and WorkOrders
	 * 
	 * @param firmId
	 * @param eSignatures
	 * @param associatedObjectId
	 * @param eSignAttribute
	 * @param decodedValue
	 */
	public void prepareAssociatedSignatures(final Long firmId, final List<IdxEsignature> eSignatures,
			final Long associatedObjectId, final IdxEsignAttribute eSignAttribute, final String decodedValue) {
		if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(associatedObjectId)) {
			logger.info(firmId, "ESignatureService:prepareAssociatedSignatures:eSign Document");
		} else {
			final IdxEsignature eSignature = new IdxEsignature();
			eSignature.setUniqueId(eSignAttribute.getUniqueId());
			eSignature.setyAxis(eSignAttribute.getLocationY());
			eSignature.setxAxis(eSignAttribute.getLocationX());
			eSignature.setEsignImage(decodedValue);
			eSignature.setPageNumber(eSignAttribute.getPageNumber());
			eSignature.setSignerAttrId(eSignAttribute.geteSignSigner().getSignerAttribute());
			eSignature.setHeight(eSignAttribute.getHeight());
			eSignature.setWidth(eSignAttribute.getWidth());
			eSignature.setSignObjectId(ObjectConstants.OBJECT_ESIGN_DOCUMENT);
			eSignatures.add(eSignature);
		}
	}

	/**
	 * This method used to update the esignDocument status based on the signer status / id.
	 * 
	 * @param idxESignDocument
	 * @param signerId
	 */
	public boolean updateESignDocStatus(final IdxESignDocument idxESignDocument, final Long signerId) {
		// For In-Person Sign - no need to check all attributes
		if (signerId == null) {
			idxESignDocument.setStatusCode(ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.toUpperCase());
			idxESignDocument.setStatusName(ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED);
			return true;
		}

		// For Send for Sign - checking for attributes tat is assigned other than current signer
		boolean isCompleted = true;
		for (IdxESignSigner idxSigner : idxESignDocument.getSigners()) {
			if(!ESignConstants.SIGNER_STATUS_SIGNED.equalsIgnoreCase(idxSigner.getSignerStatus())
					&& ESignConstants.SIGNER_ACTION_NEED_SIGN.equalsIgnoreCase(idxSigner.getSignerActions())) {
				isCompleted = false;
				break;
			}
		}
		if (isCompleted) {
			idxESignDocument.setStatusCode(ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.toUpperCase());
			idxESignDocument.setStatusName(ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED);
		} else {
			idxESignDocument.setStatusCode(ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING.toUpperCase());
			idxESignDocument.setStatusName(ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING);
		}
		return true;
	}

	/**
	 * This method used to prepare idxESignAttributes based on the eSignAttributes
	 * list.
	 *
	 * @param idxESignDocument
	 * @param eSignAttributes
	 * @param signerId
	 * @param clientIpAddress
	 * @param userAgent
	 * @param addSignInAssoObj
	 * @return
	 */
	public IdxESignDocument saveESignDocumentAttributes(final IdxESignDocument idxESignDocument,
			final String eSignAttributes, final Long signerId, final String clientIpAddress, final String userAgent,
			final boolean addSignInAssoObj) {
		final Long firmId = idxESignDocument.getFirmId();
		try {
			final List<IdxEsignAttribute> eSignAttributesData = new Gson().fromJson(eSignAttributes,
					new TypeToken<List<IdxEsignAttribute>>() {
					}.getType());

			final String creationDate = DateUtil.getEsDateFormat().format(new Date());
			final List<IdxEsignature> eSignatures = new ArrayList<>();
			final List<IdxEsignAttribute> idxESignAttributes = getAllESignAttributes(idxESignDocument);
			for (IdxEsignAttribute idxESignAttribute : eSignAttributesData) {
				boolean checkNextAttr = false;
				for (IdxEsignAttribute eSignAttribute : idxESignAttributes) {
					// update ESign label with \n
					if (idxESignAttribute.getAl() != null && (eSignAttribute.getUniqueId().equals(idxESignAttribute.getUniqueId()))) {
						eSignAttribute.getAl().setLabelName(idxESignAttribute.getAl().getLabelName());
					}

					if (ESignConstants.TYPE_SIGNATURE.equalsIgnoreCase(idxESignAttribute.getSignatureType())
							&& ESignConstants.TYPE_SIGNATURE.equalsIgnoreCase(eSignAttribute.getSignatureType())
							&& (eSignAttribute.getUniqueId() == null || eSignAttribute.getUniqueId().equals(idxESignAttribute.getUniqueId()))
							&& (idxESignAttribute.geteSignSigner().geteSignSignerId().equals(signerId)
									|| ESignConstants.IN_PERSON_SIGN.equals(idxESignDocument.getSignType()))) {
						String decodedValue = null;
						if (idxESignAttribute.getValue() != null) {
							decodedValue = URLDecoder.decode(idxESignAttribute.getValue(),
									AppConstants.URI_ENCODER_FORMAT);
						}

						eSignAttribute.setDateSigned(creationDate);
						eSignAttribute.setValue(decodedValue);
						eSignAttribute.setWidth(idxESignAttribute.getWidth());
						eSignAttribute.setHeight(idxESignAttribute.getHeight());
						eSignAttribute.setLocationX(idxESignAttribute.getLocationX());
						eSignAttribute.setLocationY(idxESignAttribute.getLocationY());
						eSignAttribute.setIsCompleted(idxESignAttribute.isCompleted());
						eSignAttribute.setCreationDate(creationDate);
						eSignAttribute.setNodeName(System.getProperty(AppConstants.NODE_NAME));
						eSignAttribute.setIpAddress(clientIpAddress);
						eSignAttribute.setUserAgent(userAgent);

						eSignAttribute.geteSignSigner().setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED);

						prepareAssociatedSignatures(firmId, eSignatures,
								idxESignDocument.getAssociatedObject().getObjectId(), eSignAttribute, decodedValue);

						checkNextAttr = true;
					} else if ((ESignConstants.TYPE_DATE.equalsIgnoreCase(idxESignAttribute.getSignatureType())
							|| ESignConstants.TYPE_TEXT.equalsIgnoreCase(idxESignAttribute.getSignatureType())
							|| ESignConstants.TYPE_NAME.equalsIgnoreCase(idxESignAttribute.getSignatureType())
							|| ESignConstants.TYPE_INITIALS.equalsIgnoreCase(idxESignAttribute.getSignatureType())
							|| ESignConstants.TYPE_CHECKBOX.equalsIgnoreCase(idxESignAttribute.getSignatureType())
							|| ESignConstants.TYPE_RADIO.equalsIgnoreCase(idxESignAttribute.getSignatureType()))
							&& (idxESignAttribute.geteSignSigner().geteSignSignerId().equals(signerId)
									|| ESignConstants.IN_PERSON_SIGN.equals(idxESignDocument.getSignType()))) {
						idxESignAttribute.setNodeName(System.getProperty(AppConstants.NODE_NAME));
						idxESignAttribute.setIpAddress(clientIpAddress);
						idxESignAttribute.setUserAgent(userAgent);

						eSignAttribute.geteSignSigner().setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED);

						String decodedValue = null;
						if (idxESignAttribute.getValue() != null) {
							decodedValue = URLDecoder.decode(idxESignAttribute.getValue(),
									AppConstants.URI_ENCODER_FORMAT);
						}

						if (eSignAttribute.getUniqueId() != null
								&& eSignAttribute.getUniqueId().equals(idxESignAttribute.getUniqueId())) {
							// For Sign.co - we're checking unique Id
							eSignAttribute.setValue(decodedValue);
							eSignAttribute.setWidth(idxESignAttribute.getWidth());
							eSignAttribute.setHeight(idxESignAttribute.getHeight());
							eSignAttribute.setLocationX(idxESignAttribute.getLocationX());
							eSignAttribute.setLocationY(idxESignAttribute.getLocationY());
							eSignAttribute.setIsCompleted(true);
							eSignAttribute.setHtmlContent(idxESignAttribute.getHtmlContent());
							eSignAttribute.setReq(idxESignAttribute.isReq());
							eSignAttribute.setIsBold(idxESignAttribute.isBold());
							eSignAttribute.setIsItalic(idxESignAttribute.isItalic());
							eSignAttribute.setIsUndLn(idxESignAttribute.isUndLn());
							eSignAttribute.setFont(idxESignAttribute.getFont());
							eSignAttribute.setFontColor(idxESignAttribute.getFontColor());
							eSignAttribute.setFontSize(idxESignAttribute.getFontSize());
							eSignAttribute.setAlign(idxESignAttribute.getAlign());
							eSignAttribute.setAttrLabels(idxESignAttribute.getAttrLabels());
							eSignAttribute.setLb(idxESignAttribute.getLb());
							eSignAttribute.setTitle(idxESignAttribute.getTitle());
							eSignAttribute.setVcEnab(idxESignAttribute.isVcEnab());
							checkNextAttr = true;
							prepareAssociatedSignatures(firmId, eSignatures,
									idxESignDocument.getAssociatedObject().getObjectId(), eSignAttribute, decodedValue);
						} else if (idxESignAttribute.getUniqueId() == null) {
							// For ESign - we're not maintaining the unique Id.
							idxESignAttribute.setValue(decodedValue);
							idxESignAttribute.setCreationDate(creationDate);
							idxESignDocument.getDocumentPages().get(idxESignAttribute.getPageNumber().intValue() - 1)
									.geteSignAttributes().add(idxESignAttribute);
							checkNextAttr = true;
							prepareAssociatedSignatures(firmId, eSignatures,
									idxESignDocument.getAssociatedObject().getObjectId(), idxESignAttribute, decodedValue);
						}
					}

					if(checkNextAttr) {
						break;
					}
				}
			}

			if (addSignInAssoObj) {
				updateAssociatedESignatures(idxESignDocument.getFirmId(),
						idxESignDocument.getAssociatedObject().getObjectId(),
						idxESignDocument.getAssociatedObject().getObjectRefId(), eSignatures);
			}

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:saveESignDocumentAttributes:exception:", exception);
		}
		return idxESignDocument;
	}

	/**
	 * This method used to upload document in document tab.
	 * 
	 * @param idxESignDocument
	 * @return
	 */
	public IdxDocument uploadDocumentInDocumentTab(final IdxESignDocument idxESignDocument, final String pdfBase) {
		final Long firmId = idxESignDocument.getFirmId();
		final IdxFolder userRootFolder = DocumentDAO.getInstance().getUserRootFolderByfirmIdUserId(firmId,
				idxESignDocument.getCreatedBy());

		final Long folderId = userRootFolder.getFolderId();
		final Long documentNumber = DocumentDAO.getInstance().getNextDocumentNumber(firmId);
		logger.info(firmId, "ESignatureService:uploadDocument:documentNumber:" + documentNumber);

		final String docKey = firmId + ":" + idxESignDocument.getCreatedBy() + ":" + documentNumber;
		final byte[] objectPdf = Base64.decodeBase64(pdfBase.split(",")[1]);
		final Long size = Long.parseLong(objectPdf.length + "");

		boolean useLocal = false;
		if (AppConstants.DEV_ENVIRONMENT.equals(System.getProperty(AppConstants.SOURCE_ENVIRONMENT))) {
			useLocal = true;
		}

		final String objRefName = idxESignDocument.getAssociatedObject().getObjectRefName();
		final String documentName = objRefName.indexOf(AppConstants.PDF_FILE_EXTENSION) > -1 ? objRefName
				: objRefName + AppConstants.PDF_FILE_EXTENSION;

		final IdxDocument signedDocument = DocumentDAO.getInstance().saveDocument(firmId, docKey,
				AppConstants.BUCKET_IDENTIFIER_FOR_DMS, documentName, null, objectPdf, size,
				ESignConstants.FILE_EXT_PDF, idxESignDocument.getAssociatedObject().getObjectId(),
				idxESignDocument.getAssociatedObject().getObjectRefId(), folderId, idxESignDocument.getCreatedBy(),
				useLocal, null, null);
		if (signedDocument != null) {
			logger.info(firmId, "ESignatureService:uploadDocument:documentId:" + signedDocument.getDocumentId());
		}
		return signedDocument;
	}

	/**
	 * This method used to update signers list by inline script.
	 *
	 * @param firmId
	 * @param documentId
	 * @param signers
	 */
	public void updateSignerByScript(final Long firmId, final Long documentId, final List<IdxESignSigner> signers) {
		try {
			final Map<String, Object> scriptParams = new HashMap<>();
			scriptParams.put(AppConstants.FIRM_ID, firmId);
			scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);

			final StringBuilder updateScript = new StringBuilder();
			updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
					+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");
			try {
				scriptParams.put("signers", new ObjectMapper().readValue(AppUtil.formatUrl(signers), ArrayList.class));
			} catch (IOException exception) {
				logger.error(firmId, "ESignatureService:updateSignerByScript:exception:", exception);
			}

			updateScript.append("ctx._source.signers = params.signers;");

			updateScript.append("}");

			final UpdateRequestBuilder updateRequestBuilder = ElasticSearchDAO
					.getInstance().getClient(firmId).prepareUpdate(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(),
							ESConstants._DOCS, documentId.toString())
					.setRouting(AppBaseDAO.getInstance().getShardId(firmId));
			final UpdateResponse updateResponse = updateRequestBuilder.setScript(
					ESAPIUtil.createScriptObject(updateScript.toString(), ScriptType.INLINE, null, scriptParams))
					.execute().actionGet();
			logger.info(firmId, "ESignatureService:updateSignerByScript:updateResponse:" + updateResponse);
		} catch (VersionConflictEngineException exception) {
			updateSignerByScript(firmId, documentId, signers);
			logger.error(firmId, "ESignatureService:updateSignerByScript:exception:", exception);
		} catch (Exception excetion) {
			logger.error(firmId, "ESignatureService:updateSignerByScript:excetion:", excetion);
		}
	}

	/**
	 * This method used to add signers of the e-sign document
	 * 
	 * @param firmId
	 * @param documentId
	 * @param signerdata
	 * @return
	 */
	public IdxESignDocument addSigner(final Long firmId, final Long documentId, final String signerdata) {
		try {
			final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);

			final Map<String, Long> employeesData =  getAllActiveEmployee(firmId);

			final List<IdxESignSigner> signers = new ArrayList<>();

			final JSONParser parser = new JSONParser();
			final JSONArray eSignArray = (JSONArray) parser.parse(signerdata);

			for (int eSignerIndex = 0; eSignerIndex < eSignArray.size(); eSignerIndex++) {
				final JSONObject eSignObj = (JSONObject) eSignArray.get(eSignerIndex);
				final IdxESignSigner eSignSigner = AppUtil.convertFromJson(IdxESignSigner.class, eSignObj.toJSONString());

				IdxESignSigner idxESignSigner = null;

				if (eSignSigner.geteSignSignerId() != null) {
					idxESignSigner = idxESignDocument.getESignSignerBySignerId(eSignSigner.geteSignSignerId());
				}

				if (idxESignSigner == null) {
					eSignSigner.seteSignSignerId(
							AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_SIGNER_ID));
				}

				if (employeesData.get(eSignSigner.getPrimaryEmailId()) != null) {
					eSignSigner.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
					eSignSigner.setObjectRefId(employeesData.get(eSignSigner.getPrimaryEmailId()));
				}

				signers.add(eSignSigner);
			}

			updateSignerByScript(firmId, documentId, signers);
			idxESignDocument.setSigners(signers);
			return idxESignDocument;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:addSigners:exception:", exception);
		}
		return null;
	}

	/**
	 * This method used to forward the document once its signed 
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param documentUrl
	 * @param recipient
	 * @param subject
	 * @param message
	 * @param attachments
	 *
	 * @author malinik 
	 *
	 * @return 
	 */
	public IdxESignDocument notifyToRecipients(final Long firmId, final IdxESignDocument idxESignDocument,
			final String documentUrl, final String recipient, final String subject, final String message,
			final String[] attachments) {
		try {
			final List<IdxESignSigner> recipients = new ArrayList<>();

			final JSONParser parser = new JSONParser();
			final JSONArray recipientArray = (JSONArray) parser.parse(recipient);
			for (int eRespIndex = 0; eRespIndex < recipientArray.size(); eRespIndex++) {
				final JSONObject eSignObj = (JSONObject) recipientArray.get(eRespIndex);
				final IdxESignSigner eSignrecipient = AppUtil.convertFromJson(IdxESignSigner.class,
						eSignObj.toJSONString());
				IdxESignSigner idxESignSigner = null;
				if (eSignrecipient.geteSignSignerId() != null) {
					idxESignSigner = idxESignDocument.getESignSignerBySignerId(eSignrecipient.geteSignSignerId());
				}

				if (idxESignSigner == null) {
					eSignrecipient.seteSignSignerId(
							AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_SIGNER_ID));
				}

				recipients.add(eSignrecipient);

			}
			idxESignDocument.getSigners().addAll(recipients);
			updateSignerByScript(firmId, idxESignDocument.geteSignDocumentId(), idxESignDocument.getSigners());

			notifyToCC(firmId, idxESignDocument, documentUrl, attachments, subject, message);
			return idxESignDocument;

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:notifyToRecipients:exception:", exception);
		}

		return null;
	}

	/**
	 * This method used to get the active employee list.
	 *
	 * @param firmId
	 * @return
	 */
	public Map<String, Long> getAllActiveEmployee(final Long firmId){
		final Map<String, Long> employeesData = new HashMap<>();

		final List<IdxEmployee> idxEmployees = EmployeeDAO.getInstance().getAllActiveEmployees(firmId);
		for(IdxEmployee idxEmployee : idxEmployees) {
			employeesData.put(idxEmployee.getEmailId(), idxEmployee.getEmployeeId());
		}
		return employeesData;
	}

	/**
	 * This method used to create ESignature History by status.
	 * @param firmId
	 * @param idxESignDocument
	 * @param idxESignSigner
	 * @param status
	 * @param eSignDescription
	 * @param clientIpAddress
	 * @param userAgent
	 * @param idxReassign
	 * @return
	 */
	public IdxEsignatureHistory createESignatureHistory(Long firmId, IdxESignDocument idxESignDocument,
			IdxESignSigner idxESignSigner, String status, String eSignDescription, String clientIpAddress,
			String userAgent, IdxReassign idxReassign) {
		final Calendar calendar = Calendar.getInstance();
		final IdxEsignatureHistory idxEsignatureHistory = new IdxEsignatureHistory();
		idxEsignatureHistory.setFirmId(firmId);
		idxEsignatureHistory.setStatus(status.toUpperCase());
		idxEsignatureHistory.setStatusName(status);
		if (idxESignSigner != null) {
			idxEsignatureHistory.setEmailId(idxESignSigner.getPrimaryEmailId());
			idxEsignatureHistory.setSignedUserName(idxESignSigner.getObjectRefName());
			idxEsignatureHistory.setSignedUserId(idxESignSigner.geteSignSignerId());
		} else {
			idxEsignatureHistory.setEmailId(idxESignDocument.getSenderDetails().getEmailId());
		}
		idxEsignatureHistory.setDocumentId(idxESignDocument.geteSignDocumentId().toString());
		idxEsignatureHistory.setObjectId(idxESignDocument.getAssociatedObject().getObjectId());
		idxEsignatureHistory.setObjectRefId(idxESignDocument.getAssociatedObject().getObjectRefId());
		idxEsignatureHistory.setHistoryDate(DateUtil.formatDate(calendar.getTime(), DateUtil.getEsDateFormat()));
		idxEsignatureHistory.setIpAddress(clientIpAddress);
		saveUserAgent(idxEsignatureHistory, userAgent);
		idxEsignatureHistory.setSenderEmpId(String.valueOf(idxESignDocument.getSenderDetails().getObjectRefId()));
		idxEsignatureHistory.setSenderEmailId(idxESignDocument.getSenderDetails().getEmailId());
		idxEsignatureHistory.setUserId(idxESignDocument.getSenderDetails().getSourceRefId());
		idxEsignatureHistory.setDocumentName(idxESignDocument.getDocumentName());
		idxEsignatureHistory.setSignType(idxESignDocument.getSignType());

		idxEsignatureHistory.setUserName(idxESignDocument.getSenderDetails().getObjectRefName());

		if (idxReassign != null) {
			idxEsignatureHistory.setRsId(idxReassign.getrSId().toString());
			idxEsignatureHistory.setRsn(idxReassign.getName());
			idxEsignatureHistory.setRsEId(idxReassign.getEmailId());
		}

		eSignDescription = eSignDescription.replace("USER_NAME", idxEsignatureHistory.getUserName());
		if (idxESignSigner != null) {
			eSignDescription = eSignDescription.replace("SENDER_NAME", idxESignDocument.getCreatedByName());
			eSignDescription = eSignDescription.replace("SIGNER_NAME", idxESignSigner.getObjectRefName());
			eSignDescription = eSignDescription.replace("DOCUMENT_NAME", idxESignDocument.getDocumentName());
			eSignDescription = eSignDescription.replace("EMAIL_ID", idxESignSigner.getPrimaryEmailId());
		}
		if (idxReassign != null) {
			eSignDescription = eSignDescription.replace("SIGNER_NAME_2", idxReassign.getName());
		}
		idxEsignatureHistory.setDescription(eSignDescription);
		final IndexResponse response = ElasticSearchDAO.getInstance().indexDocument(firmId,
				ObjectConstants.OBJECT_ESIGNATURE_HISTORY, AppUtil.convertToJson(idxEsignatureHistory), true);

		// For Completed status history
		if (AppConstants.ESIGN_SIGNED.equals(status)) {
			calendar.add(Calendar.SECOND, 1);
			idxEsignatureHistory.setHistoryDate(DateUtil.formatDate(calendar.getTime(), DateUtil.getEsDateFormat()));
			idxEsignatureHistory.setStatus(AppConstants.ESIGN_COMPLETED.toUpperCase());
			idxEsignatureHistory.setStatusName(AppConstants.ESIGN_COMPLETED);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESIGNATURE_HISTORY,
					AppUtil.convertToJson(idxEsignatureHistory), true);
		}
		idxEsignatureHistory.setHistoryId(response.getId());
		return idxEsignatureHistory;
	}

	/**
	 * This method used to prepare the mail subject by mail subject values map.
	 * 
	 * @param subject
	 * @param mailSubjectValues
	 * @return
	 */
	public String prepareMailSubject(String subject, final Map<String, String> mailSubjectValues) {
		if (subject == null) {
			subject = "";
		}

		if (AppUtil.checkMapIsNullOrNot(mailSubjectValues)) {
			for (Map.Entry<String, String> entry : mailSubjectValues.entrySet()) {
				subject = AppUtil.replaceAll(subject, entry.getKey(), entry.getValue() != null ? entry.getValue() : "");
			}
		}
		return subject;
	}

	/**
	 * This method used to prepare the mail body by mail body values map.
	 * 
	 * @param mailBody
	 * @param mailBodyValues
	 * @return
	 */
	public String prepareMailBody(String mailBody, final Map<String, String> mailBodyValues) {
		if (mailBody == null) {
			mailBody = "";
		}

		if (AppUtil.checkMapIsNullOrNot(mailBodyValues)) {
			for (Map.Entry<String, String> entry : mailBodyValues.entrySet()) {
				mailBody = AppUtil.replaceAll(mailBody, entry.getKey(), entry.getValue() != null ? entry.getValue() : "");
			}
		}
		return mailBody;
	}

	/**
	 * This method used to send email by template
	 * 
	 * @param idxEmailTemplate
	 * @param mailSubjectValues
	 * @param mailBodyValues
	 * @param downloadedFiles
	 */
	public void sendEmailByTemplate(final IdxEmailTemplate idxEmailTemplate,
			final Map<String, String> mailSubjectValues, final Map<String, String> mailBodyValues,
			final String[] downloadedFiles) {
		final String mailSubject = prepareMailSubject(idxEmailTemplate.getSubject(), mailSubjectValues);

		final String mailBody = prepareMailBody(idxEmailTemplate.getCustomMessage(), mailBodyValues);

		boolean emailStatus = AppSendMailUtil.sendMail(idxEmailTemplate.getFromEmailId(),
				idxEmailTemplate.getFromName(), idxEmailTemplate.getToEmailId(), "", "", mailSubject, mailBody, true,
				downloadedFiles, idxEmailTemplate.getFromEmailId(), idxEmailTemplate.getReplyToEmailId(), null, null, null,
				0, false, null, null, null);
		logger.info(0L, "ESignatureService:sendEmailByTemplate:emailStatus:" + emailStatus);
	}

	/**
	 * Get Email Template From Apptivo Firm based on template Name.
	 * 
	 * @param templateName
	 * @param configuration
	 * @return
	 */
	public IdxEmailTemplate getEmailTemplateByTemplateName(String templateName, IdxConfiguration configuration) {
		if (configuration != null && AppUtil.checkListisNullOrNot(configuration.getEmailTemplates())) {
			for (IdxEmailTemplate emailTemplate : configuration.getEmailTemplates()) {
				if (templateName.equals(emailTemplate.getName())) {
					emailTemplate = MessageTemplateDAO.getInstance().setMessageNameAndMessageId(emailTemplate);
					return emailTemplate;
				}
			}
		}
		return null;
	}

	/**
	 * This method used to get Esign attributes label in pdf template by object id.
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * 
	 * @return 
	 * {
	 * 		12=[{"Label":"Signature1","Who":"Contact"}], 
	 * 		14=[{"Label":"Signature","Who":"Customer"}, {"Label":"Signature","Who":"Contact"}]
	 * }
	 */
	@SuppressWarnings("unchecked")
	public Map<String, JSONObject> getESignAttributesByPdfTemplate(final Long firmId, final Long objectId,
			final Long objectRefId) {
		final Map<String, JSONObject> eSignAttributes = new HashMap<>();

		final IdxPdfTemplate pdfTemplate = getPdfTemplateForAssociatedObject(firmId, objectId, objectRefId);

		if (pdfTemplate != null) {
			final String pdfTemplateContent = pdfTemplate.getContent();
			final JSONParser parser = new JSONParser();
			try {
				final JSONObject doc = (JSONObject) parser.parse(pdfTemplateContent);

				final JSONArray sections = (JSONArray) doc.get(AppConstants.LAYOUT_SECTIONS);
				// For old template attribute does not have attribute id so we set attribute id
				Long uniqueId = 0L;

				for (int sectionIndex = 0; sectionIndex < sections.size(); sectionIndex++) {
					final JSONObject section = (JSONObject) sections.get(sectionIndex);

					final JSONArray columns = (JSONArray) section.get(AppConstants.LAYOUT_COLUMNS);

					for (int i = 0; i < columns.size(); i++) {
						final JSONObject column = (JSONObject) columns.get(i);

						if (column.get(AppConstants.LAYOUT_ATTRIBUTES) != null) {
							final JSONArray attributes = (JSONArray) column.get(AppConstants.LAYOUT_ATTRIBUTES);

							for (int j = 0; j < attributes.size(); j++) {
								final JSONObject attribute = (JSONObject) attributes.get(j);
								final String attributeTag = (String) attribute.get(AppConstants.LAYOUT_ATTRIBUTE_TAG);
								final String attributeGroup = (String) attribute.get("attributeGroup");
								if ((ESignConstants.ATTR_TAG_ESIGN.equals(attributeTag) || "eSign".equals(attributeGroup))
										&& attribute.get(ESignConstants.ATTR_SIGN_FIELDS) != null){
//									final Long key = Long.valueOf(sectionIndex + "" + j);
									final JSONArray signFieldsArray = (JSONArray) attribute.get(ESignConstants.ATTR_SIGN_FIELDS);
									final JSONObject signField = (JSONObject) signFieldsArray.get(0);
									final JSONObject labelObject = (JSONObject) signField.get(ESignConstants.ATTR_LABEL);
									final JSONObject signAssignees = (JSONObject) signField.get(ESignConstants.ATTR_SIGN_ASSIGNEE);
									String attrType = (String) attribute.get(AppConstants.LAYOUT_TYPE);
									final JSONArray attrRight = (JSONArray) attribute.get(AppConstants.LAYOUT_ATTIBUTE_RIGHT);

									final JSONObject eSignAttribute = new JSONObject();
									if (attribute.get(AppConstants.ID) == null) {
										attribute.put(AppConstants.ID, uniqueId);
										uniqueId ++;
									}
									eSignAttribute.put(AppConstants.ID, attribute.get(AppConstants.ID));

									final Long attrId = (Long) attribute.get(AppConstants.ID);

									eSignAttribute.put(ESignConstants.ATTR_WHO, signAssignees.get(ESignConstants.ATTR_ID));
									eSignAttribute.put(ESignConstants.ATTR_LABEL, labelObject.get(ESignConstants.ATTR_TEXT));
									eSignAttribute.put(ESignConstants.ATTR_ALIGN, labelObject.get(ESignConstants.ATTR_ALIGN));
									eSignAttribute.put(ESignConstants.ATTR_BOLD, labelObject.get(ESignConstants.ATTR_BOLD));
									eSignAttribute.put(ESignConstants.ATTR_ITALIC, labelObject.get(ESignConstants.ATTR_ITALIC));
									eSignAttribute.put(ESignConstants.ATTR_FONT, labelObject.get(ESignConstants.ATTR_FONT));
									eSignAttribute.put(ESignConstants.ATTR_UNDERLINE, labelObject.get(ESignConstants.ATTR_UNDERLINE));
									eSignAttribute.put(ESignConstants.ATTR_FONTSIZE, labelObject.get(ESignConstants.ATTR_FONTSIZE));
									eSignAttribute.put(ESignConstants.ATTR_FONTCOLOR, labelObject.get(ESignConstants.ATTR_FONTCOLOR));

									if (ESignConstants.TYPE_ESIGNATURE.equalsIgnoreCase(attrType)) {
										attrType = ESignConstants.TYPE_SIGNATURE;
									}
									eSignAttribute.put(ESignConstants.ATTR_TYPE, attrType);

									eSignAttribute.put(ESignConstants.ATTR_IS_MANDATORY, signField.get(ESignConstants.ATTR_IS_MANDATORY));

									eSignAttribute.put(ESignConstants.ATTR_NUMOFCOLS, section.get(ESignConstants.ATTR_NUMOFCOLS));

									if (ESignConstants.TYPE_RADIO.equalsIgnoreCase(attrType) && attrRight != null) {
										final List<String> labels = new ArrayList<>();
										for(int optIndex = 0; optIndex < attrRight.size(); optIndex++) {
											final JSONObject attrRig = (JSONObject) attrRight.get(optIndex);
											if(AppConstants.STR_TRUE.equals(attrRig.get(ESignConstants.IS_ENABLED).toString())) {
												final JSONArray options = (JSONArray) attrRig.get(ESignConstants.ATTR_OPTIONS);
												labels.add(options.get(0).toString());
											}
										}
										eSignAttribute.put(ESignConstants.ATTR_OPTIONS, labels);
									}

									final JSONObject vcObj = (JSONObject) signField.get("visible");

									if (AppConstants.TRUE.equals(signField.get("isVisible"))
											&& vcObj != null && vcObj.get("conditionSets") != null
											&& AppConstants.TRUE.equals(vcObj.get("isConditional"))) {
										final IdxCriteriaSet vc = AppUtil.convertFromJson(IdxCriteriaSet.class,
												vcObj.toString());
										eSignAttribute.put(ESignConstants.VC, vc);
									}

									eSignAttributes.put(attrId.toString(), eSignAttribute);

								}
							}
						}
					}
				}
			} catch (ParseException exception) {
				logger.error(firmId, "ESignatureService:getESignAttributesByPdfTemplate:exception:", exception);
			}
		}
		// Sorting the Map for maintaining the order of sign attributes by section wise
		return new TreeMap<>(eSignAttributes);
	}

	/**
	 * Get PDF template id by associated object.
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @return
	 */
	public IdxPdfTemplate getPdfTemplateForAssociatedObject(final Long firmId, final Long objectId,
			final Long objectRefId) {
		IdxPdfTemplate pdfTemplate = null;
		Long pdfTemplateId = null;
		if (ObjectConstants.OBJECT_ESTIMATE.equals(objectId)) {
			final IdxEstimate idxEstimate = ElasticSearchDAO.getInstance().getDocument(firmId, IdxEstimate.class,
					ObjectConstants.OBJECT_ESTIMATE, objectRefId);
			final IdxPdfTemplateConfiguration configPdfTemplates = CommonUtil.getPdfTemplateConfiguration(firmId,
					ObjectConstants.OBJECT_ESTIMATE, ObjectConstants.OBJECT_ESTIMATES_SETTINGS_DATA);
			pdfTemplateId = idxEstimate.getTemplateId();
			pdfTemplate = EstimateElasticService.getInstance().getPdfTemplateById(pdfTemplateId,
					configPdfTemplates.getPdfTemplates());
		} else if (ObjectConstants.OBJECT_CONTRACT.equals(objectId)) {
			final IdxContract idxContract = ElasticSearchDAO.getInstance().getDocument(firmId, IdxContract.class,
					ObjectConstants.OBJECT_CONTRACT, objectRefId);
			final IdxPdfTemplateConfiguration configPdfTemplates = CommonUtil.getPdfTemplateConfiguration(firmId,
					ObjectConstants.OBJECT_CONTRACT, ObjectConstants.OBJECT_CONTRACT_SETTINGS_DATA);
			pdfTemplateId = idxContract.getContractTemplateId();
			pdfTemplate = EstimateElasticService.getInstance().getPdfTemplateById(pdfTemplateId,
					configPdfTemplates.getPdfTemplates());
		} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(objectId)) {
			final IdxWorkOrder idxWorkOrder = ElasticSearchDAO.getInstance().getDocument(firmId, IdxWorkOrder.class,
					ObjectConstants.OBJECT_SERVICE_WORK_ORDERS, objectRefId);
			final IdxPdfTemplateConfiguration configPdfTemplates = CommonUtil.getPdfTemplateConfiguration(firmId,
					ObjectConstants.OBJECT_SERVICE_WORK_ORDERS, ObjectConstants.OBJECT_SERVICE_WORK_ORDERS_SETTINGS_DATA);
			pdfTemplateId = idxWorkOrder.getTemplateId();
			pdfTemplate = WorkOrdersElasticService.getInstance().getPdfTemplateById(pdfTemplateId,
					configPdfTemplates.getPdfTemplates());
		} else if (ObjectConstants.OBJECT_CASE.equals(objectId) || objectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			final IdxCase idxCase = ElasticSearchDAO.getInstance().getDocument(firmId, IdxCase.class,
					ObjectConstants.OBJECT_CASE, objectRefId);
			final IdxPdfTemplateConfiguration configPdfTemplates = CommonUtil.getPdfTemplateConfiguration(firmId,
					objectId, ObjectConstants.OBJECT_CASES_SETTINGS_DATA);
			pdfTemplateId = idxCase.getPdfTemplateId();
			pdfTemplate = CommonServletService.getInstance().getPdfTemplateById(pdfTemplateId,
					configPdfTemplates.getPdfTemplates());
		} else {
			logger.info(firmId, "ESignatureService:getPdfTemplateForAssociatedObject:in else block");
		}
		return pdfTemplate;
	}

	/**
	 * This method used to update the associated object document id.
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @param documentId
	 * @param isResend
	 * @return
	 */
	public String updateAssociateObject(final Long firmId, final Long objectId, final Long objectRefId,
			final Long documentId, final String signType, final Boolean isESignCompleted, final Boolean isResend) {
		String objectRefNumber = null;
		if (ObjectConstants.OBJECT_ESTIMATE.equals(objectId)) {
			objectRefNumber = updateEstimate(firmId, objectRefId, documentId, signType, isESignCompleted, isResend);
		} else if (ObjectConstants.OBJECT_CONTRACT.equals(objectId)) {
			objectRefNumber = updateContract(firmId, objectRefId, documentId, signType, isESignCompleted, isResend);
		} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(objectId)) {
			objectRefNumber = updateWorkOrder(firmId, objectRefId, documentId, signType, isESignCompleted, isResend);
		} else if(ObjectConstants.OBJECT_CASE.equals(objectId) || objectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			objectRefNumber = updateCase(firmId, objectRefId, documentId, signType, isESignCompleted, isResend);
		} else {
			logger.info(firmId, "ESignatureService:updateAssociateObject:in else block");
		}
		return objectRefNumber;
	}

	/**
	 * This method used to update the estimate eSign Details
	 * - documentId
	 * - signType
	 * - isESignCompleted
	 * 
	 * @param firmId
	 * @param objectRefId
	 * @param documentId
	 * @param signType
	 * @param isESignCompleted
	 * @param isResend
	 * @return
	 */
	public String updateEstimate(final Long firmId, final Long objectRefId, final Long documentId,
			final String signType, final Boolean isESignCompleted, final Boolean isResend) {
		final IdxEstimate idxEstimate = ElasticSearchDAO.getInstance().getDocument(firmId, IdxEstimate.class,
				ObjectConstants.OBJECT_ESTIMATE, objectRefId);
		if (idxEstimate != null) {
			if (documentId != null) {
				idxEstimate.setDocumentId(documentId.toString());
			}
			if (signType != null) {
				idxEstimate.setSignType(signType);
			}
			if (isESignCompleted != null) {
				idxEstimate.setESignCompleted(isESignCompleted);
			}
			// In Resend scenario, we need to reset esignatures
			if (Boolean.TRUE.equals(isResend)) {
				idxEstimate.seteSignatures(null);
			}

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESTIMATE, objectRefId,
					AppUtil.convertToJson(idxEstimate));
			return idxEstimate.getEstimateNumber();
		}
		return null;
	}

	/**
	 * This method used to update the contract eSign Details
	 * - documentId
	 * - signType
	 * - isESignCompleted
	 * 
	 * @param firmId
	 * @param objectRefId
	 * @param documentId
	 * @param signType
	 * @param isESignCompleted
	 * @param isResend
	 * @return
	 */
	public String updateContract(final Long firmId, final Long objectRefId, final Long documentId,
			final String signType, final Boolean isESignCompleted, final Boolean isResend) {
		final IdxContract idxContract = ElasticSearchDAO.getInstance().getDocument(firmId, IdxContract.class,
				ObjectConstants.OBJECT_CONTRACT, objectRefId);
		if (idxContract != null) {
			if (documentId != null) {
				idxContract.setDocumentId(documentId.toString());
			}
			if (signType != null) {
				idxContract.setSignType(signType);
			}
			if (isESignCompleted != null) {
				idxContract.setESignCompleted(isESignCompleted);
			}
			// In Resend scenario, we need to reset esignatures 
			if (Boolean.TRUE.equals(isResend)) {
				idxContract.seteSignatures(null);
			}

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_CONTRACT, objectRefId,
					AppUtil.convertToJson(idxContract));
			return idxContract.getContractNumber() != null ? idxContract.getContractNumber() : idxContract.getContractName();
		}
		return null;
	}

	/**
	 * This method used to update the workOrder eSign Details
	 * - documentId
	 * - signType
	 * - isESignCompleted
	 * 
	 * @param firmId
	 * @param objectRefId
	 * @param documentId
	 * @param signType
	 * @param isESignCompleted
	 * @param isResend
	 * @return
	 */
	public String updateWorkOrder(final Long firmId, final Long objectRefId, final Long documentId,
			final String signType, final Boolean isESignCompleted, final Boolean isResend) {
		final IdxWorkOrder idxWorkOrder = ElasticSearchDAO.getInstance().getDocument(firmId, IdxWorkOrder.class,
				ObjectConstants.OBJECT_SERVICE_WORK_ORDERS, objectRefId);
		if (idxWorkOrder != null) {
			if (documentId != null) {
				idxWorkOrder.setDocumentId(documentId.toString());
			}
			if (signType != null) {
				idxWorkOrder.setSignType(signType);
			}
			if (isESignCompleted != null) {
				idxWorkOrder.setESignCompleted(isESignCompleted);
			}
			// In Resend scenario, we need to reset esignatures 
			if (Boolean.TRUE.equals(isResend)) {
				idxWorkOrder.seteSignatures(null);
			}

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_SERVICE_WORK_ORDERS,
					objectRefId, AppUtil.convertToJson(idxWorkOrder));
			return idxWorkOrder.getWorkOrderNumber();
		}
		return null;
	}

	/**
	 * This method used to update the Case eSign Details
	 * - documentId
	 * - signType
	 * - isESignCompleted
	 *
	 * @param firmId
	 * @param objectRefId
	 * @param documentId
	 * @param signType
	 * @param isESignCompleted
	 * @param isResend
	 * @return
	 */
	public String updateCase(final Long firmId, final Long objectRefId, final Long documentId,
			final String signType, final Boolean isESignCompleted, final Boolean isResend) {
		final IdxCase idxCase = ElasticSearchDAO.getInstance().getDocument(firmId, IdxCase.class,
				ObjectConstants.OBJECT_CASE, objectRefId);
		if (idxCase != null) {
			if (documentId != null) {
				idxCase.setDocumentId(documentId.toString());
			}
			if (signType != null) {
				idxCase.setSignType(signType);
			}
			if (isESignCompleted != null) {
				idxCase.setESignCompleted(isESignCompleted);
			}
			// In Resend scenario, we need to reset esignatures
			if (Boolean.TRUE.equals(isResend)) {
				idxCase.seteSignatures(null);
			}

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_CASE,
					objectRefId, AppUtil.convertToJson(idxCase));
			return idxCase.getCaseNumber();
		}
		return null;
	}

	/**
	 * This method used to get the associated object Ref name.
	 *
	 * @param firmId
	 * @param objectId
	 * @param objectRefNumber
	 * @return
	 */
	public String getDocumentNameESign(final Long firmId, final Long objectId, final String objectRefNumber) {
		String docName = null;
		if (ObjectConstants.OBJECT_ESTIMATE.equals(objectId)) {
			final IdxEstimateConfiguration config = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
					IdxEstimateConfiguration.class, ObjectConstants.OBJECT_ESTIMATES_SETTINGS_DATA, firmId);
			if (config != null && config.getAppName() != null) {
				docName = config.getAppName() + " #: " + objectRefNumber;
			} else {
				docName = AppConstants.ESTIMATE_NUMBER_PREFIX + " " + objectRefNumber;
			}
		} else if (ObjectConstants.OBJECT_CONTRACT.equals(objectId)) {
			final IdxContractsConfiguration config = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
					IdxContractsConfiguration.class, ObjectConstants.OBJECT_CONTRACT_SETTINGS_DATA, firmId);
			if (config != null && config.getAppName() != null) {
				docName = config.getAppName() + " #: " + objectRefNumber;
			} else {
				docName = AppConstants.CONTRACT_NUMBER_PREFIX + " " + objectRefNumber;
			}
		} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(objectId)) {
			final IdxWorkOrdersConfiguration config = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
					IdxWorkOrdersConfiguration.class, ObjectConstants.OBJECT_SERVICE_WORK_ORDERS_SETTINGS_DATA, firmId);
			if (config != null && config.getAppName() != null) {
				docName = config.getAppName() + " #: " + objectRefNumber;
			} else {
				docName = AppConstants.WORKORDER_NUMBER_PREFIX + " " + objectRefNumber;
			}
		} else if (ObjectConstants.OBJECT_CASE.equals(objectId)
				|| objectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			final IdxConfiguration config = AppSettingsDAO.getInstance().getConfigData(firmId, objectId);
			if (config != null && config.getAppName() != null) {
				docName = config.getAppName() + " #: " + objectRefNumber;
			} else {
				docName = AppConstants.CASE_NUMBER_PREFIX + " " + objectRefNumber;
			}
		} else {
			logger.info(firmId, "ESignatureService:getDocumentNameESign:in else block");
		}
		return docName;
	}

	/**
	 * This method used to find the hashvalue for the file.
	 * 
	 * @param filePath
	 * @return
	 */
	public String generateHashCode(String filePath) {
		try {
			final MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
			return getHashValue(filePath, messageDigest);
		} catch (NoSuchAlgorithmException exception) {
			logger.error("ESignatureService:generateHashCode:exception:", exception);
		}
		return null;
	}

	/**
	 * To Generate the hash Value
	 * 
	 * @param filePath
	 * @param messageDigest
	 * @return
	 */
	public String getHashValue(final String filePath, MessageDigest messageDigest) {
		final StringBuilder result = new StringBuilder();
		try (DigestInputStream dis = new DigestInputStream(new FileInputStream(filePath), messageDigest)) {
			messageDigest = dis.getMessageDigest();
			for (byte b : messageDigest.digest()) {
				result.append(String.format("%02x", b));
			}
			return result.toString();
		} catch (Exception exception) {
			logger.error("ESignatureService:getHashValue:error while hashing file:", exception);
		}
		return null;
	}
	
	/**
	 * This method used to verify the hash value of the signed document.
	 *
	 * @param idxESignDocument
	 * @param fileContent
	 * @param docRevId
	 * @return
	 */
	public boolean verifyHashValue(final IdxESignDocument idxESignDocument, final byte[] fileContent,
			final String docRevId) {
		final Long firmId = idxESignDocument.getFirmId();

		try {
			String inputPDFName;
			String fileId;
			String hashcode;

			if(docRevId != null) {
				inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId + "_"
						+ docRevId + "_" + System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;
				logger.info(firmId, "ESignatureService:verifyHashValue:inputPDFName:" + inputPDFName);

				final File createdInputPDF = new File(inputPDFName);
				FileUtils.writeByteArrayToFile(createdInputPDF, fileContent);

				hashcode = generateHashCode(inputPDFName);
				logger.info(firmId, "ESignatureService:verifyHashValue:hashCode:" + hashcode);

				fileId = idxESignDocument.getFirmId() + "_" + docRevId;
			} else {
				inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
						+ firmId + "_" + idxESignDocument.getSenderDetails().getSourceRefId() + "_"
						+ idxESignDocument.geteSignDocumentId() + "_" + System.currentTimeMillis()
						+ AppConstants.PDF_FILE_EXTENSION;
				logger.info(firmId, "ESignatureService:verifyHashValue:inputPDFName:" + inputPDFName);

				final File createdInputPDF = new File(inputPDFName);
				FileUtils.writeByteArrayToFile(createdInputPDF, fileContent);

				hashcode = generateHashCode(inputPDFName);
				logger.info(firmId, "ESignatureService:verifyHashValue:hashCode:" + hashcode);

				fileId = idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId();
			}

			final Path createInputPDF = Paths.get(inputPDFName);
			Files.deleteIfExists(createInputPDF);

			return BlockchainService.getInstance().verifyHash(firmId, fileId, hashcode);
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:verifyHashValue:IOException:", exception);
		}
		return true;
	}

	/**
	 * This method used to make entry to the block chain.
	 * 
	 * @param firmId
	 * @param revisionId
	 * @param signerName
	 * @param filePath
	 * @return
	 */
	public void saveToBlockChain(final Long firmId, final String revisionId, final String signerName,
			final String filePath) {
		try {
			final String fileId = firmId + "_" + revisionId;
			final String hashcode = generateHashCode(filePath);
			final String currentDate = new SimpleDateFormat(DateUtil.format_mdyhms).format(new Date());

			BlockchainService.getInstance().createFile(firmId, fileId, hashcode, signerName, currentDate);

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:saveToBlockChain:IOException:", exception);
		}
	}

	/**
	 * This method used to update the esignatures for associated objects
	 * - Estimate, Contract and Workorder
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @param eSignatures
	 */
	public void updateAssociatedESignatures(final Long firmId, final Long objectId, final Long objectRefId,
			final List<IdxEsignature> eSignatures) {
		if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)) {
			logger.info(firmId, "ESignatureService:updateAssociatedESignatures:esign document");
		} else if (ObjectConstants.OBJECT_ESTIMATE.equals(objectId)) {
			final IdxEstimate estimate = ElasticSearchDAO.getInstance().getDocument(firmId, IdxEstimate.class,
					ObjectConstants.OBJECT_ESTIMATE, objectRefId);
			estimate.geteSignatures().addAll(eSignatures);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESTIMATE, objectRefId,
					AppUtil.convertToJson(estimate));
		} else if (ObjectConstants.OBJECT_CONTRACT.equals(objectId)) {
			final IdxContract contract = ElasticSearchDAO.getInstance().getDocument(firmId, IdxContract.class,
					ObjectConstants.OBJECT_CONTRACT, objectRefId);
			contract.geteSignatures().addAll(eSignatures);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_CONTRACT, objectRefId,
					AppUtil.convertToJson(contract));
		} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(objectId)) {
			final IdxWorkOrder workOrder = ElasticSearchDAO.getInstance().getDocument(firmId, IdxWorkOrder.class,
					ObjectConstants.OBJECT_SERVICE_WORK_ORDERS, objectRefId);
			workOrder.geteSignatures().addAll(eSignatures);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_SERVICE_WORK_ORDERS, objectRefId,
					AppUtil.convertToJson(workOrder));
		} else if (ObjectConstants.OBJECT_CASE.equals(objectId) || objectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			final IdxCase idxCase = ElasticSearchDAO.getInstance().getDocument(firmId, IdxCase.class,
					ObjectConstants.OBJECT_CASE, objectRefId);
			idxCase.geteSignatures().addAll(eSignatures);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_CASE, objectRefId,
					AppUtil.convertToJson(idxCase));
		} else {
			logger.info(firmId, "ESignatureService:updateAssociatedESignatures:in else block");
		}
	}
	
	/**
	 * To get all ESignAttributes in ESignDocument.
	 * 
	 * @param idxESignDocument
	 * @return
	 */
	public List<IdxEsignAttribute> getAllESignAttributes(final IdxESignDocument idxESignDocument) {
		final List<IdxEsignAttribute> idxESignAttributes = new ArrayList<>();
		for(IdxEsignDocumentPage idxESignDocumentPage : idxESignDocument.getDocumentPages()) {
			idxESignAttributes.addAll(idxESignDocumentPage.geteSignAttributes());
		}
		logger.info(idxESignDocument.getFirmId(),
				"ESignatureService:getAllESignAttributes:idxESignAttributes:size:" + idxESignAttributes.size());
		return idxESignAttributes;
	}

	/**
	 * To get all Histories of eSignDocument by document id.
	 * 
	 * @param firmId
	 * @param documentId
	 * @return
	 */
	public List<IdxEsignatureHistory> getESignDocHistories(final Long firmId, final Long documentId,
			final TimeZone timeZone) {
		final List<IdxEsignatureHistory> idxEsignatureHistories = new ArrayList<>();

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery(ESignConstants.REQUEST_PARAM_DOCUMENT_ID, documentId));
		builder.setQuery(andBuilder);

		builder.addSort(ESignConstants.HISTORY_DATE, SortOrder.ASC);
		int batchSize  = ElasticSearchDAO.DEFAULT_ES_500_RESULTS;
		builder.setSize(batchSize);
		builder.setScroll(new TimeValue(ElasticSearchDAO.DEFAULT_ES_60K_SCROLL_TIME_VALUE));

		logger.info(firmId, "EsignatureService:getESignDocHistories:builder:" + builder.toString());

		SearchResponse response = builder.execute().actionGet();

		if (response.getHits().getHits().length != 0) {
			do {
				for (SearchHit hit : response.getHits().getHits()) {
					final IdxEsignatureHistory idxEsignatureHistory = AppUtil.convertFromJson(IdxEsignatureHistory.class,
							hit.getSourceAsString());
					idxEsignatureHistory.setHistoryId(hit.getId());
					idxEsignatureHistory.formatDateValues(timeZone);
					idxEsignatureHistories.add(idxEsignatureHistory);
				}
				if (response.getHits().getHits().length < batchSize) {
					break;
				}
				response = ElasticSearchDAO.getInstance().getClient(firmId).prepareSearchScroll(response.getScrollId())
						.setScroll(new TimeValue(ElasticSearchDAO.DEFAULT_ES_60K_SCROLL_TIME_VALUE)).execute().actionGet();
			} while (response.getHits().getHits().length != 0);
			ESAPIUtil.freeSearchResponse(firmId, response);
		} else {
			logger.info(firmId, "EsignatureService:getESignDocHistories:no hits:returning empty list");
		}
		logger.info(firmId, "EsignatureService:getESignDocHistories:size:" + idxEsignatureHistories.size());
		return idxEsignatureHistories;
	}
	
	/**
	 * get all documents data 
	 * 
	 * @param firmId
	 * @param objectId
	 * @param startIndex
	 * @param numRecords
	 * @param sortColumn
	 * @param sortDir
	 * @param userData
	 * @param objectStatus
	 * @param isDashboardView
	 * @param isTemplate
	 * @param isEnabled
	 * @param selectedFilter
	 * @param selectedTab
	 * @return
	 */
	public Map<String, Object> getAll(final Long firmId, final Long objectId, final Integer startIndex,
			final Integer numRecords, final String sortColumn, final String sortDir, final UserData userData,
			final String objectStatus, final boolean isDashboardView, final String isTemplate, final String isEnabled,
			final String selectedFilter, final String selectedTab) {
		final Map<String, Object> result = new HashMap<>();

		final String[] includes = { AppConstants.FIRM_ID, ESignConstants.ESIGN_DOCUMENT_ID, ESignConstants.DOC_NAME,
				ESignConstants.TEMPLATE_NAME, ESignConstants.SIGN_TYPE, ESignConstants.IS_ENABLED,
				ESignConstants.STATUS_NAME, ESignConstants.STATUS_CODE, ESignConstants.IS_SENT,
				AppConstants.CREATED_BY_NAME, AppConstants.CREATION_DATE, ESignConstants.SENDER_DETAILS,
				ESignConstants.ASSOCIATED_OBJECT };
		final String[] excludes = {};

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(objectId.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH)
				.setFetchSource(includes, excludes)
				.setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		if (objectStatus != null) {
			andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, objectStatus));
		} else {
			andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, AppConstants.OBJECT_STATUS_ACTIVE));
		}

		if (ESignConstants.MY_DOCUMENTS.equalsIgnoreCase(selectedTab)) {
			final QueryBuilder objectRefIdNestedQuery = QueryBuilders.boolQuery()
					.must(QueryBuilders.termQuery(ESignConstants.ASSIGNEES_OBJECT_REF_ID, userData.getEmployeeId()));
			andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSIGNEES, objectRefIdNestedQuery));
		} else if(AppConstants.BOOLEAN_TRUE.equals(isTemplate)) {
			// No need to set access level for templates
		} else {
			generateBuilderByAccessLevel(firmId, userData, andBuilder);
		}

		// For showing the sign.co documents
		// Update: Now we'll show all documents in Sign.co - Case:87712
		// andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSOCIATED_OBJECT, QueryBuilders.boolQuery()
		//	.must(QueryBuilders.termsQuery(ESignConstants.ASSOCIATED_OBJECT_ID, ESignConstants.SIGN_OBJECT_ID))));

		if (AppConstants.BOOLEAN_TRUE.equals(isEnabled)) {
			andBuilder.must(QueryBuilders.termQuery(ESignConstants.IS_ENABLED, true));
		}

		if (AppConstants.BOOLEAN_TRUE.equals(isTemplate)) {
			andBuilder.must(QueryBuilders.termQuery(ESignConstants.IS_TEMPLATE, true));
		} else {
			andBuilder.mustNot(QueryBuilders.termQuery(ESignConstants.IS_TEMPLATE, true));
		}

		if (AppUtil.checkStringNullOrNot(selectedFilter)) {
			final List<String> selectedFilters = AppUtil.convertFromJsonToStringList(selectedFilter);
			if (AppUtil.checkListisNullOrNot(selectedFilters)) {
				andBuilder.must(QueryBuilders.termsQuery(ESignConstants.STATUS_CODE, selectedFilters));
			}
		}

		if (isDashboardView) {
			andBuilder.must(QueryBuilders.termsQuery(ESignConstants.STATUS_CODE, ESignConstants.ESIGN_DOCUMENT_STATUSES));

			final AggregationBuilder filterAgg = AggregationBuilders.filter(ESignConstants.ESIGN_DOCUMENTS, andBuilder);
			final AggregationBuilder statuses = AggregationBuilders.terms(ESignConstants.ESIGN_STATUSES)
					.field(ESignConstants.STATUS_CODE);
			filterAgg.subAggregation(statuses);
			builder.addAggregation(filterAgg);
		}
		builder.setPostFilter(andBuilder);
		setSortSizeToBuilder(builder, sortColumn, sortDir, startIndex, numRecords);

		logger.info(firmId, "ESignatureService:getAll:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		final List<IdxESignDocument> idxESignDocuments = new ArrayList<>();
		if (hits != null && hits.length > 0) {
			for (final SearchHit hit : hits) {
				final IdxESignDocument idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class,
						hit.getSourceAsString());
				idxESignDocument.formatDateValues(userData.getTimeZone(), null);
				idxESignDocuments.add(idxESignDocument);
			}
		}

		if (isDashboardView) {
			Map<String, Long> docStatusCount = new HashMap<>();
			InternalFilter eSignDoc = response.getAggregations().get(ESignConstants.ESIGN_DOCUMENTS);
			Terms statusesResult = eSignDoc.getAggregations().get(ESignConstants.ESIGN_STATUSES);
			for (Terms.Bucket entry : statusesResult.getBuckets()) {
				if (AppUtil.checkStringNullOrNot(entry.getKeyAsString())) {
					docStatusCount.put(entry.getKeyAsString(), entry.getDocCount());
				}
			}
			result.put(ESignConstants.RESPONSE_PARAM_DASHBOARD_COUNTS, docStatusCount);
		}
		logger.info(firmId, "Esignatureservice:getAll:response:totalHits:" + response.getHits().getTotalHits().value);
		result.put(ESignConstants.RESPONSE_PARAM_COUNT, response.getHits().getTotalHits().value);
		if (!isDashboardView) {
			result.put(ESignConstants.RESPONSE_PARAM_DOCUMENTS, idxESignDocuments);
		}
		return result;
	}
	
	/**
	 * This method  used to get the recent document Ids.
	 * 
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public List<Long> getAllRecentDocumentIds(final Long firmId, final UserData userData) {
		final List<Long> documentIds = new ArrayList<>();

		final String[] includes = { ESignConstants.ESIGN_DOCUMENT_ID };
		final String[] excludes = {};

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setFetchSource(includes, excludes).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, AppConstants.OBJECT_STATUS_ACTIVE));
		generateBuilderByAccessLevel(firmId, userData, andBuilder);

		builder.setPostFilter(andBuilder);
		setSortSizeToBuilder(builder, AppConstants.CREATION_DATE, AppConstants.COMMON_SORT_DESC, 0, 12);

		logger.info(firmId, "ESignatureService:getAllRecentDocumentIds:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		for (final SearchHit hit : hits) {
			documentIds.add(Long.valueOf(hit.getId()));
		}
		return documentIds;
	}

	/**
	 * get all idxEsignatureHistory for sign.co 
	 * 
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public Map<String, Object> getAllDashBoardHistory(final Long firmId, final UserData userData) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		// TODO: Need to add document id's in esignature history for sign.co documents
		final List<Long> recentDocIds = getAllRecentDocumentIds(firmId, userData);
		final BoolQueryBuilder orBuilder = QueryBuilders.boolQuery();
		orBuilder.should(QueryBuilders.termsQuery(AppConstants.STR_OBJECT_REF_ID, recentDocIds));
		orBuilder.should(QueryBuilders.termsQuery(ESignConstants.DOCUMENT_ID, recentDocIds));
		andBuilder.must(orBuilder);

		builder.setPostFilter(andBuilder);

		builder.addSort(ESignConstants.HISTORY_DATE, SortOrder.DESC);
		builder.setSize(12);

		logger.info(firmId, "Esignatureservice:getAllHistory:builder:" + builder.toString());
		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();
		final Map<String, Object> result = new HashMap<>();
		final List<IdxEsignatureHistory> idxHistory = new ArrayList<>();
		if (hits != null && hits.length > 0) {
			for (final SearchHit hit : hits) {
				final IdxEsignatureHistory idxEsignatureHistory = AppUtil.convertFromJson(IdxEsignatureHistory.class,
						hit.getSourceAsString());
				idxEsignatureHistory.formatDateValues(userData.getTimeZone());
				idxHistory.add(idxEsignatureHistory);
			}
		}
		logger.info(firmId, "Esignatureservice:getAllHistory:response.:totalHits:" + response.getHits().getTotalHits().value);
		result.put(ESignConstants.RESPONSE_PARAM_COUNT, response.getHits().getTotalHits().value);
		result.put(ESignConstants.RESPONSE_PARAM_DOCUMENTS, idxHistory);
		return result;
	}
	
	/**
	 * Get document By Statuses
	 * 
	 * @param startIndex
	 * @param numRecords
	 * @param sortColumn
	 * @param sortDir
	 * @param userData
	 * @param objectStatus
	 * @return
	 */
	public Map<String, Object> getByStatus(final Integer startIndex, final Integer numRecords, final String sortColumn,
			final String sortDir, UserData userData, final String objectStatus) {
		final Map<String, Object> result = new HashMap<>();

		final Long firmId = userData.getFirmId();

		final String[] includes = { AppConstants.FIRM_ID, ESignConstants.ESIGN_DOCUMENT_ID, ESignConstants.DOC_NAME,
				ESignConstants.STATUS_NAME, ESignConstants.STATUS_CODE, AppConstants.CREATED_BY_NAME,
				AppConstants.CREATION_DATE, ESignConstants.SENDER_DETAILS, ESignConstants.ASSOCIATED_OBJECT };
		final String[] excludes = {};

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH)
				.setFetchSource(includes, excludes)
				.setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		andBuilder.mustNot(QueryBuilders.termQuery(ESignConstants.IS_TEMPLATE, true));

		generateBuilderByAccessLevel(firmId, userData, andBuilder);

		andBuilder.must(QueryBuilders.termQuery(ESignConstants.STATUS_CODE,
				ESignConstants.ESIGN_DOCUMENT_STATUS_NEW.toUpperCase()));

		if (objectStatus != null) {
			andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, objectStatus));
		} else {
			andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, AppConstants.OBJECT_STATUS_ACTIVE));
		}

		builder.setPostFilter(andBuilder);
		setSortSizeToBuilder(builder, sortColumn, sortDir, startIndex, numRecords);

		logger.info(firmId, "Esignatureservice:getAll:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		final List<IdxESignDocument> idxESignDocuments = new ArrayList<>();
		if (hits != null && hits.length > 0) {
			for (final SearchHit hit : hits) {
				final IdxESignDocument idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class,
						hit.getSourceAsString());
				idxESignDocument.formatDateValues(userData.getTimeZone(), null);
				idxESignDocuments.add(idxESignDocument);
			}
		}
		
		result.put(ESignConstants.RESPONSE_PARAM_COUNT, response.getHits().getTotalHits().value);
		result.put(ESignConstants.RESPONSE_PARAM_DOCUMENTS, idxESignDocuments);
		return result;
	}
	
	/**
	 * can reuse it to set to the builder such as,.. sort column, sort Dir, start index, number of results
	 * 
	 * @param builder
	 * @param sortColumn
	 * @param sortDir
	 * @param startIndex
	 * @param numResults
	 */
	public void setSortSizeToBuilder(final SearchRequestBuilder builder, final String sortColumn,
			final String sortDir, final Integer startIndex, final Integer numResults)
	{
		if ((sortColumn != null) && !sortColumn.trim().isEmpty()) {
			if (AppConstants.COMMON_SORT_ASC.equalsIgnoreCase(sortDir)) {
				builder.addSort(sortColumn, SortOrder.ASC);
			} else {
				builder.addSort(sortColumn, SortOrder.DESC);
			}
		}

		if (startIndex != null && startIndex >= 0) {
			builder.setTrackTotalHits(true).setFrom(startIndex);
		} else {
			builder.setTrackTotalHits(true).setFrom(0);
		}

		if ((numResults != null) && (numResults > 0)) {
			builder.setSize(numResults);
		} else {
			builder.setSize(ElasticSearchDAO.DEFAULT_ES_MAX_RESULTS);
		}
	}
	
	/**
	 * This method used to get Documents for Kanban View.
	 *
	 * @param firmId
	 * @param objectId
	 * @param startIndex
	 * @param numRecords
	 * @param userData
	 * @param selectedTab
	 * @return
	 */
	public Map<String, List<IdxESignDocument>> getAllByKanbanView(final Long firmId, final Long objectId,
			final Integer startIndex, final Integer numRecords, final UserData userData, final String selectedTab) {
		final Map<String, List<IdxESignDocument>> results = new HashMap<>();

		final String[] includes = { AppConstants.FIRM_ID, ESignConstants.ESIGN_DOCUMENT_ID, ESignConstants.DOC_NAME,
				ESignConstants.STATUS_NAME, ESignConstants.STATUS_CODE, ESignConstants.SENDER_DETAILS,
				ESignConstants.SIGNERS, ESignConstants.SIGN_TYPE, ESignConstants.IS_SENT, AppConstants.CREATED_BY_NAME,
				AppConstants.CREATION_DATE, ESignConstants.ASSOCIATED_OBJECT };
		final String[] excludes = {};

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(objectId.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH)
				.setFetchSource(includes, excludes)
				.setExplain(false);

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, AppConstants.OBJECT_STATUS_ACTIVE));

		if (ESignConstants.MY_DOCUMENTS.equalsIgnoreCase(selectedTab)) {
			final QueryBuilder objectRefIdNestedQuery = QueryBuilders.boolQuery()
					.must(QueryBuilders.termQuery(ESignConstants.ASSIGNEES_OBJECT_REF_ID, userData.getEmployeeId()));

			andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSIGNEES, objectRefIdNestedQuery));
		} else {
			generateBuilderByAccessLevel(firmId, userData, andBuilder);
		}
		andBuilder.mustNot(QueryBuilders.termQuery(ESignConstants.IS_TEMPLATE, true));

		// We preparing query for when startIndex is greater than 100.
		if (startIndex + numRecords > AppConstants.TOP_HITS_AGGREGATION_LIMIT) {
			// Setting the startIndex as from and numberofRecords as Size.
			builder.setFrom(startIndex).setSize(numRecords);

			// Adding sort with creationDate
			builder.addSort(AppConstants.CREATION_DATE, SortOrder.DESC);

			// Iterating the document status.
			for (String status : ESignConstants.ESIGN_DOCUMENT_STATUSES) {
				// Preparing queryBuilder for to set statusCode.
				final BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();
				queryBuilder.must(andBuilder);
				queryBuilder.must(QueryBuilders.termQuery(ESignConstants.STATUS_CODE, status));

				// added queryBuilder values in to builder
				builder.setPostFilter(queryBuilder);
				logger.info(firmId, "ESignatureService:getAllByKanbanView:builder:" + builder.toString());
				final SearchResponse searchRes = builder.execute().actionGet();

				// Iterating searchHit based on searchResponse and preparing eSignDocument records.
				final List<IdxESignDocument> idxESignDocuments = new ArrayList<>();
				for (SearchHit searchHit : searchRes.getHits()) {
					final IdxESignDocument idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class,
							searchHit.getSourceAsString());
					idxESignDocument.formatDateValues(userData.getTimeZone(), null);
					idxESignDocuments.add(idxESignDocument);
				}

				// Saving the idxESignDocuments based on status.
				results.put(status, idxESignDocuments);
			}
		} else {
			// This block is used for when startIndex is less than 100.
			andBuilder.must(QueryBuilders.termsQuery(ESignConstants.STATUS_CODE, ESignConstants.ESIGN_DOCUMENT_STATUSES));

			// Preparing TopHits aggregations based on startIndex and numofRecords
			final TopHitsAggregationBuilder hitsAgg = AggregationBuilders.topHits(AppConstants.STR_HITS).from(startIndex)
					.size(numRecords).fetchSource(includes, excludes);
			final FieldSortBuilder fieldSortBuilder = SortBuilders.fieldSort(AppConstants.CREATION_DATE);
			fieldSortBuilder.order(SortOrder.DESC);
			hitsAgg.sort(fieldSortBuilder);

			// preparing AggregationBuilder to fetch eSignDocuemnt based on Esign document status.
			final AggregationBuilder filterAgg = AggregationBuilders.filter(ESignConstants.ESIGN_DOCUMENTS, andBuilder);
			final AggregationBuilder statuses = AggregationBuilders.terms(ESignConstants.ESIGN_STATUSES)
					.field(ESignConstants.STATUS_CODE);

			filterAgg.subAggregation(statuses.subAggregation(hitsAgg));
			builder.addAggregation(filterAgg);
			logger.info(firmId, "ESignatureService:getAllByKanbanView:builder:" + builder.toString());

			// Preparing filter aggregation based on document statuses.
			final InternalFilter filteragg = builder.execute().actionGet().getAggregations()
					.get(ESignConstants.ESIGN_DOCUMENTS);
			final Terms agg = filteragg.getAggregations().get(ESignConstants.ESIGN_STATUSES);

			for (Terms.Bucket entry : agg.getBuckets()) {
				if (AppUtil.checkStringNullOrNot(entry.getKeyAsString())) {

					final List<IdxESignDocument> idxESignDocuments = new ArrayList<>();
					final TopHits topHits = entry.getAggregations().get(AppConstants.STR_HITS);
					final SearchHits searchHits = topHits.getHits();

					for (SearchHit searchHit : searchHits.getHits()) {
						final IdxESignDocument idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class,
								searchHit.getSourceAsString());
						idxESignDocument.formatDateValues(userData.getTimeZone(), null);
						idxESignDocuments.add(idxESignDocument);
					}
					results.put(entry.getKeyAsString(), idxESignDocuments);
				} else {
					results.put(entry.getKeyAsString(), null);
				}
			}
		}
		return results;

	}
	
	/**
	 * To set default signer details for Sign-Own
	 * 
	 * @param idxESignDocument
	 * @return
	 */
	public void createDefaultSigner(final IdxESignDocument idxESignDocument) {
		final IdxESignSigner idxESignSigners = new IdxESignSigner(
				AppBaseDAO.getInstance().getSequenceNextVal(idxESignDocument.getFirmId(),
						AppConstants.APP_SEQ_ESIGN_SIGNER_ID),
				idxESignDocument.getAssociatedObject().getObjectId(),
				idxESignDocument.getSenderDetails().getObjectRefName(),
				idxESignDocument.getSenderDetails().getEmailId(), ESignConstants.SIGNER_STATUS_UPLOADED.toUpperCase(),
				ESignConstants.SIGNER_ACTION_NEED_SIGN);
		idxESignDocument.getSigners().add(idxESignSigners);
	}

	/**
	 * This method used to create document Viewed History based on SignType of document.
	 *
	 * @param firmId
	 * @param signerId
	 * @param idxESignDocument
	 * @param clientIpAddress
	 * @param userAgent
	 * @return
	 */
	public IdxESignDocument createViewHistoryBySignType(final Long firmId, final Long signerId,
			final IdxESignDocument idxESignDocument, final String clientIpAddress, final String userAgent) {
		boolean isNeedToIndex = false;

		// IN_PERSON_SIGN - Creating View History and Updating signer status for all signers.
		if (ESignConstants.IN_PERSON_SIGN.equalsIgnoreCase(idxESignDocument.getSignType())) {
			for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
				if (ESignConstants.SIGNER_STATUS_NEW.equalsIgnoreCase(idxESignSigner.getSignerStatus())) {
					createESignatureHistory(firmId, idxESignDocument, idxESignSigner,
							AppConstants.ESIGN_VIEWED, AppConstants.ESIGN_DESC_VIEW, clientIpAddress, userAgent, null);
					idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_VIEWED.toUpperCase());
					isNeedToIndex = true;
				}
			}
		} else {
			// SEND_SIGN and SIGN_OWN - Creating view history and Updating signer status based on the signerId.
			final IdxESignSigner idxESignSigner = idxESignDocument.getESignSignerBySignerId(signerId);
			if (idxESignSigner != null
					&& (ESignConstants.SIGNER_STATUS_SENT.equalsIgnoreCase(idxESignSigner.getSignerStatus())
							|| ESignConstants.SIGNER_STATUS_NEW.equalsIgnoreCase(idxESignSigner.getSignerStatus()))) {
				createESignatureHistory(firmId, idxESignDocument, idxESignSigner, AppConstants.ESIGN_VIEWED,
						AppConstants.ESIGN_DESC_VIEW, clientIpAddress, userAgent, null);
				idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_VIEWED.toUpperCase());
				isNeedToIndex = true;

				// Action Center - Viewed
				if (!idxESignDocument.getSenderDetails().getEmailId().equals(idxESignSigner.getPrimaryEmailId())
						&& ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
					ESignEventActionService.getInstance().produceActionQueue(firmId, idxESignDocument, idxESignSigner,
							null, ESignConstants.AE_CODE_VIEWED);
				}
			}
		}

		if(isNeedToIndex) {
			updateESignDocument(firmId, idxESignDocument);
		}

		return idxESignDocument;
	}

	/**
	 * This method used to sign IN_PERSON_SIGN Type Document.
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @param result
	 * @param timeZoneId
	 * @param clientIpAddress
	 * @param userAgent
	 */
	public void signInPersonDocument(final Long firmId, final IdxESignDocument idxESignDocument,
			final Map<String, String> result, final String timeZoneId, final String clientIpAddress,
			final String userAgent) {
		// Setting document status as completed.
		idxESignDocument.setStatusCode(ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.toUpperCase());
		idxESignDocument.setStatusName(ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED);

		// Creating document signed history for all signers.
		for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
			if (ESignConstants.SIGNER_ACTION_NEED_SIGN.equals(idxESignSigner.getSignerActions())) {
				createESignatureHistory(firmId, idxESignDocument, idxESignSigner, AppConstants.ESIGN_SIGNED,
						AppConstants.ESIGN_DESC_SIGN, clientIpAddress, userAgent, null);

				idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED.toUpperCase());
			}
		}

		// To generate complted pdf with Audit trail
//		generateCompletedPDF(idxESignDocument, result, TimeZone.getTimeZone(timeZoneId));
		final String pdfBase = AppConstants.BASE64_PREFIX_PDF
				+ Base64.encodeBase64String(Base64.decodeBase64(result.get(AppConstants.BYTES_CONTENT)));
		final IdxESignDocRevisions idxDocRevSigner = saveESignDocRevision(firmId,
				ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), idxESignDocument.geteSignDocumentId().toString(),
				pdfBase);
		saveToBlockChain(idxESignDocument.getFirmId(), idxDocRevSigner.getId(),
				idxESignDocument.getSigners().get(0).getObjectRefName(), result.get(AppConstants.FILE_PATH));

		deleteFileIfExists(firmId, result.get(AppConstants.FILE_PATH));

		updateESignDocument(firmId, idxESignDocument);

		// Updating Associated Object (isESignCompleted) and Uploading the Signed document in Documents Tab.
		final IdxObject idxAssociatedObject = idxESignDocument.getAssociatedObject();
		if (idxAssociatedObject != null
				&& !ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxAssociatedObject.getObjectId())) {
			updateAssociateObject(firmId, idxAssociatedObject.getObjectId(), idxAssociatedObject.getObjectRefId(), null,
					null, true, null);
			uploadDocumentInDocumentTab(idxESignDocument, pdfBase);

			// Trigger ESA for completed document
			triggerESA(firmId, idxESignDocument, idxAssociatedObject.getObjectId(),
					idxAssociatedObject.getObjectRefId());
		}

		// Sending signed Document to signer and document owner.
		final String documentUrl = getDocumentRedirectionURL(firmId, idxESignDocument.geteSignDocumentId(), null, null, null);
		byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, TimeZone.getTimeZone(timeZoneId));
		final String[] attachments = getAttachmentsForEmail(idxESignDocument, pdfBase, auditTrailContent);

		notifyDocumentCompletion(firmId, idxESignDocument, null, documentUrl, attachments);
	}

	/**
	 * THis method used to update the e-sign document based on version.
	 *
	 * @param firmId
	 * @param documentId
	 * @param signerId
	 * @param eSignAttributes
	 * @param timeZoneId
	 * @param clientIpAddress
	 * @param userAgent
	 * @param addSignInAssoObj
	 * @return
	 */
	public Map<String, Object> updateESignDocumentByVersion(final Long firmId, final Long documentId,
			final Long signerId, final String eSignAttributes, final String timeZoneId, final String clientIpAddress,
			final String userAgent, final boolean addSignInAssoObj) {
		Map<String, Object> signerDetails = new HashMap<>();
		try {
			IdxESignDocument idxESignDocument = getESignDocumentBySignerId(firmId, documentId, signerId);

			saveESignDocumentAttributes(idxESignDocument, eSignAttributes, signerId, clientIpAddress, userAgent,
					addSignInAssoObj);

			// prepare signedDocument with eSignAttributes.
			final Map<String, String> result = prepareSignedPDFInBytes(idxESignDocument);

			signerDetails.put(ESignConstants.DOC_FILE_PATH_SIGNER, result.get(AppConstants.FILE_PATH));

			signerDetails.put(ESignConstants.DOC_BASE_SIGNER, AppConstants.BASE64_PREFIX_PDF
					+ Base64.encodeBase64String(Base64.decodeBase64(result.get(AppConstants.BYTES_CONTENT))));

			// Getting the current ESignSigner and setting status as signed.
			for (int i = 0; i < idxESignDocument.getSigners().size(); i++) {
				final IdxESignSigner idxESignSigner = idxESignDocument.getSigners().get(i);
				if (idxESignSigner.geteSignSignerId().equals(signerId)) {
					idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED.toUpperCase());
					signerDetails.put("currentSigner", idxESignSigner);
					break;
				}
			}

			// if SequentialOrder enabled, send mail to next signer.
			if (Boolean.TRUE.equals(idxESignDocument.getIsSequential())
					&& AppUtil.checkListisNullOrNot(idxESignDocument.getSignerForESign())) {
				final IdxESignSigner eSignSigner = idxESignDocument.getSignerForESign().get(0);

				eSignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SENT.toUpperCase());

				signerDetails.put("nextSigner", eSignSigner);

			}

			updateESignDocStatus(idxESignDocument, signerId);

			// Generation PDF with Audit trail for completed document.
//			if (ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.equalsIgnoreCase(idxESignDocument.getStatusName())) {
//				generateCompletedPDF(idxESignDocument, result, TimeZone.getTimeZone(timeZoneId));
//				signerDetails.put(ESignConstants.DOC_FILE_PATH_COMPLETED, result.get(AppConstants.FILE_PATH));
//				signerDetails.put(ESignConstants.DOC_BASE_COMPLETED, AppConstants.BASE64_PREFIX_PDF
//						+ Base64.encodeBase64String(Base64.decodeBase64(result.get(AppConstants.BYTES_CONTENT))));
//			}

			idxESignDocument = ElasticSearchDAO.getInstance().indexDocument(firmId, IdxESignDocument.class,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, idxESignDocument.geteSignDocumentId(),
					AppUtil.convertToJson(idxESignDocument), idxESignDocument.getVersion());

			signerDetails.put("idxESignDocument", idxESignDocument);

		} catch (final VersionConflictEngineException exception) {
			logger.error(firmId, "ESignatureService:signESignDocument:version conflict", exception);
			signerDetails = updateESignDocumentByVersion(firmId, documentId, signerId, eSignAttributes, timeZoneId,
					clientIpAddress, userAgent, false);
		} catch (final Exception exception) {
			logger.error(firmId, "ESignatureService:signESignDocument:exception:", exception);
		}
		return signerDetails;
	}

	/**
	 * This method used to sign SEND_SIGN and SIGN_OWN Type Document.
	 *
	 * @param firmId
	 * @param documentId
	 * @param signerId
	 * @param eSignAttributes
	 * @param timeZoneId
	 * @param clientIpAddress
	 * @param userAgent
	 * @param addSignInAssoObj
	 *
	 */
	public void signESignDocument(final Long firmId, final Long documentId, final Long signerId,
			final String eSignAttributes, final String timeZoneId, final String clientIpAddress, final String userAgent,
			final boolean addSignInAssoObj) {

		final String[] includes = {};
		final String[] excludes = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
				ESignConstants.ESIGN_SIGNED_DOCUMENT };

		final IdxESignDocument eSignDocument = getDocument(firmId, documentId, includes, excludes);

		final IdxESignSigner signer = eSignDocument.getESignSignerBySignerId(signerId);

		// creating a signed history for idxESignSigner.
		final IdxEsignatureHistory idxEsignHistory = createESignatureHistory(firmId, eSignDocument, signer,
				AppConstants.ESIGN_SIGNED, AppConstants.ESIGN_DESC_SIGN, clientIpAddress, userAgent, null);

		// Action Center - Signed
		if (!eSignDocument.getSenderDetails().getEmailId().equals(signer.getPrimaryEmailId())
				&& ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(eSignDocument.getAssociatedObject().getObjectId())) {
			ESignEventActionService.getInstance().produceActionQueue(firmId, eSignDocument, signer, null,
					ESignConstants.AE_CODE_SIGNED);
		}

		final Map<String, Object> updatedDocResult = updateESignDocumentByVersion(firmId, documentId, signerId,
				eSignAttributes, timeZoneId, clientIpAddress, userAgent, addSignInAssoObj);

		final IdxESignDocument idxESignDocument = (IdxESignDocument) updatedDocResult.get("idxESignDocument");
		final IdxObject idxAssociatedObject = idxESignDocument.getAssociatedObject();
		final Boolean isResend = idxESignDocument.isResend();

		final IdxESignSigner currentSigner = (IdxESignSigner) updatedDocResult.get("currentSigner");

		// If it's Sequential
		final IdxESignSigner nextSigner = (IdxESignSigner) updatedDocResult.get("nextSigner");

		if (nextSigner != null) {
			// Prepare document redirection url
			final String documentUrl = getDocumentRedirectionURL(firmId, idxESignDocument.geteSignDocumentId(), null,
					null, null);

			requestSignBySigner(firmId, idxESignDocument, nextSigner, documentUrl, isResend);

			final String historyStatus = Boolean.TRUE.equals(isResend) ? AppConstants.ESIGN_RESENT : AppConstants.ESIGN_SENT;
			final String historyStatusDesc = Boolean.TRUE.equals(isResend) ? AppConstants.ESIGN_DESC_RESENT : AppConstants.ESIGN_DESC_SENT;
			createESignatureHistory(firmId, idxESignDocument, nextSigner, historyStatus,
					historyStatusDesc, clientIpAddress, userAgent, null);
		}

		// Saving Hash Code of Signed document in Block Chain - Signer level.
		final String filePath = (String) updatedDocResult.get(ESignConstants.DOC_FILE_PATH_SIGNER);
		if (filePath != null) {
			final IdxESignDocRevisions idxDocRevSigner = saveESignDocRevision(firmId,
					ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString(), idxEsignHistory.getHistoryId(),
					updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString());

			saveToBlockChain(idxESignDocument.getFirmId(), idxDocRevSigner.getId(), currentSigner.getObjectRefName(),
					filePath);
		}

		// Saving Hash Code of completed document in Block Chain.
		if (ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.equalsIgnoreCase(idxESignDocument.getStatusName())) {
			final IdxESignDocRevisions idxDocRevCompleted = saveESignDocRevision(firmId,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), idxESignDocument.geteSignDocumentId().toString(),
					updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString());

			saveToBlockChain(idxESignDocument.getFirmId(), idxDocRevCompleted.getId(), currentSigner.getObjectRefName(),
					filePath);
		}

		// Deleting the File
		if(filePath != null) {
			deleteFileIfExists(firmId, filePath);
		}

		// Notifying the Signer and Owner of the Document.
		final String documentUrl = getDocumentRedirectionURL(firmId, idxESignDocument.geteSignDocumentId(), null, null, null);

		final String[] attachments = getAttachmentsForEmail(idxESignDocument, 
				updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString(), null);

		notifyToSigner(firmId, idxESignDocument, currentSigner, documentUrl, attachments);
		notifyToOwner(firmId, idxESignDocument, currentSigner, documentUrl, attachments);

		// Once the document is completed, sending the completed document to E-Sign participants
		if (ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.equalsIgnoreCase(idxESignDocument.getStatusName())) {
			final TimeZone userTimeZone = TimeZone.getTimeZone(timeZoneId);

			if (idxESignDocument.getSignerCount() > 1) {
				// Sending Document Notification for multi signer scenario
				byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, userTimeZone);

				final String[] compFileatt = getAttachmentsForEmail(idxESignDocument,
						updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString(), auditTrailContent);
				notifyDocumentCompletion(firmId, idxESignDocument, null, documentUrl, compFileatt);
			} else if (idxESignDocument.getSignerCount() == 1 && !idxESignDocument.getCCList().isEmpty()) {
				// Sending document completed notification for single Signer scenario
				byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, userTimeZone);

				final String[] compFileatt = getAttachmentsForEmail(idxESignDocument,
						updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString(), auditTrailContent);
				notifyDocumentCompletion(firmId, idxESignDocument, idxESignDocument.getCCWithoutOwner(), documentUrl, compFileatt);
			}

			// Upload document in Documents tab once all signers signed the document for E-Sign.
			if (!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
				uploadDocumentInDocumentTab(idxESignDocument, updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString());
			}

			// Action Center - Completed
			// For maintaining the completed action center entry in last Updated
			try {
				AppExceptionService.logThreadSleep(firmId, null, null, AppConstants.DELAY.intValue());
				Thread.sleep(AppConstants.DELAY);
			} catch(final Exception exception) {
				logger.error(firmId, "ESignatureService:signESignDocument:exception:", exception);
			}

			if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
				ESignEventActionService.getInstance().produceActionQueue(firmId, idxESignDocument, currentSigner, null,
						ESignConstants.AE_CODE_COMPLETED);
			}

			if (idxAssociatedObject != null
					&& !ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxAssociatedObject.getObjectId())) {
				// Trigger ESA for completed document
				triggerESA(firmId, idxESignDocument, idxAssociatedObject.getObjectId(),
						idxAssociatedObject.getObjectRefId());
			}

			// Callback API
			if (ESignConstants.callbackEnabledFirms.contains(firmId)) {
				sendDataToCustomerServer(firmId, idxESignDocument, currentSigner,
						updatedDocResult.get(ESignConstants.DOC_BASE_SIGNER).toString());
			}
		}
	}

	/**
	 * This method used to send the Document for E-Sign by Sign.co.
	 *
	 * @param firmId
	 * @param userId
	 * @param userData
	 * @param dateFormat
	 * @param request
	 * @throws ParseException
	 */
	public Map<String, Object> createESignByApptivo(final Long firmId, final Long userId, final UserData userData,
			final String dateFormat, final HttpServletRequest request) {
		final Long docObjectId = AppHttpUtil.getLongParameter(request, "docObjectId", null);
		final Long docObjectRefId = AppHttpUtil.getLongParameter(request, "docObjectRefId", null);
		final String signerData = AppHttpUtil.getStringParameter(request, "signersData", null);
		final String pageSize = AppHttpUtil.getStringParameter(request, "pageSize",
				ESignConstants.DOCUMENT_PAPER_SIZE_A4);
		final String signType = AppHttpUtil.getStringParameter(request, "signType", null);
		final String eSignHistory = AppHttpUtil.getStringParameter(request, "eSignHistory", null);
		final Boolean isSequential = AppHttpUtil.getBooleanParameter(request, ESignConstants.IS_SEQUENTIAL, false);
		final Boolean isLandscape = AppHttpUtil.getBooleanParameter(request, ESignConstants.IS_LANDSCAPE, false);
		final String customSubject = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_SUBJECT, null);
		final String customMessage = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_MESSAGE, null);
		final String fa = AppHttpUtil.getStringParameter(request, ESignConstants.FA, null);
		final Boolean isResend = AppHttpUtil.getBooleanParameter(request, ESignConstants.IS_RESEND, false);
		final String brandId = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_BRAND_ID, null);

		final Map<String, Object> result = new HashMap<>();

		// Validating the document limit based on the Credits/Sign.co Approach.
		final Map<String, String> validateESignResult = validateESignDocLimit(firmId);
		if(validateESignResult.get(AppConstants.RESULT_STATUS) != null) {
			result.putAll(validateESignResult);
			return result;
		}

		try {
		// Getting PDF Bytes content and file name of document.
		final Map<String, Object> objectPDFMap = getObjectPDF(firmId, userId, docObjectId,
				docObjectRefId, userData, request, dateFormat);
		final String fileName = (String) objectPDFMap.get(ESignConstants.FILE_NAME);
		final byte[] objectPdf = (byte[]) objectPDFMap.get("content");
		logger.info(firmId, "ESignatureService:createESignByApptivo:fileName:" + fileName);

		// Preparing the eSignLabels.
		final Map<String, JSONObject> eSignAttributes = getESignAttributesByPdfTemplate(firmId, docObjectId,
				docObjectRefId);
		logger.info(firmId, "ESignatureService:createESignByApptivo:eSignAttributes:size:" + eSignAttributes.size());

		// Creating associatedObject details for IdxESignDocument.
		final IdxObject associatedObject = new IdxObject();
		associatedObject.setObjectId(docObjectId);
		associatedObject.setObjectRefId(docObjectRefId);
		associatedObject.setType(pageSize);
		associatedObject.setLandscape(isLandscape);

		// Preparing IdxESignDocument object.
		final IdxESignDocument eSignDocument = createESignDocumentWithPDFBytes(userData, fileName, objectPdf,
				eSignAttributes, signerData, associatedObject, signType, isSequential, fa, isResend, brandId);

		// Preparing document Url
		final String documentUrl = getDocumentRedirectionURL(firmId, eSignDocument.geteSignDocumentId(),
				userData.getTimeZone().getID(), docObjectId, dateFormat);

		// SIGN_OWN and SEND_SIGN - Creating ESignHistories and sending ESignDocument for Signers.
		if (!ESignConstants.IN_PERSON_SIGN.equals(eSignDocument.getSignType())) {
			// Updating Associated object details.
			updateAssociateObject(firmId, docObjectId, docObjectRefId, null, null, true, isResend);

			// Setting custom subject and custom message in idxESignDocument
			if (customSubject != null && customMessage != null) {
				eSignDocument.setCustomSubject(customSubject);
				eSignDocument.setCustomMessage(customMessage);
			}

			// Requesting sign / Resending document to signers through mail.
			requestSignForESign(firmId, eSignDocument, documentUrl, isResend);
			if (Boolean.TRUE.equals(isResend)) {
				// Invalidate the old docs
				invalidateExistingEsignDoc(firmId, docObjectId, docObjectRefId, userData);
			}

			// Creating e-sign sent History for signers.
			final JSONParser parser = new JSONParser();
			final JSONArray eSignHistoryArray = (JSONArray) parser.parse(eSignHistory);
			final String userAgent = AppHttpUtil.getUserAgent(request);
			for (int eSignHistoryIndex = 0; eSignHistoryIndex < eSignHistoryArray.size(); eSignHistoryIndex++) {
				final JSONObject eSignHistoryObject = (JSONObject) eSignHistoryArray.get(eSignHistoryIndex);
				final IdxEsignatureHistory idxEsignatureHistory = AppUtil.convertFromJson(IdxEsignatureHistory.class,
						eSignHistoryObject.toJSONString());
				idxEsignatureHistory.setIpAddress(AppHttpUtil.getClientIPAddress(request));
				idxEsignatureHistory.setFirmId(firmId);
				saveUserAgent(idxEsignatureHistory, userAgent);

				// setting history status based onthe isResend
				final String eSignHistStatus = Boolean.TRUE.equals(isResend) ? AppConstants.ESIGN_RESENT : AppConstants.ESIGN_SENT;
				createSignHistoryForSent(firmId, userData, idxEsignatureHistory.getEmailId(),
						eSignDocument.geteSignDocumentId().toString(), idxEsignatureHistory,
						eSignHistStatus, eSignDocument.getDocumentName());

				// Setting signer status sent for signers
				eSignDocument.getESignSignerByEmailId(idxEsignatureHistory.getEmailId())
						.setSignerStatus(ESignConstants.SIGNER_STATUS_SENT.toUpperCase());

				if(Boolean.TRUE.equals(eSignDocument.getIsSequential())) {
					break;
				}
			}

			if(Boolean.TRUE.equals(eSignDocument.getIsSequential())) {
				eSignDocument.getSigners().get(0).setSignerStatus(ESignConstants.SIGNER_STATUS_SENT.toUpperCase());
			}
			
			if (ObjectConstants.OBJECT_ESTIMATE.equals(docObjectId)
					|| ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(docObjectId)
					|| ObjectConstants.OBJECT_CASE.equals(docObjectId)
					|| docObjectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
				final IdxConfiguration idxConfiguration = AppSettingsDAO.getInstance().getConfigData(firmId, docObjectId);
				executeESAUpdateAttributeAction(firmId, userId, userData, idxConfiguration, docObjectId, docObjectRefId, request, AppConstants.ESIGN_SENT);
			}

		} else {
			// Updating the signer status for In-Person Sign
			for(IdxESignSigner idxESigner : eSignDocument.getSigners()) {
				idxESigner.setSignerStatus(ESignConstants.SIGNER_STATUS_VIEWED.toUpperCase());
			}

			// IN_PERSON_SIGN - Preparing document redirection URL for esignDocument.
			result.put(AppConstants.REDIRECT_URI, documentUrl);
		}

		updateESignDocument(firmId, eSignDocument);

		// ESign - Billing
		// *  Handling Billing for ESign 
		// * Restricting Billing for Resend Documents 
		if (!Boolean.TRUE.equals(isResend)) {
			updateESignCreditUsage(firmId, userId, docObjectId,
					eSignDocument.getAssociatedObject().getSourceRefId(), docObjectRefId, userData);
		}
		
		// Updating latest document sent date in Apptivo Customer
		final SignDocSentDateThread pageThread = new SignDocSentDateThread(firmId);
		final Thread thread = new Thread(pageThread);
		thread.start();

		eSignDocument.setDocumentData("");
		eSignDocument.setDocumentPages(null);
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		result.put(ESignConstants.RESPONSE_PARAM_ESIGNDOCUMENT, AppUtil.convertToJson(eSignDocument));
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:sendDocumetForESign:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		}
		return result;
	}

	/**
	 * This method used to validate the sign own signers while upload from template - more than one role scenario
	 *
	 * @param idxESignDocument
	 */
	public void validateSignOwnSigners(final IdxESignDocument idxESignDocument) {
		final List<IdxESignSigner> idxESigners = new ArrayList<>();
		for (IdxESignSigner signer : idxESignDocument.getSigners()) {
			if (AppUtil.checkStringNullOrNot(signer.getPrimaryEmailId())) {
				idxESigners.add(signer);
				break;
			}
		}

		if (AppUtil.checkListisNullOrNot(idxESigners)) {
			idxESignDocument.setSigners(idxESigners);
		}
	}

	/**
	 * This method used to prepare the List of ESign Attributes from eSignAttributes. 
	 *
	 * @param idxESignDocument
	 * @param eSignAttributes
	 * @param isSignOwn
	 * @param creationDate
	 * @param clientIpAddress
	 * @param userAgent
	 * @throws ParseException
	 * @throws UnsupportedEncodingException
	 */
	public void prepareESignAttributes(final IdxESignDocument idxESignDocument, final String eSignAttributes,
			final String isSignOwn, final String creationDate, final String clientIpAddress, final String userAgent)
			throws ParseException, UnsupportedEncodingException {
		final JSONParser parser = new JSONParser();
		final JSONArray esignattribute = (JSONArray) parser.parse(eSignAttributes);
		for (int eSignattributeIndex = 0; eSignattributeIndex < esignattribute.size(); eSignattributeIndex++) {
			final JSONObject idxESignAttr = (JSONObject) esignattribute.get(eSignattributeIndex);
			final IdxEsignAttribute idxEsignAttribute = AppUtil.convertFromJson(IdxEsignAttribute.class,
					idxESignAttr.toJSONString());
			if (AppConstants.BOOLEAN_TRUE.equals(isSignOwn)) {
				idxEsignAttribute.seteSignSigner(idxESignDocument.getSigners().get(0));
				idxEsignAttribute.setDateSigned(creationDate);
				idxEsignAttribute.setCreationDate(creationDate);
				idxEsignAttribute.setNodeName(System.getProperty(AppConstants.NODE_NAME));
				idxEsignAttribute.setIpAddress(clientIpAddress);
				idxEsignAttribute.setUserAgent(userAgent);
			}
			if (AppUtil.checkStringNullOrNot(idxEsignAttribute.getValue())) {
				final String decodedValue = URLDecoder.decode(idxEsignAttribute.getValue(), AppConstants.URI_ENCODER_FORMAT);
				idxEsignAttribute.setValue(decodedValue);
				if ((!ESignConstants.TYPE_TEXT.equalsIgnoreCase(idxEsignAttribute.getSignatureType())
						&& !ESignConstants.TYPE_DATE.equalsIgnoreCase(idxEsignAttribute.getSignatureType()))
						|| ESignConstants.SIGN_OWN.equalsIgnoreCase(idxESignDocument.getSignType())) {
					idxEsignAttribute.setIsCompleted(true);
				}
			}

			final Long pageNumber = idxEsignAttribute.getPageNumber() - 1;
			final IdxEsignDocumentPage idxEsignDocumentPage = idxESignDocument.getDocumentPages()
					.get(pageNumber.intValue());
			idxEsignDocumentPage.geteSignAttributes().add(idxEsignAttribute);
		}
	}
	
	/**
	 * Set Document Status based on sign Type.
	 *
	 * For Send-Sign, In-Person Sign
	 * If current logged in used is a signer - Set status as NEW.
	 * If not - set status as SENT.
	 *
	 * For Sign-Own,
	 * By default we're setting as DRAFT.
	 *
	 * @param idxESignDocument
	 */
	public void setDocumentStatusBySignType(final IdxESignDocument idxESignDocument,final boolean isCompleted) {
		final Long firmId = idxESignDocument.getFirmId();
		String documentStatus = isCompleted ? ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED
				: ESignConstants.ESIGN_DOCUMENT_STATUS_NEW;
		boolean isSignerAvailable = false;

		if (idxESignDocument.getSignType().equals(ESignConstants.SEND_SIGN)
				|| idxESignDocument.getSignType().equals(ESignConstants.ESIGN)
				|| idxESignDocument.getSignType().equals(ESignConstants.IN_PERSON_SIGN)) {
			for (IdxESignSigner signer : idxESignDocument.getSigners()) {
				if (idxESignDocument.getSenderDetails().getEmailId().equals(signer.getPrimaryEmailId())) {
					isSignerAvailable = true;
					break;
				}
			}
			if(!isSignerAvailable) {
				documentStatus = isCompleted ? ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED
						: ESignConstants.ESIGN_DOCUMENT_STATUS_SENT;
			}
		} else if(idxESignDocument.getSignType().equals(ESignConstants.SIGN_OWN)) {
			documentStatus = isCompleted ? ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED
					: ESignConstants.ESIGN_DOCUMENT_STATUS_DRAFT;
		} else {
			logger.info(firmId, "ESignatureService:setDocumentStatusBySignType:in else block");

		}

		logger.info(firmId, "ESignatureService:setDocumentStatusBySignType:documentStatus:" + documentStatus);

		idxESignDocument.setStatusCode(documentStatus.toUpperCase());
		idxESignDocument.setStatusName(documentStatus);
	}
	
	/**
	 * This method used to get the document based on signerId with include and exclude fields.
	 * 
	 * @param firmId
	 * @param documentId
	 * @param includeFields
	 * @param excludeFields
	 * @return
	 */
	public IdxESignDocument getDocument(final Long firmId, final Long documentId, final String[] includeFields,
			final String[] excludeFields) {
		IdxESignDocument idxESignDocument = null;
		final GetResponse docResponse = ElasticSearchDAO.getInstance().getDocumentFields(firmId,
				ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId, includeFields, excludeFields);
		if (docResponse != null) {
			idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class, docResponse.getSourceAsString());
		}
		return idxESignDocument;
	}

	/**
	 * This method used to get the document based on include and exclude fields.
	 *
	 * @param firmId
	 * @param clazz
	 * @param objectId
	 * @param id
	 * @param includeFields
	 * @param excludeFields
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public <T> T getDocument (final Long firmId, final Class<T> clazz, final Long objectId, final Long id,
			final String[] includeFields, final String[] excludeFields) {
		Object object = null;
		final GetResponse docResponse = ElasticSearchDAO.getInstance().getDocumentFields(firmId, objectId, id,
				includeFields, excludeFields);
		if (docResponse != null) {
			object = AppUtil.convertFromJson(clazz, docResponse.getSourceAsString());
		}
		return (T) object;
	}

	/**
	 * This method used to check the estimate is valid or not - Expired or Voided
	 *
	 * @param firmId
	 * @param id
	 * @return
	 */
	public boolean isValidEstimate(final Long firmId, final Long id) {
		boolean isValidEstimate = true;

		final String[] includeFields = { AppConstants.STR_STATUS_CODE };
		final String[] excludeFields = {};
		final IdxEstimate idxEstimate = getDocument(firmId, IdxEstimate.class, ObjectConstants.OBJECT_ESTIMATE, id,
				includeFields, excludeFields);
		if (idxEstimate != null && (AppConstants.ESTIMATE_STATUS_REJECTED.equals(idxEstimate.getStatusCode())
				|| AppConstants.ESTIMATE_STATUS_VOID.equals(idxEstimate.getStatusCode()))) {
			isValidEstimate = false;
		}

		return isValidEstimate;
	}

	/**
	 * This method is used to get the document for side panel.
	 * 
	 * @param firmId
	 * @param documentId
	 * @param statusName
	 * @param userData
	 *
	 * @return
	 */
	public IdxESignDocument getDocumentbyId(final Long firmId, final Long documentId, final String statusName,
			final UserData userData) {
		IdxESignDocument idxESignDocument = null;
		IdxEsignDocumentPage idxEsignDocumentPage = null;

		final String[] include = { AppConstants.FIRM_ID, ESignConstants.ESIGN_DOCUMENT_ID, ESignConstants.DOC_NAME,
				ESignConstants.STATUS_NAME, ESignConstants.STATUS_CODE, AppConstants.OBJECT_STATUS,
				ESignConstants.SIGN_TYPE, ESignConstants.IS_SENT, ESignConstants.SIGNERS, AppConstants.CREATED_BY_NAME,
				ESignConstants.EXP_DATE, AppConstants.CREATION_DATE, ESignConstants.TOTAL_PAGES,
				ESignConstants.IS_TEMPLATE, ESignConstants.ASSOCIATED_OBJECT, ESignConstants.FA, ESignConstants.MFD,
				ESignConstants.REASSIGN, AppConstants.CREATED_BY, ESignConstants.SENDER_DETAILS, "", "", "" };
		final String[] exclude = {};

		// Including the pdf base value document data/ Signed data from document prepareLegalDisclosurebased on the document status.
		if (ESignConstants.ESIGN_DOCUMENT_STATUS_NEW.equalsIgnoreCase(statusName)
				|| ESignConstants.ESIGN_DOCUMENT_STATUS_SENT.equalsIgnoreCase(statusName)) {
			include[include.length - 2] = ESignConstants.ESIGN_DOCUMENT_DATA;
		} else if (ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING.equalsIgnoreCase(statusName)
				|| ESignConstants.ESIGN_DOCUMENT_STATUS_COMPLETED.equalsIgnoreCase(statusName)) {
			include[include.length -2] = ESignConstants.ESIGN_SIGNED_DOCUMENT;
		} else if(ESignConstants.ESIGN_DOCUMENT_STATUS_DRAFT.equalsIgnoreCase(statusName)) {
			include[include.length -2] = ESignConstants.IS_SEQUENTIAL;
			include[include.length - 1] = ESignConstants.VC;
		} else {
			include[include.length - 3] = ESignConstants.VC;
			include[include.length - 2] = ESignConstants.ESIGN_DOCUMENT_DATA;
			include[include.length - 1] = ESignConstants.ESIGN_SIGNED_DOCUMENT;
		}

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString()).setSize(1)
				.setFetchSource(include, exclude);

		final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
		boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		boolQueryBuilder.must(QueryBuilders.termQuery(ESignConstants.ESIGN_DOCUMENT_ID, documentId));

		// To get the 0th index of document page alone in document.
		final InnerHitBuilder innerHitBuilder = new InnerHitBuilder(ESignConstants.ESIGN_DOCUMENT_PAGES);
		innerHitBuilder.setSize(1);
		final NestedQueryBuilder nestedQueryBuilder = QueryBuilders
				.nestedQuery(ESignConstants.ESIGN_DOCUMENT_PAGES, QueryBuilders.matchAllQuery(), ScoreMode.Total)
				.innerHit(innerHitBuilder);
		boolQueryBuilder.must(nestedQueryBuilder);

		builder.setQuery(boolQueryBuilder);

		logger.info(firmId, "ESignatureService:getDocumentbyId:builder:" + builder.toString());

		final SearchResponse hits = builder.execute().actionGet();
		for (SearchHit hit : hits.getHits()) {
			idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class, hit.getSourceAsString());
			idxESignDocument.formatDateValues(userData.getTimeZone(), userData.getDatePattern());

			// getting the inner hits of the document.
			final SearchHits innerHits = hit.getInnerHits().get(ESignConstants.ESIGN_DOCUMENT_PAGES);
			for (SearchHit innerhit : innerHits) {
				idxEsignDocumentPage = AppUtil.convertFromJson(IdxEsignDocumentPage.class,
						innerhit.getSourceAsString());
				idxESignDocument.getDocumentPages().add(idxEsignDocumentPage);
				if(Boolean.FALSE.equals(idxESignDocument.getIsSent())) {
					idxESignDocument.setDocumentData(null);
				}
			}

			// For Existing Templates - we're not getting the mfd details
			if(Boolean.TRUE.equals(idxESignDocument.getIsTemplate()) && !AppUtil.checkListisNullOrNot(idxESignDocument.getMfd())) {
				// Multi-file Details
				final IdxObject mfd = new IdxObject();
				mfd.setId(0L);
				mfd.setName(idxESignDocument.getDocumentName());
				mfd.setSrc(idxESignDocument.getSource());
				mfd.setExt(idxESignDocument.getFileExt());
				mfd.setPc(idxESignDocument.getTotalPages());
				idxESignDocument.getMfd().add(mfd);
			}
		}
		return idxESignDocument;
	}

	/**
	 * This method used to verify hash value of signed document.
	 *
	 * @param firmId
	 * @param documentId
	 * @param objId
	 * @param objRefId
	 * @return
	 */
	public Map<String, String> verifyHashValues(final Long firmId, final Long documentId, Long objId,
			String objRefId) {
		final Map<String, String> result = new HashMap<>();

		try {
			IdxESignDocRevisions idxDocRev = getESignDocReviByObjRefId(firmId, objId, objRefId);

			if (idxDocRev == null && ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objId)) {
				final IdxEsignatureHistory idxEsignHist = getLatestESignHistoryByDocId(firmId, documentId);
				if (idxEsignHist != null) {
					idxDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGNATURE_HISTORY,
							idxEsignHist.getHistoryId());
					objId = ObjectConstants.OBJECT_ESIGNATURE_HISTORY;
					objRefId = idxEsignHist.getHistoryId();
				}
			}

			if (idxDocRev == null && ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objId)) {
				idxDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, objRefId + "_o");
				objId = ObjectConstants.OBJECT_ESIGN_DOCUMENT;
				objRefId += "_o";
			}

			if (idxDocRev == null) {
				final String[] include = {};
				final String[] exclude = { ESignConstants.ESIGN_DOCUMENT_PAGES };

				final IdxESignDocument idxESignDocument = ESignatureService.getInstance().getDocument(firmId,
						documentId, include, exclude);
				final String documentData = idxESignDocument.getSignedDocument() != null
						? idxESignDocument.getSignedDocument()
						: idxESignDocument.getDocumentData();
				final boolean hashValueVerification = verifyHashValue(idxESignDocument,
						Base64.decodeBase64(documentData.split(",")[1]), null);
				result.put(AppConstants.RESULT_STATUS, hashValueVerification ? AppConstants.RESULT_STATUS_SUCCESS
						: AppConstants.RESULT_STATUS_FAILURE);
				result.put(AppConstants.STR_OBJECT_ID, objId.toString());
				result.put(AppConstants.STR_OBJECT_REF_ID, objRefId);
			} else {
				final boolean hashValueVerification = verifyHashValue(new IdxESignDocument(firmId),
						Base64.decodeBase64(idxDocRev.getDocData().split(",")[1]), idxDocRev.getId());
				result.put(AppConstants.RESULT_STATUS, hashValueVerification ? AppConstants.RESULT_STATUS_SUCCESS : AppConstants.RESULT_STATUS_FAILURE);
				result.put("isRev", AppConstants.YES);
				result.put(AppConstants.STR_OBJECT_ID, objId.toString());
				result.put(AppConstants.STR_OBJECT_REF_ID, objRefId);
			}
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:verifyHashValues:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		}
		return result;
	}
	
	/**
	 * This method used to download the Signed PDF or document Page.
	 * @param firmId
	 * @param documentId
	 * @param request
	 * @param response
	 */
	public void printPDF(final HttpServletRequest request, final HttpServletResponse response, final Long firmId,
			final Long documentId, final String isRev, final Long objId, final String objRefId) {

		if (AppConstants.YES.equals(isRev)) {
			final IdxESignDocRevisions idxDocRev = getESignDocReviByObjRefId(firmId, objId, objRefId);

			final String[] include = { ESignConstants.ASSOCIATED_OBJECT };
			final String[] exclude = {};

			final IdxESignDocument idxESignDocument = ESignatureService.getInstance().getDocument(firmId, documentId,
					include, exclude);
			final String objRefName = idxESignDocument.getAssociatedObject().getObjectRefName();
			final String documentName = objRefName.indexOf(AppConstants.PDF_FILE_EXTENSION) > -1 ? objRefName
					: objRefName + AppConstants.PDF_FILE_EXTENSION;

			final Cookie downloadTokenCookie = new Cookie(AppConstants.COOKIE_NAME,
					String.valueOf(new Date().getTime()));
			// Cookies should be "secure
			downloadTokenCookie.setSecure(true);
			downloadTokenCookie.setPath("/");
			AppHttpUtil.addSecureHttpOnlyCookie(response, downloadTokenCookie, request);
			try {
				AppHttpUtil.writeResponse(response, request, AppConstants.CONTENTTYPE_PDF,
						documentName, Base64.decodeBase64(idxDocRev.getDocData().split(",")[1]));
			} catch (Exception exception) {
				logger.error(firmId, "ESignatureService:printPDF:exception:", exception);

			}
		} else {
			final String[] include = {};
			final String[] exclude = {ESignConstants.ESIGN_DOCUMENT_PAGES};
			
			final IdxESignDocument idxESignDocument = ESignatureService.getInstance().getDocument(firmId, documentId,
					include, exclude);
			final String objRefName = idxESignDocument.getAssociatedObject().getObjectRefName();
			final String documentName = objRefName.indexOf(AppConstants.PDF_FILE_EXTENSION) > -1 ? objRefName
					: objRefName + AppConstants.PDF_FILE_EXTENSION;

			final Cookie downloadTokenCookie = new Cookie(AppConstants.COOKIE_NAME,
					String.valueOf(new Date().getTime()));
			// Cookies should be "secure
			downloadTokenCookie.setSecure(true);
			downloadTokenCookie.setPath("/");
			AppHttpUtil.addSecureHttpOnlyCookie(response, downloadTokenCookie, request);
			try {
				if (idxESignDocument.getSignedDocument() != null) {
					AppHttpUtil.writeResponse(response, request, AppConstants.CONTENTTYPE_PDF, documentName,
							Base64.decodeBase64(idxESignDocument.getSignedDocument().split(",")[1]));
				} else if (idxESignDocument.getDocumentData() != null) {
					AppHttpUtil.writeResponse(response, request, AppConstants.CONTENTTYPE_PDF, documentName,
							Base64.decodeBase64(idxESignDocument.getDocumentData().split(",")[1]));
				} else {
					logger.info(firmId, "ESignatureService:printPDF:in else block");
				}

			} catch (final IOException exception) {
				logger.error("ESignatureService:printESignPdf:exception:", exception);
			}
		}
	}

	/**
	 * This method used to download the Audit
	 *
	 * @param firmId
	 * @param documentId
	 * @param idxESignDocument
	 * @param timeZone
	 * @param request
	 * @param response
	 * @return
	 */
	public String downloadAudit(final Long firmId, final Long documentId, IdxESignDocument idxESignDocument,
			final TimeZone timeZone, final HttpServletRequest request, final HttpServletResponse response) {
		if (idxESignDocument == null) {
			final String[] include = {};
			final String[] exclude = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
					ESignConstants.ESIGN_SIGNED_DOCUMENT };

			idxESignDocument = getDocument(firmId, documentId, include, exclude);
		}
		byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, timeZone);

		final String objRefName = idxESignDocument.getAssociatedObject().getObjectRefName();
		final String documentName = objRefName + "_audit" + AppConstants.PDF_FILE_EXTENSION;

		final Cookie downloadTokenCookie = new Cookie(AppConstants.COOKIE_NAME, String.valueOf(new Date().getTime()));
		// Cookies should be "secure
		downloadTokenCookie.setSecure(true);
		downloadTokenCookie.setPath("/");
		AppHttpUtil.addSecureHttpOnlyCookie(response, downloadTokenCookie, request);
		try {
			AppHttpUtil.writeResponse(response, request, AppConstants.CONTENTTYPE_PDF, documentName, 
					auditTrailContent);
			return AppConstants.RESULT_STATUS_SUCCESS;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:downloadAudit:exception:", exception);
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to index the Change Request.
	 * 
	 * @param idxDocChangeRequest
	 */
	public void indexDocChangeRequest(final IdxDocChangeRequest idxDocChangeRequest) {
		final Long firmId = idxDocChangeRequest.getFirmId();
		final IndexResponse indexResponse = ElasticSearchDAO.getInstance().indexDocument(firmId,
				ObjectConstants.OBJECT_DOC_CHANGE_REQUEST, AppUtil.convertToJson(idxDocChangeRequest), true);
		logger.info(firmId, "ESignatureService:indexDocChangeRequest:indexResponse:" + indexResponse);

		if (indexResponse != null && indexResponse.getId() != null) {
			idxDocChangeRequest.setChangeRequestId(indexResponse.getId());
		}
	}

	/**
	 * This method used to get all comments.
	 * 
	 * @param firmId
	 * @param documentId
	 * @param timeZoneId
	 * @return
	 */
	public List<IdxDocChangeRequest> getAllComments(final Long firmId, final Long documentId, final String timeZoneId) {

		final List<IdxDocChangeRequest> documents = new ArrayList<>();

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery(ESignConstants.REQUEST_PARAM_DOCUMENT_ID, documentId));

		int batchSize  = ElasticSearchDAO.DEFAULT_ES_500_RESULTS;
		final SearchRequestBuilder searchRequestBuilder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_DOC_CHANGE_REQUEST.toString()).setExplain(false)
				.setScroll(new TimeValue(ElasticSearchDAO.DEFAULT_ES_60K_SCROLL_TIME_VALUE)).setPostFilter(andBuilder)
				.setSize(batchSize)
				.setRouting(AppBaseDAO.getInstance().getShardId(firmId));
		SearchResponse scrollResp = searchRequestBuilder.execute().actionGet();

		logger.info(firmId, "ESignatureService:getAllComments:searchRequestBuilder:" + searchRequestBuilder.toString());

		do {
			for (final SearchHit hit : scrollResp.getHits().getHits()) {
				final IdxDocChangeRequest document = AppUtil.convertFromJson(IdxDocChangeRequest.class, hit.getSourceAsString());
				document.setChangeRequestId(hit.getId());
				document.formatDateValues(TimeZone.getTimeZone(timeZoneId));
				documents.add(document);
			}
			if (scrollResp.getHits().getHits().length < batchSize) {
				break;
			}
			scrollResp = ElasticSearchDAO.getInstance().getClient(firmId).prepareSearchScroll(scrollResp.getScrollId())
					.setScroll(new TimeValue(ElasticSearchDAO.DEFAULT_ES_60K_SCROLL_TIME_VALUE)).execute().actionGet();
		} while (scrollResp.getHits().getHits().length != 0);
		ESAPIUtil.freeSearchResponse(firmId, scrollResp);
		return documents;
	}

	/**
	 * This method used to send change Request notification to signers through email.
	 * 
	 * @param idxDocChangeRequest
	 * @param mentionedSigners
	 * @param objectId
	 * @param brandId
	 */
	public void sendChangeRequestNotification(final IdxDocChangeRequest idxDocChangeRequest,
			final List<IdxObject> mentionedSigners, final Long objectId, String brandId,
			final IdxESignDocument idxESignDocument, final IdxESignSigner idxSigner) {
		final Long firmId = idxDocChangeRequest.getFirmId();

		final String fromAddress = getFromAddressForTemplate(objectId);
		String commentCreator = idxDocChangeRequest.getCreatedByName();

		String comments = "";
		comments +=	"<tr>" + 
						"<td style=\"border-bottom: 1px solid #efefef;\">" +
							"<div style='font-family: Arial; float: left; padding: 10px; display: flex;'>" +
								"<span style='color: #fff;outline: none;width: 46px;height: 25px;max-width: 27px;" +
								  "border: 2px solid rgba(0,0,0,0.30);border-radius: 50%;" +
								  "box-shadow: 0 0 3px #2196f3;text-align: center;" +
								  "background-color: rgb(33, 150, 243);float: left;'>" + 
									"<span style='position:relative;top:5px;font-size:16px;'>" + 
										commentCreator.substring(0, 1) + 
									ESignConstants.SPAN_END_TAG + 
								ESignConstants.SPAN_END_TAG + 
								"<div style='float: left;padding-left: 10px;font-size: 13px;width: 490px;'>" +
									ESignConstants.SPAN_TAG + commentCreator + ESignConstants.SPAN_END_TAG +
									"<div style='padding-top: 10px;word-break: break-all;'>" + 
										idxDocChangeRequest.getComments() + 
									ESignConstants.DIV_END_TAG + 
								ESignConstants.DIV_END_TAG +
							ESignConstants.DIV_END_TAG + 
						"</td>" +
					"</tr>";

		if (AppUtil.checkListisNullOrNot(idxDocChangeRequest.getHistory())) {
			for (int index = 0; index < idxDocChangeRequest.getHistory().size(); index++) {
				final IdxDocChangeRequest idxDocChangeRequestNested = idxDocChangeRequest.getHistory().get(index);
				commentCreator = idxDocChangeRequestNested.getCreatedByName();
				comments +=	"<tr>" + 
						"<td style=\"border-bottom: 1px solid #efefef;\">" +
							"<div style='font-family: Arial; float: left; padding: 10px; display: flex;'>" +
								"<span style='color: #fff;outline: none;width: 46px;height: 25px;max-width: 27px;" +
								  "border: 2px solid rgba(0,0,0,0.30);border-radius: 50%;" +
								  "box-shadow: 0 0 3px #2196f3;text-align: center;" +
								  "background-color: rgb(33, 150, 243);float: left;'>" + 
									"<span style='position: relative; top: 5px; font-size: 16px;'>" + 
										commentCreator.substring(0, 1) + 
									ESignConstants.SPAN_END_TAG + 
								ESignConstants.SPAN_END_TAG + 
								"<div style='float: left;padding-left: 10px;font-size: 13px;width: 490px;'>" +
									ESignConstants.SPAN_TAG + commentCreator + ESignConstants.SPAN_END_TAG +
									"<div style='padding-top: 10px;word-break: break-all;'>" + 
										idxDocChangeRequestNested.getComments() + 
									ESignConstants.DIV_END_TAG + 
								ESignConstants.DIV_END_TAG +
							ESignConstants.DIV_END_TAG + 
						"</td>" +
					"</tr>";
			}
		}

		IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
				ESignConstants.SEND_CHANGE_REQUEST_NOTIFICATION);

		if (idxEmailTemplate == null) {
			idxEmailTemplate = getEmailTemplateByName(AppConstants.APPTIVO_FIRM_ID,
					ESignConstants.SEND_CHANGE_REQUEST_NOTIFICATION);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		final String documentName = mentionedSigners.get(0).getName();
		final String documentURL = getDocumentRedirectionURL(firmId, Long.valueOf(idxDocChangeRequest.getDocumentId()), null,
				null, null);
		
		final Map<String, String> mailBodyValues = new HashMap<>();
		final Map<String, String> mailSubjectValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);

		mailSubjectValues.put(ESignConstants.DOCUMENT_NAME, documentName);

		mailBodyValues.put(ESignConstants.DOCUMENT_NAME, documentName);
		mailBodyValues.put(ESignConstants.SIGNER_NAME_2, commentCreator);
		mailBodyValues.put(ESignConstants.COMMENTS, comments);

		updateBrandingContent(firmId, brandId, mailBodyValues);

		for(IdxObject mentionedSigner : mentionedSigners) {
			final String documentRedirectionURL = documentURL + "&" + ESignConstants.URL_SIGNER_ID_PARAM + "="
					+ AppEncryptionUtil.encrypt(mentionedSigner.getObjectRefId().toString());
			
			prepareESignAttrForRequestSign(idxESignDocument, idxSigner, documentURL, mailSubjectValues, mailBodyValues);
			mailBodyValues.remove(ESignConstants.SIGNER_NAME);
			mailBodyValues.put(ESignConstants.SIGNER_NAME_1, mentionedSigner.getObjectRefName());

			idxEmailTemplate.setFromEmailId(fromAddress);
			idxEmailTemplate.setFromName(commentCreator);
			idxEmailTemplate.setReplyToEmailId(fromAddress);

			idxEmailTemplate.setToEmailId(mentionedSigner.getEmailId());

			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);
		}
	}

	/**
	 * This method used to get recent signatures.
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @return
	 */
	public List<IdxObjectSign> getRecentSavedSignatures(final Long firmId, final Long objectId,
			final Long objectRefId) {
		final List<IdxObjectSign> signatures = new ArrayList<>();

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_ID, objectId));
		andBuilder.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_REF_ID, objectRefId));

		SearchRequestBuilder searchRequestBuilder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_SAVED_SIGNATURES.toString()).setExplain(false)
				.setPostFilter(andBuilder).setSize(ESignConstants.RECENT_NUM_SIGNATURES)
				.setRouting(AppBaseDAO.getInstance().getShardId(firmId))
				.addSort(ESignConstants.DATE_LAST_USED, SortOrder.DESC);

		logger.info(firmId, "ESignatureService:getRecentSavedSignatures:searchRequestBuilder:" + searchRequestBuilder.toString());
		for (final SearchHit hit : searchRequestBuilder.execute().actionGet().getHits()) {
			final IdxObjectSign signature = AppUtil.convertFromJson(IdxObjectSign.class, hit.getSourceAsString());
			signature.setId(hit.getId());
			signatures.add(signature);
		}
		logger.info(firmId, "ESignatureService:getRecentSavedSignatures:signatures:size:" + signatures.size());

		return signatures;
	}
	
	/**
	 * This method used to index the signature.
	 * 
	 * @param idxObjectSign
	 */
	public void indexSignature(final IdxObjectSign idxObjectSign) {
		final Long firmId = idxObjectSign.getFirmId();
		if (idxObjectSign.getId() == null) {
			final IndexResponse indexResponse = ElasticSearchDAO.getInstance().indexDocument(firmId,
					ObjectConstants.OBJECT_SAVED_SIGNATURES, AppUtil.convertToJson(idxObjectSign), true);
			logger.info(firmId, "ESignatureService:indexSignature:indexResponse:" + indexResponse);

			if (indexResponse != null && indexResponse.getId() != null) {
				idxObjectSign.setId(indexResponse.getId());
			}
		} else {
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_SAVED_SIGNATURES,
					idxObjectSign.getId(), AppUtil.convertToJson(idxObjectSign));
		}
	}
	
	/**
	 * This method used to update the Last used data of Signatures.
	 *
	 * @param firmId
	 * @param signatureId
	 */
	public String updateLastUsedSignature (final Long firmId, final String signatureId) {
		final IdxObjectSign idxObjectSign = ElasticSearchDAO.getInstance().getDocument(firmId, IdxObjectSign.class,
				ObjectConstants.OBJECT_SAVED_SIGNATURES, signatureId);
		logger.info(firmId, "ESignatureService:updateLastUsedSignature:idxObjectSign:" + idxObjectSign);

		if(idxObjectSign != null) {
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());
			idxObjectSign.setDateLastUsed(currentDate);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_SAVED_SIGNATURES, signatureId,
					AppUtil.convertToJson(idxObjectSign));
			return AppConstants.RESULT_STATUS_SUCCESS;
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to return the 6th Signature object to Update if total Signature limit reached
	 * 
	 * @param firmId
	 * @param idxObjectSign
	 * @return
	 * @throws UnsupportedEncodingException 
	 */
	public IdxObjectSign prepareIdxObjectSign(final Long firmId, final IdxObjectSign idxObjectSign) {
		final List<IdxObjectSign> idxObjectSigns = getRecentSavedSignatures(firmId,
				Long.valueOf(idxObjectSign.getObjectId()), Long.valueOf(idxObjectSign.getObjectRefId()));
		logger.info(firmId, "ESignatureService:prepareIdxObjectSign:idxObjectSigns:size:" + idxObjectSigns.size());

		if (idxObjectSigns.size() == ESignConstants.RECENT_NUM_SIGNATURES) {
			final IdxObjectSign savedSignature = idxObjectSigns.get(idxObjectSigns.size() - 1);
			savedSignature.setSignature(idxObjectSign.getSignature());
			return savedSignature;
		}
		return idxObjectSign;
	}

	/**
	 * This method used to get the Firm ESign Document based on firmId and documentId.
	 * 
	 * @param firmId
	 * @param documentId
	 * @return
	 */
	public IdxFirmESignDocument getFirmESignDocument(final Long firmId, final Long documentId) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(AppConstants.ATHENA_INDEX_ID)
				.prepareSearch(ObjectConstants.OBJECT_FIRM_ESIGN_DOCUMENT.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery(ESignConstants.REQUEST_PARAM_DOCUMENT_ID, documentId));

		builder.setPostFilter(andBuilder);
		builder.setSize(1);
		logger.info(firmId, "ESignatureService:getFirmESignDocument:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();
		if (hits != null && hits.length > 0) {
			return AppUtil.convertFromJson(IdxFirmESignDocument.class,
					hits[0].getSourceAsString());
		}
		return null;
	}

	/**
	 * This method used to get the document page by index.
	 *
	 * @param firmId
	 * @param documentId
	 * @param pageNumber
	 * @return
	 */
	public IdxEsignDocumentPage getDocPageByIndex(final Long firmId, final Long documentId, final Long pageNumber) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString()).setSize(1)
				.setFetchSource(false);

		final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
		boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		boolQueryBuilder.must(QueryBuilders.termQuery(ESignConstants.ESIGN_DOCUMENT_ID, documentId));

		// To get the 0th index of document page alone in document.
		final InnerHitBuilder innerHitBuilder = new InnerHitBuilder(ESignConstants.ESIGN_DOCUMENT_PAGES);
		innerHitBuilder.setSize(1);
		final QueryBuilder documentPagesBuilder = QueryBuilders.boolQuery().must(
				QueryBuilders.termQuery(ESignConstants.ESIGN_DOCUMENT_PAGES + "." + ESignConstants.PAGE_NUMBER, pageNumber));

		final NestedQueryBuilder nestedQueryBuilder = QueryBuilders
				.nestedQuery(ESignConstants.ESIGN_DOCUMENT_PAGES, documentPagesBuilder, ScoreMode.Total)
				.innerHit(innerHitBuilder);
		boolQueryBuilder.must(nestedQueryBuilder);

		builder.setQuery(boolQueryBuilder);

		logger.info(firmId, "ESignatureService:getDocPageByIndex:builder:" + builder.toString());

		final SearchResponse hits = builder.execute().actionGet();
		for (SearchHit hit : hits.getHits()) {
			// getting the inner hits of the document.
			final SearchHits innerHits = hit.getInnerHits().get(ESignConstants.ESIGN_DOCUMENT_PAGES);
			for (SearchHit innerhit : innerHits) {
				if (innerhit != null && innerhit.getSourceAsString() != null) {
					return AppUtil.convertFromJson(IdxEsignDocumentPage.class, innerhit.getSourceAsString());
				}
			}
		}
		return null;
	}

	/**
	 * This method used to get the next document page details from document.
	 * 
	 * @param firmId
	 * @param request
	 */
	public Map<String, Object> getNextDocumentPage(final Long firmId, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		Long pageNumber = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_PAGE_INDEX, 0L);
		final String isFrom = AppHttpUtil.getStringParameter(request, AppConstants.STR_IS_FROM, null);
		final String mfdata = AppHttpUtil.getStringParameter(request,ESignConstants.MFD, "");

		final Map<String, Object> results = new HashMap<>();

		try {

			final HttpSession session = request.getSession();

			final IdxObject mfd = AppUtil.convertFromJson(IdxObject.class, mfdata);

			String attributeId = ESignConstants.ESIGN_DOCUMENT_CONV_PAGES + documentId;
			if (mfd != null) {
				attributeId += "_" + mfd.getId();
			}

			final Integer convertedPagesCount = (Integer) session.getAttribute(attributeId);
			if ("save".equalsIgnoreCase(isFrom) && (convertedPagesCount == null || pageNumber > convertedPagesCount)) {
				results.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				return results;
			}

			final IdxEsignDocumentPage page = getDocPageByIndex(firmId, documentId, pageNumber);
			if(page != null) {
				results.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				results.put(ESignConstants.RESPONSE_PARAM_DOCUMENT, page);
			} else {
				results.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			}
			return results;
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:getNextDocumentPage:exception:", exception);
		}
		results.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return results;
	}

	/**
	 * This API used to get the fromAddress for email template by objectId.
	 * 
	 * @param objectId
	 * @return
	 */
	public String getFromAddressForTemplate(final Long objectId) {
		String fromAddress = null;
		if(ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(objectId)) {
			fromAddress = AppBaseDAO.getInstance().getEnvProperty(ESignConstants.SIGN_EMAIL_FROM_ADDRESS,
				AppConstants.YES);
		} else {
			fromAddress = AppBaseDAO.getInstance().getEnvProperty(ESignConstants.ESIGN_EMAIL_FROM_ADDRESS,
					AppConstants.YES);
		}
		return fromAddress;
	}

	/**
	 * This method used to get the email template from Apptivo firm by Template Name
	 * @param firmId
	 * @param templateName
	 * 
	 * @return
	 */
	public IdxEmailTemplate getEmailTemplateByName(final Long firmId, final String templateName) {
		final IdxConfiguration customerConfiguration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
				IdxCustomersConfiguration.class, ObjectConstants.OBJECT_CUSTOMERS_SETTINGS_DATA, firmId);

		return getEmailTemplateByTemplateName(templateName, customerConfiguration);
	}

	/**
	 * This method used to get the email template by message type.
	 * 
	 * @param firmId
	 * @param messageType
	 * @return
	 */
	public IdxEmailTemplate getEmailTemplateByMessageType(final Long firmId, final String messageType) {
		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);
		if (idxESignConfiguration != null) {
			for (IdxEmailTemplate configEmailTemplate : idxESignConfiguration.getEmailTemplates()) {
				if (configEmailTemplate.getMessageType().equals(messageType)) {
					return ElasticSearchDAO.getInstance().getDocument(firmId, IdxEmailTemplate.class,
							ObjectConstants.OBJECT_EMAIL_TEMPLATE, configEmailTemplate.getId());
				}
			}
		}
		return null;
	}

	/**
	 * This method used to modify the subject and message of the mail template for
	 * Sign.co
	 *
	 * @param idxEmailTemplate
	 * @param idxESignDocument
	 */
	public void customizeMailTemplateContent(final IdxEmailTemplate idxEmailTemplate,
			final IdxESignDocument idxESignDocument) {
		// Replacing the custom subject
		if (idxESignDocument.getCustomSubject() != null) {
			idxEmailTemplate.setSubject(idxESignDocument.getCustomSubject());
		}

		// Replacing the custom message section.
		if (idxESignDocument.getCustomMessage() != null) {
			final String customMessage = idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1];
			idxEmailTemplate.setCustomMessage(
					idxEmailTemplate.getCustomMessage().replace(customMessage, idxESignDocument.getCustomMessage()));
		}

		// Removing the custom message code.
		idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
	}

	/**
	 * This method used to get the request sign email template by objectId.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @return
	 */
	public IdxEmailTemplate getRequestSignEmailTemplateByObjectId(final Long firmId,
			final IdxESignDocument idxESignDocument) {
		IdxEmailTemplate idxEmailTemplate = null;

		// For Sign.co, get customized email template
		if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
			idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.SEND_DOCUMENT_FOR_ESIGN);

			customizeMailTemplateContent(idxEmailTemplate, idxESignDocument);

			return idxEmailTemplate;
		}

		// For ESign (Sign.co Integrated firm), getting Sign.co customized Email Template
		if (!ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
			final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

			if (AppConstants.YES.equals(idxFirm.geteSignEnabled())) {
				idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.SEND_DOCUMENT_FOR_ESIGN);
				if (idxEmailTemplate == null) {
					idxEmailTemplate = getEmailTemplateByName(AppConstants.APPTIVO_FIRM_ID,
							ESignConstants.SEND_DOCUMENT_FOR_ESIGN);
				}

				customizeMailTemplateContent(idxEmailTemplate, idxESignDocument);
			} else {
				idxEmailTemplate = getEmailTemplateByName(AppConstants.APPTIVO_FIRM_ID,
						ESignConstants.SEND_DOCUMENT_FOR_ESIGN);
			}
		}
		return idxEmailTemplate;
	}

	/**
	 * This method used to check the SPF/DKIM is enabled in firm.
	 *
	 * @param firmId
	 * @param senderDetails
	 */
	public boolean isSpfDkimEnabled(final Long firmId, final IdxObject senderDetails) {
		boolean isEnabled = false;
		final IdxEmailsConfiguration idxEmailConfiguration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
				IdxEmailsConfiguration.class, ObjectConstants.OBJECT_EMAILS_SETTINGS_DATA, firmId);

		if (idxEmailConfiguration != null) {
			final IdxEmailDeliverability idxEmailDeliverability = EmailDAO.getInstance().getUserDomainByFromAddr(firmId,
					idxEmailConfiguration, senderDetails.getEmailId());
			if (idxEmailDeliverability != null && idxEmailDeliverability.getIsEnabled()) {
				final String isSpfDkimValidated = AppUtil.checkStringNullOrNot(
						idxEmailDeliverability.getIsSpfDkimValidated()) ? idxEmailDeliverability.getIsSpfDkimValidated()
								: AppConstants.NO;

				final String isFromAddressInReplyTo = AppUtil
						.checkStringNullOrNot(idxEmailDeliverability.getIsFromAddressInReplyTo())
								? idxEmailDeliverability.getIsFromAddressInReplyTo()
								: AppConstants.NO;

				if (AppConstants.YES.equals(isSpfDkimValidated) && AppConstants.NO.equals(isFromAddressInReplyTo)) {
					isEnabled = true;
				}
			}
		}
		return isEnabled;
	}

	/**
	 * This method used to prepare the email address based on the isSpfDkimEnabled
	 *
	 * @param idxESignDocument
	 * @param idxEmailTemplate
	 * @param isSpfDkimEnabled
	 */
	public void prepareEmailAddresses(final IdxESignDocument idxESignDocument, final IdxEmailTemplate idxEmailTemplate,
			final boolean isSpfDkimEnabled) {
		final IdxObject senderDetails = idxESignDocument.getSenderDetails();

		final String fromEmailId = senderDetails.getEmailId();
		final String fromName = senderDetails.getObjectRefName();

		final String defaultFromEmailId = getFromAddressForTemplate(
				idxESignDocument.getAssociatedObject().getObjectId());
		final String defaultFromName = ESignConstants.ESIGN_FROM_EMAIL_NAME;

		if (!isSpfDkimEnabled || fromEmailId.equals(idxEmailTemplate.getToEmailId())) {
			idxEmailTemplate.setFromEmailId(defaultFromEmailId);
			idxEmailTemplate.setReplyToEmailId(fromEmailId);
			idxEmailTemplate.setFromName(defaultFromName);
		} else {
			idxEmailTemplate.setFromEmailId(fromEmailId);
			idxEmailTemplate.setReplyToEmailId(fromEmailId);
			idxEmailTemplate.setFromName(fromName);
		}
	}

	/**
	 * This API used to send sign requesting mail to the signers.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param documentUrl
	 * @param isResend
	 */
	public void requestSignForESign(final Long firmId, final IdxESignDocument idxESignDocument,
			final String documentUrl, final Boolean isResend) {
		// Fetching the Email Template.
		IdxEmailTemplate idxEmailTemplate = null;
		if (Boolean.TRUE.equals(isResend)) {
			idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.RESEND_DOCUMENT_FOR_ESIGN);
			if (idxEmailTemplate == null) {
				idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.RESEND_DOCUMENT_FOR_ESIGN);
			}
			customizeMailTemplateContent(idxEmailTemplate, idxESignDocument);
		} else {
			// Getting request sign email template by objectId.
			idxEmailTemplate = getRequestSignEmailTemplateByObjectId(firmId, idxESignDocument);
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// For preparing mail subject and body for email template.
		final Map<String, String> mailSubjectValues = new HashMap<>();
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);

		// Sending Email to signers.
		for (IdxESignSigner idxSigner : idxESignDocument.getSignerForESign()) {
			// Preparing toAddress for Email Template.
			idxEmailTemplate.setToEmailId(idxSigner.getPrimaryEmailId());

			prepareESignAttrForRequestSign(idxESignDocument, idxSigner, documentUrl, mailSubjectValues, mailBodyValues);

			prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

			updateBrandingContent(firmId, idxESignDocument.getbId(), mailBodyValues);

			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);

			// Action Center - Need your signature
			if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
				ESignEventActionService.getInstance().produceActionQueue(firmId, idxESignDocument, idxSigner, null,
						ESignConstants.AE_CODE_NEED_YOUR_SIGNATURE);
			}

			// If isSequential is true, request sign to first signer of the document alone.
			if (Boolean.TRUE.equals(idxESignDocument.getIsSequential())) {
				break;
			}
		}
	}

	/**
	 * This API used to send sign requesting mail to the idxSigner.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param idxSigner
	 * @param documentUrl
	 * @param isResend
	 *
	 */
	public void requestSignBySigner(final Long firmId, final IdxESignDocument idxESignDocument,
			final IdxESignSigner idxSigner, final String documentUrl, final Boolean isResend) {
		// Fetching the Email Template.
		IdxEmailTemplate idxEmailTemplate = null;
		if (Boolean.TRUE.equals(isResend)) {
			idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.RESEND_DOCUMENT_FOR_ESIGN);
		} else {
			// Getting request sign email template by objectId.
			idxEmailTemplate = getRequestSignEmailTemplateByObjectId(firmId, idxESignDocument);
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// For preparing mail subject and body for email template.
		final Map<String, String> mailSubjectValues = new HashMap<>();
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);

		// Preparing toAddress for Email Template.
		idxEmailTemplate.setToEmailId(idxSigner.getPrimaryEmailId());

		prepareESignAttrForRequestSign(idxESignDocument, idxSigner, documentUrl, mailSubjectValues, mailBodyValues);

		updateBrandingContent(firmId, idxESignDocument.getbId(), mailBodyValues);

		prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

		// Sending Email to signers.
		sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);

		// // Action Center - Need your signature
		if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
			ESignEventActionService.getInstance().produceActionQueue(firmId, idxESignDocument, idxSigner, null,
					ESignConstants.AE_CODE_NEED_YOUR_SIGNATURE);
		}
	}

	/**
	 * This API used to prepare the common attributes content for requesting sign
	 * mail template.
	 * 
	 * Custom Subject and Custom Message
	 * 
	 * Business Information: Business Name, Business Phone and Business Address
	 *
	 * Branding Information: Company Logo, Company tagline and Email signature
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param mailBodyValues
	 */
	public void prepareCommonAttrForRequestSign(final Long firmId, final IdxESignDocument idxESignDocument,
			final Map<String, String> mailBodyValues) {
		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);
		final IdxComUser comUser = EmployeeDAO.getInstance().getIdxUser(firmId, idxESignDocument.getCreatedBy());

		// Business Information:
		mailBodyValues.put(ESignConstants.BUSINESS_NAME, idxFirm.getFirmName());

		String phoneNumber = "";
		if (AppUtil.checkListisNullOrNot(idxFirm.getPhoneNumbers())) {
			for (IdxPhoneNumber idxPhoneNumber : idxFirm.getPhoneNumbers()) {
				if (AppUtil.checkStringNullOrNot(idxPhoneNumber.getPhoneNumber())
						&& idxPhoneNumber.getPhoneNumber().length() > 3) {
					phoneNumber = idxPhoneNumber.getPhoneNumber();
					break;
				}
			}
		}
		mailBodyValues.put(ESignConstants.BUSINESS_PHONE, phoneNumber);

		String address = "";
		if (idxFirm.getAddress() != null) {
			address = idxFirm.getAddress().getFormattedAddressLines(false);
		}
		mailBodyValues.put(ESignConstants.BUSINESS_ADDRESS, address);

		// Branding Information:

		mailBodyValues.put(ESignConstants.COMPANY_LOGO, String.format(ESignConstants.LOGO_IMG_TAG, idxFirm.getBrandingImage()));
		mailBodyValues.put(ESignConstants.COMPANY_TAGLINE, idxFirm.getBrandingName());

		String emailSignatureText = "";
		final IdxEmailSignatureTemplate idxEmailSign = EmployeeDAO.getInstance().getEmailSignatureTemplate(firmId);

		if (comUser.getSignatureText() != null) {
			emailSignatureText = comUser.getSignatureText();
		} else if (idxEmailSign != null) {
			emailSignatureText = idxEmailSign.getTemplateText();
		} else {
			emailSignatureText = "";
		}
		mailBodyValues.put(ESignConstants.EMAIL_SIGNATURE, emailSignatureText);

		// Replacing the Sign logo in email template
		updateBrandingContent(firmId, idxESignDocument.getbId(), mailBodyValues);
	}

	/**
	 * This API used to prepare the esign attributes content for requesting sign
	 * mail template.
	 * 
	 * ESign Information: Document Name, Document Re-direction URL, Sender Name,
	 * Sender Email ID, Signer Name and Signer Email ID.
	 * 
	 * @param idxESignDocument
	 * @param idxSigner
	 * @param documentUrl
	 * @param mailSubjectValues
	 * @param mailBodyValues
	 */
	public void prepareESignAttrForRequestSign(final IdxESignDocument idxESignDocument, final IdxESignSigner idxSigner,
			final String documentUrl, final Map<String, String> mailSubjectValues,
			final Map<String, String> mailBodyValues) {
		// Preparing Subject for Email Template.
		final String documentName = idxESignDocument.getDocumentName();

		// Preparing mail subject values for email template.
		mailSubjectValues.put(ESignConstants.DOCUMENT_NAME, documentName);

		mailSubjectValues.put(ESignConstants.SENDER_NAME, idxESignDocument.getSenderDetails().getObjectRefName());
		mailSubjectValues.put(ESignConstants.SENDER_EMAIL_ID, idxESignDocument.getSenderDetails().getEmailId());

		if (idxSigner != null) {
			mailSubjectValues.put(ESignConstants.SIGNER_NAME, idxSigner.getObjectRefName());
			mailSubjectValues.put(ESignConstants.SIGNER_EMAIL_ID, idxSigner.getPrimaryEmailId());
		}

		// Preparing mail body values for email template.
		if(AppUtil.checkStringNullOrNot(documentUrl) && idxSigner != null) {
			final String documentRedirectionUrl = documentUrl + "&" + ESignConstants.URL_SIGNER_ID_PARAM + "="
					+ AppEncryptionUtil.encrypt(idxSigner.geteSignSignerId().toString());
			mailBodyValues.put(ESignConstants.DOCUMENT_URL, documentRedirectionUrl);
		}

		mailBodyValues.put(ESignConstants.DOCUMENT_NAME, documentName);

		mailBodyValues.put(ESignConstants.SENDER_NAME, idxESignDocument.getSenderDetails().getObjectRefName());
		mailBodyValues.put(ESignConstants.SENDER_EMAIL_ID, idxESignDocument.getSenderDetails().getEmailId());

		if (idxSigner != null) {
			mailBodyValues.put(ESignConstants.SIGNER_NAME, idxSigner.getObjectRefName());
			mailBodyValues.put(ESignConstants.SIGNER_EMAIL_ID, idxSigner.getPrimaryEmailId());
		}

		if(idxESignDocument.getExpDate() != null) {
			mailBodyValues.put(ESignConstants.EXPIRY_DATE, new SimpleDateFormat(DateUtil.format_mdy)
					.format(DateUtil.parseDate(idxESignDocument.getExpDate(), DateUtil.getEsDateFormat(), new Date())));
			mailBodyValues.put(ESignConstants.EXTENDED_DATE, new SimpleDateFormat(DateUtil.format_mdy)
					.format(DateUtil.parseDate(idxESignDocument.getExpDate(), DateUtil.getEsDateFormat(), new Date())));
		}

//		mailBodyValues.put(ESignConstants.THUMBNAIL_IMG, idxESignDocument.getDocumentPages().get(0).getDocumentData());
	}

	/**
	 * This method used to notify the signer when the document is signed.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param idxESignSigner
	 * @param documentUrl
	 * @param attachments
	 */
	public void notifyToSigner(final Long firmId, final IdxESignDocument idxESignDocument,
			final IdxESignSigner idxESignSigner, final String documentUrl, final String[] attachments) {
		IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
				ESignConstants.SEND_NOTIFICATION_TO_ESIGNER);
		if (idxEmailTemplate == null) {
			// Getting email template from Apptivo customer configuration.
			idxEmailTemplate = getEmailTemplateByName(AppConstants.APPTIVO_FIRM_ID,
					ESignConstants.SEND_NOTIFICATION_TO_ESIGNER);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// Preparing mail subject for template.
		final Map<String, String> mailSubjectValues = new HashMap<>();

		// Preparing mail body for template.
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
		prepareESignAttrForRequestSign(idxESignDocument, idxESignSigner, documentUrl, mailSubjectValues, mailBodyValues);

		idxEmailTemplate.setToEmailId(idxESignSigner.getPrimaryEmailId());

		prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

		// Restricting the Signed document Distribution based on Signer
		if (Boolean.FALSE.equals(idxESignSigner.getIae())) {
			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);
		} else {
			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, attachments);
		}
	}

	/**
	 * This method used to send the notification mail to CC
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param documentUrl
	 * @param attachments
	 * @param subject
	 * @param message
	 */
	public void notifyToCC(final Long firmId, final IdxESignDocument idxESignDocument, final String documentUrl,
			final String[] attachments, final String subject, final String message) {
		for (final IdxESignSigner idxESignSigner : idxESignDocument.getCCList()) {
			IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
					ESignConstants.SEND_NOTIFICATION_TO_CC);
			if (idxEmailTemplate == null) {
				// Getting email template from Apptivo customer configuration.
				idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.SEND_NOTIFICATION_TO_CC);
			} else {
				idxEmailTemplate
						.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
			}

			// Checking SPF/DKIM enabled or not.
			final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

			// Preparing the Mail Subject and Mail Body - custom variables
			final Map<String, String> mailSubjectValues = new HashMap<>();
			final Map<String, String> mailBodyValues = new HashMap<>();
			prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
			prepareESignAttrForRequestSign(idxESignDocument, idxESignSigner, documentUrl, mailSubjectValues, mailBodyValues);

			if (subject != null) {
				idxEmailTemplate.setSubject(subject);
			}

			if (message != null) {
				mailBodyValues.put(ESignConstants.CUSTOM_MESSAGE,
						"You have a message from the sender.<br />" + message);
			} else {
				mailBodyValues.put(ESignConstants.CUSTOM_MESSAGE, "");
			}

			idxEmailTemplate.setToEmailId(idxESignSigner.getPrimaryEmailId());

			prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, attachments);
		}
	}

	/**
	 * This method used to send the notification mail to the owner of the document
	 * when document is signed by signer.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param idxESignSigner
	 * @param documentUrl
	 * @param attachments
	 */
	public void notifyToOwner(final Long firmId, final IdxESignDocument idxESignDocument,
			final IdxESignSigner idxESignSigner, final String documentUrl, final String[] attachments) {
		// Restricting the notification mail for signer as owner scenario
		if (idxESignSigner.getPrimaryEmailId().equalsIgnoreCase(idxESignDocument.getSenderDetails().getEmailId())) {
			return;
		}

		IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
				ESignConstants.SEND_NOTIFICATION_TO_ESIGN_REQUESTER);
		if (idxEmailTemplate == null) {
			// Getting email template from Apptivo customer configuration..
			idxEmailTemplate = getEmailTemplateByName(AppConstants.APPTIVO_FIRM_ID,
					ESignConstants.SEND_NOTIFICATION_TO_ESIGN_REQUESTER);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// Preparing mail subject for template.
		final Map<String, String> mailSubjectValues = new HashMap<>();

		// Preparing mail body for template.
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
		prepareESignAttrForRequestSign(idxESignDocument, idxESignSigner, documentUrl, mailSubjectValues, mailBodyValues);

		mailBodyValues.put(ESignConstants.AUDIT_TRAIL, prepareAuditTrailContent(idxESignDocument.getSigners()));

		idxEmailTemplate.setToEmailId(idxESignDocument.getSenderDetails().getEmailId());

		prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

		sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, attachments);
	}

	/**
	 * This method used to prepare the audit trail content for email template
	 * 
	 * @param idxESignSigners
	 * @return
	 */
	public String prepareAuditTrailContent(final List<IdxESignSigner> idxESignSigners) {
		final StringBuilder auditTrail = new StringBuilder();
		for(IdxESignSigner idxESignSigner : idxESignSigners) {
			if(ESignConstants.SIGNER_ACTION_NEED_SIGN.equals(idxESignSigner.getSignerActions())) {
				if(ESignConstants.SIGNER_STATUS_NEW.equalsIgnoreCase(idxESignSigner.getSignerStatus())) {
					idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_PENDING.toUpperCase());
				}
				auditTrail.append("<tr>" +
						"<td style=\"border-bottom: 1px solid #efefef;\">" +
							"<div style='font-family: Arial; float: left; padding: 10px; display: flex;'>" +
								"<span style='color: #fff;outline: none;width: 46px;height: 25px;max-width: 27px;" +
								  "border: 2px solid rgba(0,0,0,0.30);border-radius: 50%;" +
								  "box-shadow: 0 0 3px #2196f3;text-align: center;" +
								  "background-color: rgb(33, 150, 243);float: left;'>" +
									"<span style='position:relative;top:5px;font-size:16px;'>" +
										idxESignSigner.getObjectRefName().substring(0, 1) +
									ESignConstants.SPAN_END_TAG +
								ESignConstants.SPAN_END_TAG +
								"<div style='float: left;padding-left: 10px;padding-top: 5px;font-size: 13px;width: 490px;'>" +
									ESignConstants.SPAN_TAG +
										idxESignSigner.getObjectRefName() +
										" (" + idxESignSigner.getPrimaryEmailId() + ") - " +
										idxESignSigner.getSignerStatus().substring(0, 1) +
										idxESignSigner.getSignerStatus().substring(1, idxESignSigner.getSignerStatus().length()).toLowerCase() +
									ESignConstants.SPAN_END_TAG +
								ESignConstants.DIV_END_TAG +
							ESignConstants.DIV_END_TAG +
						ESignConstants.TD_END_TAG +
					ESignConstants.TR_END_TAG);
			}
		}
		return auditTrail.toString();
	}

	/**
	 * This method used to get the signers list excluding the document owner mail.
	 * 
	 * @param idxESignDocument
	 * @return
	 */
	public List<IdxESignSigner> getSigners(final IdxESignDocument idxESignDocument) {
		final List<IdxESignSigner> idxESignSigners = new ArrayList<>();
		for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
			if (!idxESignDocument.getSenderDetails().getEmailId().equals(idxESignSigner.getPrimaryEmailId())) {
				idxESignSigners.add(idxESignSigner);
			}
		}
		return idxESignSigners;
	}

	/**
	 * This method used to send the notification mail to signers and owner of the
	 * document, once the document is signed by all the signers.
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param signers
	 * @param documentUrl
	 * @param attachments
	 */
	public void notifyDocumentCompletion(final Long firmId, final IdxESignDocument idxESignDocument,
			List<IdxESignSigner> signers, final String documentUrl, final String[] attachments) {

		IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
				ESignConstants.SEND_COMPLETED_DOC_TO_ESIGN_PARTICIPANTS);
		if (idxEmailTemplate == null) {
			// Getting email template from Apptivo customer configuration..
			idxEmailTemplate = getEmailTemplateByName(AppConstants.APPTIVO_FIRM_ID,
					ESignConstants.SEND_COMPLETED_DOC_TO_ESIGN_PARTICIPANTS);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// For preparing mail subject and body for email template.
		final Map<String, String> mailSubjectValues = new HashMap<>();
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);

		// Preparing mail body for email template.
		final String auditTrail = prepareAuditTrailContent(idxESignDocument.getSigners());
		mailBodyValues.put(ESignConstants.AUDIT_TRAIL, auditTrail);

		// Sending Email to signers.
		if (signers == null) {
			signers = getSigners(idxESignDocument);
		}
		for(IdxESignSigner idxSigner : signers) {

			prepareESignAttrForRequestSign(idxESignDocument, idxSigner, documentUrl, mailSubjectValues, mailBodyValues);

			idxEmailTemplate.setToEmailId(idxSigner.getPrimaryEmailId());

			prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

			// Restricting the Signed document Distribution based on Signer
			if(Boolean.FALSE.equals(idxSigner.getIae())) {
				sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);
			} else {
				sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, attachments);
			}
		}

		// Sending document completion for the owner of the document.
		String ownerSignerId = idxESignDocument.getCreatedBy().toString();

		// Owner As a Signer Data
		final IdxESignSigner ownerData = idxESignDocument
				.getESignSignerByEmailId(idxESignDocument.getSenderDetails().getEmailId());
		if (ownerData != null) {
			ownerSignerId = ownerData.geteSignSignerId().toString();
		}

		final String documentRedirectionUrl = documentUrl + "&" + ESignConstants.URL_SIGNER_ID_PARAM + "="
				+ AppEncryptionUtil.encrypt(ownerSignerId);

		mailBodyValues.put(ESignConstants.DOCUMENT_URL, documentRedirectionUrl);
		mailBodyValues.put(ESignConstants.SIGNER_NAME, idxESignDocument.getSenderDetails().getObjectRefName());

		if (AppConstants.DEV_ENVIRONMENT.equals(System.getProperty(AppConstants.SOURCE_ENVIRONMENT))) {
			logger.info(firmId, "ESignatureService:notifyDocumentCompletion:mailSubjectValues:" + mailSubjectValues);
			logger.info(firmId, "ESignatureService:notifyDocumentCompletion:mailBodyValues:" + mailBodyValues);
		}

		idxEmailTemplate.setToEmailId(idxESignDocument.getSenderDetails().getEmailId());

		prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

		sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, attachments);
	}

	/**
	 * This method used to update the email template in configuration and in OBJECT_EMAIL_TEMPLATE.
	 * 
	 * @param firmId
	 * @param userData
	 * @param emailTemplateDataStr
	 * @return
	 */
	public Map<String, Object> updateEmailTemplate(final Long firmId, final UserData userData,
			final String emailTemplateDataStr) {
		final Map<String, Object> results = new HashMap<>();

		final String currentDate = DateUtil.getEsDateFormat().format(new Date());

		final IdxEmailTemplate emailTemplateData = AppUtil.convertFromJson(IdxEmailTemplate.class,
				emailTemplateDataStr);
		logger.info(firmId, "ESignatureService:updateEmailTemplate:templateData:" + emailTemplateData);

		// Updating email template in configuration
		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

		final IdxEmailTemplate configEmailTemplate = idxESignConfiguration.getEmailTemplate(emailTemplateData.getId());
		if (configEmailTemplate != null) {
			configEmailTemplate.setName(emailTemplateData.getName());
			configEmailTemplate.setSubject(emailTemplateData.getSubject());
			configEmailTemplate
					.setCustomMessage(emailTemplateData.getCustomMessage().split(ESignConstants.CUST_MSG)[1]);
			configEmailTemplate.setIsEnabled(emailTemplateData.getIsEnabled());

			configEmailTemplate.setLastUpdateDate(currentDate);
			configEmailTemplate.setLastUpdatedByName(userData.getFullName());
			configEmailTemplate.setLastUpdatedBy(userData.getUserId());

			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));
		}

		// Updating email template in OBJECT_EMAIL_TEMPLATE
		final IdxEmailTemplate idxEmailTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxEmailTemplate.class, ObjectConstants.OBJECT_EMAIL_TEMPLATE, emailTemplateData.getId());
		logger.info(firmId, "ESignatureService:updateEmailTemplate:idxEmailTemplate:" + idxEmailTemplate);

		if (idxEmailTemplate != null) {
			emailTemplateData.setLastUpdateDate(currentDate);
			emailTemplateData.setLastUpdatedByName(userData.getFullName());
			emailTemplateData.setLastUpdatedBy(userData.getUserId());

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
					emailTemplateData.getId(), AppUtil.convertToJson(emailTemplateData));

			// Updating the email template revision
			AppSettingsDAO.getInstance().addEmailTemplateRevision(firmId, userData.getUserId(), userData.getFullName(),
					emailTemplateData.getObjectId(), emailTemplateData.getCustomMessage(), emailTemplateData.getId(),
					emailTemplateData.getWidgets(), null);

			results.put(AppConstants.RESULT_CONFIG_DATA, idxESignConfiguration);
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
		} else {
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		}

		return results;
	}

	/**
	 * This method used to reset the email template message content.
	 *
	 * @param firmId
	 * @param userData
	 * @param id
	 * @param sequenceNumber
	 * @return
	 */
	public Map<String, Object> resetEmailTemplate(final Long firmId, final UserData userData, final Long id,
			final Long sequenceNumber) {
		final Map<String, Object> results = new HashMap<>();

		final IdxEmailTemplate idxEmailTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxEmailTemplate.class, ObjectConstants.OBJECT_EMAIL_TEMPLATE, id);

		final String emailTemplateData = AppFileUtil.getInstance()
				.readFileFromClassPath(ESignConstants.EMAIL_TEMPLATE_FILE_PATH);
		try {
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final JSONParser parser = new JSONParser();
			final JSONArray emailTemplates = (JSONArray) parser.parse(emailTemplateData);
			for (int i = 0; i < emailTemplates.size(); i++) {
				final IdxEmailTemplate emailTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class,
						emailTemplates.get(i).toString());
				if (emailTemplate.getSequenceNumber().equals(sequenceNumber)) {
					// Updating email template
					idxEmailTemplate.setCustomMessage(emailTemplate.getCustomMessage());
					idxEmailTemplate.setWidgets(emailTemplate.getWidgets());

					idxEmailTemplate.setLastUpdatedBy(userData.getUserId());
					idxEmailTemplate.setLastUpdatedByName(userData.getFullName());
					idxEmailTemplate.setLastUpdateDate(currentDate);

					ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
							idxEmailTemplate.getId(), AppUtil.convertToJson(idxEmailTemplate));

					// Updating the email template revision
					AppSettingsDAO.getInstance().addEmailTemplateRevision(firmId, userData.getUserId(),
							userData.getFullName(), idxEmailTemplate.getObjectId(), idxEmailTemplate.getCustomMessage(),
							idxEmailTemplate.getId(), idxEmailTemplate.getWidgets(), null);

					// Updating the email template in configuration
					final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
							IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

					final IdxEmailTemplate configEmailTemplate = idxESignConfiguration.getEmailTemplate(idxEmailTemplate.getId());

					configEmailTemplate.setCustomMessage(
							idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1]);

					configEmailTemplate.setLastUpdateDate(idxEmailTemplate.getLastUpdateDate());
					configEmailTemplate.setLastUpdatedByName(idxEmailTemplate.getLastUpdatedByName());
					configEmailTemplate.setLastUpdatedBy(idxEmailTemplate.getLastUpdatedBy());

					ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
							ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
							AppUtil.convertToJson(idxESignConfiguration));

					results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
					results.put(AppConstants.RESULT_CONFIG_DATA, idxESignConfiguration);
					results.put(AppConstants.RESULT_DATA, idxEmailTemplate);
					return results;
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:resetEmailTemplate:exception:", exception);
		}
		results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);

		return results;
	}

	/**
	 * This method used to get the attachment file for email.
	 * 
	 * @param idxESignDocument
	 * @param pdfBase
	 * @param auditBase
	 * @return
	 */
	public String[] getAttachmentsForEmail(final IdxESignDocument idxESignDocument, final String pdfBase,
			final byte[] auditBase) {
		String[] result = new String[1];

		final byte[][] icsByteArray = new byte[1][];
		icsByteArray[0] = Base64.decodeBase64(pdfBase.split(",")[1]);
		final String objRefName = idxESignDocument.getAssociatedObject().getObjectRefName();
		final String documentName = objRefName.indexOf(AppConstants.PDF_FILE_EXTENSION) > -1 ? objRefName
				: objRefName + AppConstants.PDF_FILE_EXTENSION;

		final Object[] additionalAttachedObjects = AppCommonUtil.downloadMultipleDocuments("", 0, documentName, true,
				"test", false, icsByteArray);
		String[] docAttachment = (String[]) additionalAttachedObjects[4];
		result[0] = docAttachment[0];

		if (auditBase != null) {
			result = new String[2];
			result[0] = docAttachment[0];

			final String auditFileName = objRefName + "_audit" + AppConstants.PDF_FILE_EXTENSION;
			icsByteArray[0] = auditBase;

			final Object[] auditAttachmentObject = AppCommonUtil.downloadMultipleDocuments("", 0, auditFileName, true,
					"test", false, icsByteArray);
			String[] auditAttachment = (String[]) auditAttachmentObject[4];
			result[1] = auditAttachment[0];
		}

		return result;
	}

	/**
	 * This method used to get the PDF content based on objectId.
	 * 
	 * @param firmId
	 * @param userId
	 * @param objectId
	 * @param objectRefId
	 * @param userData
	 * @param request
	 * @param dateFormat
	 * @return
	 */
	public Map<String, Object> getObjectPDF(final Long firmId, final Long userId, final Long objectId,
			final Long objectRefId, final UserData userData, final HttpServletRequest request,
			final String dateFormat) {
		final Map<String, Object> objectPDF;
		if (ObjectConstants.OBJECT_ESTIMATE.equals(objectId)) {
			objectPDF = EstimateElasticService.getInstance().getEstimatePdf(firmId, objectRefId, userData, request);
		} else if (ObjectConstants.OBJECT_CONTRACT.equals(objectId)) {
			objectPDF = ContractsElasticService.getInstance().getContractPdf(firmId, userId,
					ObjectConstants.OBJECT_CONTRACT, userData, objectRefId.toString(), request);
		} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(objectId)) {
			objectPDF = WorkOrdersElasticService.getInstance().getWorkOrderPdf(firmId, objectRefId, userData,
					dateFormat, request);
		} else if(ObjectConstants.OBJECT_CASE.equals(objectId) || objectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			objectPDF = CasesElasticService.getInstance().getCasePdf(firmId, objectRefId, objectId, userData,
					dateFormat, request);
		} else {
			objectPDF = null;
			logger.info(firmId, "ESignatureService:getObjectPDF:in else block");
		}
		return objectPDF;
	}

	/**
	 * This method used to get all the e-sign histories by objectId and objectRefId.
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @param startIndex
	 * @param numRecords
	 * @param sortColumn
	 * @return
	 */
	public SearchHits getAllEsignHistory(final Long firmId, final Long objectId, final Long objectRefId,
			final Integer startIndex, final Integer numRecords, final String sortColumn) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false)
				.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery()
				.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId))
				.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_ID, objectId))
				.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_REF_ID, objectRefId));
		builder.setPostFilter(boolQueryBuilder);

		if (startIndex != null) {
			builder.setTrackTotalHits(true).setFrom(startIndex);
		} else {
			builder.setTrackTotalHits(true).setFrom(0);
		}

		if (numRecords != null && numRecords > 0) {
			builder.setSize(numRecords);
		} else {
			builder.setSize(AppConstants.DASHBOARD_MAX_RECORDS);
		}

		builder.addSort(sortColumn, SortOrder.ASC);

		final SearchHits searchHits = builder.execute().actionGet().getHits();

		logger.info(firmId, "ESignatureService:getAllEsignHistory:builder:" + builder.toString());
		logger.info(firmId, "ESignatureService:getAllEsignHistory:total hits:" + searchHits.getTotalHits().value);
		return searchHits;
	}

	/**
	 * This method used to make a e-sign sent entry in e-signature history tab.
	 * 
	 * @param firmId
	 * @param userData
	 * @param emailId
	 * @param documentId
	 * @param idxEsignatureHistory
	 * @param status
	 * @param documentName
	 */
	public void createSignHistoryForSent(final Long firmId, final UserData userData, final String emailId,
			final String documentId, final IdxEsignatureHistory idxEsignatureHistory, final String status,
			final String documentName) {
		idxEsignatureHistory.setFirmId(firmId);
		idxEsignatureHistory.setStatus(status.toUpperCase());
		idxEsignatureHistory.setStatusName(status);
		idxEsignatureHistory.setEmailId(emailId);
		idxEsignatureHistory.setDocumentId(documentId);
		idxEsignatureHistory.setHistoryDate(DateUtil.formatDate(new Date(), DateUtil.getEsDateFormat()));

		String desc = AppConstants.ESIGN_DESC_SENT;
		if (AppConstants.ESIGN_RESENT.equalsIgnoreCase(status)) {
			desc = AppConstants.ESIGN_DESC_RESENT;
		}
		desc = desc.replace("SENDER_NAME", userData.getFullName());
		desc = desc.replace("EMAIL_ID", emailId);
		desc = desc.replace("DOCUMENT_NAME", documentName);
		idxEsignatureHistory.setDescription(desc);

		ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESIGNATURE_HISTORY,
				AppUtil.convertToJson(idxEsignatureHistory), true);
	}

	/**
	 * This method used to check whether the signer signed the document.
	 *
	 * @param idxESignDocument
	 * @param signerEmailId
	 * @return
	 */
	public boolean isDocSignedBySigner(final IdxESignDocument idxESignDocument, final String signerEmailId) {
		boolean isSigned = true;

		for (IdxEsignDocumentPage idxESignDocumentPage : idxESignDocument.getDocumentPages()) {
			for (IdxEsignAttribute idxESignAttribute : idxESignDocumentPage.geteSignAttributes()) {
				if (signerEmailId.equals(idxESignAttribute.geteSignSigner().getPrimaryEmailId())
						&& !idxESignAttribute.isCompleted()) {
					isSigned = false;
					break;
				}
			}
		}

		return isSigned;
	}

	/**
	 * This method used to update the status of the signer if the document is signed at the
	 * document prepare page itself in SEND_ESIGN.
	 *
	 * Note: It'll only applicable if owner is one of the signer of the document
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @param documentUrl
	 * @param clientIpAddress
	 * @param userAgent
	 */
	public void updateStatusForOwnerAsSigner(final Long firmId, final IdxESignDocument idxESignDocument,
			final String documentUrl, final String clientIpAddress, final String userAgent) {
		boolean isOwnerExists = false;
		boolean isOwnerSigned = true;

		IdxESignSigner eSignSigner = null;
		final String ownerEmailId = idxESignDocument.getSenderDetails().getEmailId();

		for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
			if (ownerEmailId.equals(idxESignSigner.getPrimaryEmailId())
					&& ESignConstants.SIGNER_ACTION_NEED_SIGN.equalsIgnoreCase(idxESignSigner.getSignerActions())) {
				isOwnerExists = true;
				eSignSigner = idxESignSigner;
				break;
			}
		}

		if (isOwnerExists) {
			isOwnerSigned = isDocSignedBySigner(idxESignDocument, ownerEmailId);

			if (isOwnerSigned) {
				eSignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED.toUpperCase());

				final IdxEsignatureHistory idxEsignHistory = createESignatureHistory(firmId, idxESignDocument, eSignSigner,
						AppConstants.ESIGN_SIGNED, AppConstants.ESIGN_DESC_SIGN, clientIpAddress, userAgent, null);

				// Creating the signed document
				final Map<String, String> result = prepareSignedPDFInBytes(idxESignDocument);
				final String pdfBase = AppConstants.BASE64_PREFIX_PDF
						+ Base64.encodeBase64String(Base64.decodeBase64(result.get(AppConstants.BYTES_CONTENT)));
				final IdxESignDocRevisions idxDocRevSigner = saveESignDocRevision(firmId,
						ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString(), idxEsignHistory.getHistoryId(), pdfBase);
				saveToBlockChain(idxESignDocument.getFirmId(), idxDocRevSigner.getId(),
						eSignSigner.getObjectRefName(), result.get(AppConstants.FILE_PATH));

				deleteFileIfExists(firmId, result.get(AppConstants.FILE_PATH));

				// Sending notification mail to the signer
				notifyToSigner(firmId, idxESignDocument, eSignSigner, documentUrl,
						getAttachmentsForEmail(idxESignDocument, pdfBase, null));

				// Updating the document status to In-Progress - One of the signer is signed
				if(idxESignDocument.getSigners().size() > 1) {
					idxESignDocument.setStatusCode(ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING.toUpperCase());
					idxESignDocument.setStatusName(ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING);
				}
			}
		}
	}

	/**
	 * This method used to convert doc to Pdf file by NodeJS Service.
	 *
	 * @param firmId
	 * @param userId
	 * @param documentId
	 * @param mfd
	 * @param bFile
	 * @return
	 */
	public Map<String, Object> convertDocToPdf(final Long firmId, final Long userId,
			final Long documentId, final IdxObject mfd, final byte[] bFile) {
		final Map<String, Object> fileData = new HashMap<>();

		final String fileName = firmId + "_" + userId + "_" + documentId + "_" + mfd.getId() + "_"
				+ System.currentTimeMillis() + mfd.getExt();

		final Map<String, String> params = new HashMap<>();
		params.put(ESignConstants.FILE_NAME, fileName);
		params.put(ESignConstants.FILE_CONTENT, Base64.encodeBase64String(bFile));

		final String docToPdfBaseUrl = AppBaseDAO.getInstance().getEnvProperty(ESignConstants.DOC_TO_PDF_BASE_URL,
				AppConstants.YES);

		final String auth = AppBaseDAO.getInstance().getEnvProperty(ESignConstants.DOC_TO_PDF_APP_AUTH,
				AppConstants.YES);

		FileInputStream fileInputStream = null;
		try {
			final AppHttpClient appHttpClient = new AppHttpClient();

			appHttpClient.setProviderBaseURI(docToPdfBaseUrl);
			appHttpClient.setUserName(auth.split(":")[0]);
			appHttpClient.setPassword(auth.split(":")[1]);

			final Map<String, String> response = appHttpClient.executePostMethod(ESignConstants.CONVERT_TO_PDF, params,
					AppConstants.CONTENTTYPE_URL_ENCODED);

			/**
			 * Response: { "status": "success", "fileContent": "pdfBase"}
			 */
			if (response != null) {
				final JSONParser jsonParser = new JSONParser();
				final JSONObject responseObject = (JSONObject) jsonParser.parse(
						response.get(AppConstants.CONTENTTYPE_XML.toLowerCase()));

				final String resultStatus = responseObject.get(AppConstants.RESULT_STATUS).toString();

				if (AppConstants.RESULT_STATUS_SUCCESS.equalsIgnoreCase(resultStatus)) {
					final String fileContent = responseObject.get(ESignConstants.FILE_CONTENT).toString();

					final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
							+ firmId + "_" + userId + "_" + documentId + "_" + mfd.getId()  + "_" + System.currentTimeMillis()
							+ AppConstants.PDF_FILE_EXTENSION;

					final File pdfFile = new File(inputPDFName);
					byte[] decodedPDF = Base64.decodeBase64(fileContent);
					FileUtils.writeByteArrayToFile(pdfFile, decodedPDF);

					byte[] byteContent = new byte[(int) pdfFile.length()];

					fileInputStream = new FileInputStream(pdfFile);
					int numRead = fileInputStream.read(byteContent);
					logger.info(firmId, "ESignatureService:convertDocToPdf:numRead:"+ numRead);
					fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
					fileData.put(ESignConstants.FILE_NAME, inputPDFName);
					fileData.put(ESignConstants.FILE_CONTENT,
							AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(byteContent));
				} else {
					fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
					if (responseObject.get(AppConstants.RESULT_REASON).toString() != null) {
						fileData.put(AppConstants.STR_ERROR_CODE, responseObject.get(AppConstants.STR_ERROR_CODE).toString());
						fileData.put(AppConstants.RESULT_REASON, responseObject.get(AppConstants.RESULT_REASON).toString());
					}
				}
			}
		} catch (AppException exception) {
			fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			logger.error(firmId, "ESignatureService:convertDocToPdf:app exception:", exception);
		} catch (IOException exception) {
			fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			logger.error(firmId, "ESignatureService:convertDocToPdf:io exception:", exception);
		} catch(Exception exception) {
			fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			logger.error(firmId, "ESignatureService:convertDocToPdf:exception:", exception);
		} finally
		{
			if(fileInputStream != null)
			{
				try {
					fileInputStream.close();
				} catch (IOException e) {
					logger.error(firmId, "ESignatureService:convertDocToPdf:IOException:e:", e);
				}
			}
		}
		return fileData;
	}

	/**
	 * This method used to get the file data - file path and byte content from request.
	 *
	 * @param firmId
	 * @param userId
	 * @param documentId
	 * @param mfd
	 * @param request
	 * @return
	 */
	@SuppressWarnings("rawtypes")
	public Map<String, Object> getFileData(final Long firmId, final Long userId, final Long documentId,
			final IdxObject mfd, final HttpServletRequest request) {
		Map<String, Object> fileData = new HashMap<>();
		final FileItemFactory factory = new DiskFileItemFactory();
		final ServletFileUpload upload = new ServletFileUpload(factory);
		List items = null;

		try {
			items = upload.parseRequest(request);
		} catch (final FileUploadException exception) {
			logger.error(firmId, "ESignatureService:getFileData:exception while parsing:", exception);
		}

		Iterator iter = null;

		if (items != null) {
			iter = items.iterator();
		}

		if (iter != null) {
			byte[] bFile;
			FileInputStream fileInputStream = null;
			while (iter.hasNext()) {
				try {
					final FileItem item = (FileItem) iter.next();

					final String fileId = documentId + "_" + mfd.getId().toString();

					if (!item.isFormField() && item.getSize() > 0) {
						if (AppConstants.CONTENTTYPE_PDF.equalsIgnoreCase(item.getContentType())) {
							final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR)
									+ "/" + firmId + "_" + userId + "_" + fileId + "_" + System.currentTimeMillis()
									+ AppConstants.PDF_FILE_EXTENSION;

							final File uploadedFile = new File(inputPDFName);
							item.write(uploadedFile);

							bFile = new byte[(int) uploadedFile.length()];

							fileInputStream = new FileInputStream(uploadedFile);
							int numRead = fileInputStream.read(bFile);
							// fileInputStream.close();
							logger.info(firmId, "ESignatureService:getFileData:pdfContent:numRead:" + numRead);

							fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
							fileData.put(ESignConstants.FILE_NAME, inputPDFName);
							fileData.put(ESignConstants.FILE_CONTENT,
									AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(bFile));
						} else if (AppConstants.CONTENTTYPE_PNG.equalsIgnoreCase(item.getContentType())
								|| AppConstants.CONTENTTYPE_JPEG.equalsIgnoreCase(item.getContentType())
								|| AppConstants.CONTENTTYPE_JPG.equalsIgnoreCase(item.getContentType())) {
							final String fileExtension = AppConstants.CONTENTTYPE_PNG
									.equalsIgnoreCase(item.getContentType())
											? AppConstants.PNG_FILE_EXTENSION
											: AppConstants.CONTENTTYPE_JPEG.equalsIgnoreCase(item.getContentType())
													? AppConstants.JPEG_FILE_EXTENSION
													: AppConstants.CONTENTTYPE_JPG.equalsIgnoreCase(
															item.getContentType()) ? AppConstants.JPG_FILE_EXTENSION
																	: AppConstants.PNG_FILE_EXTENSION;

							final String createdInputImg = ApplicationProperties
									.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId + "_" + userId + "_"
									+ fileId + "_" + System.currentTimeMillis() + fileExtension;

							final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR)
									+ "/" + firmId + "_" + userId + "_" + fileId + "_" + System.currentTimeMillis()
									+ AppConstants.PDF_FILE_EXTENSION;

							final File uploadedPngFile = new File(createdInputImg);
							item.write(uploadedPngFile);

							final PDDocument document = new PDDocument();
							final FileInputStream in = new FileInputStream(createdInputImg);
							final BufferedImage bimg = ImageIO.read(in);

							float width = BigDecimal.valueOf(bimg.getWidth() / 4.5).floatValue();
							float height = BigDecimal.valueOf(bimg.getHeight() / 4.5).floatValue();
							final PDPage page = new PDPage(new PDRectangle(width, height));
							document.addPage(page);

							final PDImageXObject img = PDImageXObject.createFromFile(createdInputImg, document);
							final PDPageContentStream contentStream = new PDPageContentStream(document, page);
							contentStream.drawImage(img, 0, 0, width, height);
							contentStream.close();
							in.close();
							document.save(inputPDFName);
							document.close();

							final File inputPDFNameFile = new File(inputPDFName);
							fileInputStream = new FileInputStream(inputPDFName);
							byte[] bytes = new byte[(int) inputPDFNameFile.length()];
							int readedBytes = fileInputStream.read(bytes);
							logger.info(firmId, "ESignatureService:getFileData:pdfContent:readedBytes:" + readedBytes);

							fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
							fileData.put(ESignConstants.FILE_NAME, inputPDFName);
							fileData.put(ESignConstants.FILE_CONTENT,
									AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(bytes));

						} else if ("application/octet-stream".equalsIgnoreCase(item.getContentType())) {
							// For Library Templates
							final String inputHTMLName = ApplicationProperties
									.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId + "_" + userId + "_"
									+ fileId + "_" + System.currentTimeMillis() + ".html";

							final File uploadedFile = new File(inputHTMLName);
							item.write(uploadedFile);

							bFile = new byte[(int) uploadedFile.length()];

							fileInputStream = new FileInputStream(uploadedFile);
							int numRead = fileInputStream.read(bFile);
							// fileInputStream.close();
							logger.info(firmId, "ESignatureService:getFileData:octetStream:numRead:" + numRead);

							final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR)
									+ "/" + firmId + "_" + userId + "_" + fileId + "_" + System.currentTimeMillis()
									+ AppConstants.PDF_FILE_EXTENSION;

							final String result = convertHtmlToPDF(firmId, inputHTMLName, inputPDFName);

							if (AppConstants.RESULT_STATUS_SUCCESS.equalsIgnoreCase(result)) {
								final File inputPDFFile = new File(inputPDFName);

								final FileInputStream pdfInputStream = new FileInputStream(inputPDFFile);
								byte[] pdfbyte = new byte[(int) inputPDFFile.length()];
								numRead = pdfInputStream.read(pdfbyte);

								logger.info(firmId, "ESignatureService:getFileData:num read from pdf:" + numRead);
								pdfInputStream.close();

								fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
								fileData.put(ESignConstants.FILE_NAME, inputPDFName);
								fileData.put(ESignConstants.FILE_CONTENT,
										AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(pdfbyte));
							} else {
								fileData.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
							}
						} else {
							final String inputFileName = ApplicationProperties
									.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId + "_" + userId + "_"
									+ fileId + "_" + System.currentTimeMillis() + mfd.getName();

							final File uploadedFile = new File(inputFileName);
							item.write(uploadedFile);

							bFile = new byte[(int) uploadedFile.length()];

							fileInputStream = new FileInputStream(uploadedFile);
							int numRead = fileInputStream.read(bFile);
							// fileInputStream.close();
							logger.info(firmId, "ESignatureService:getFileData:numRead:" + numRead);
							fileData = convertDocToPdf(firmId, userId, documentId, mfd, bFile);

							final Path createInputPDF = Paths.get(inputFileName);
							Files.deleteIfExists(createInputPDF);
						}
					}
				} catch (Exception exception) {
					logger.error(firmId, "ESignatureService:saveFile:exception while writing file:", exception);
				} finally {
					if (fileInputStream != null) {
						try {
							fileInputStream.close();
						} catch (IOException e) {
							logger.error(firmId, "ESignatureService:getFileData:IOException:e:", e);
						}
					}
				}
			}
		}
		return fileData;
	}

	/**
	 * This method used to save the eSignDocument,
	 * while uploading the document in sign.co.
	 *
	 * @param firmId
	 * @param userId
	 * @param objectId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> save(final Long firmId, final Long userId, final Long objectId, final UserData userData,
			final HttpServletRequest request) {
		final String eSignDocumentData = AppHttpUtil.getStringParameter(request,
				ESignConstants.REQUEST_PARAM_ESIGN_DOCUMENT_DATA, "");
		final String signType = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_SIGN_TYPE, "");
		final String clientIpAddress = AppHttpUtil.getClientIPAddress(request);
		final String userAgent = AppHttpUtil.getUserAgent(request);
		final HttpSession session = request.getSession();

		final Map<String, Object> result = new HashMap<>();

		Map<String, Object> planDetails = new HashMap<>();
		if (!ESignConstants.UPLOAD_TEMPLATE.equalsIgnoreCase(signType)) {
			planDetails = getPlanInformation(firmId, userData);

			if (planDetails == null) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
				result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_PLAN_ERRROR);
				return result;
			}

			final Long remainingDCount = (Long) planDetails.get(AppConstants.REMAINING_DOC_COUNT);
			final Long remainingDocCount = remainingDCount != null ? remainingDCount : 0L;
			if (remainingDocCount <= 0L) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
				result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_DOC_LIMIT_EXISTS);
			} else if (AppConstants.YES.equals(planDetails.get(AppConstants.IS_TRIAL_EXPIRED))) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
				result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_TRAIL_PLAN_EXPIRED);
			}  else if (AppConstants.YES.equals(planDetails.get(AppConstants.IS_PLAN_EXPIRED))) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
				result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_PLAN_EXPIRED);
			}

			if (result.get(AppConstants.RESULT_STATUS) != null) {
				return result;
			}
		}

		try {
			final IdxESignDocument idxDocument = AppUtil.convertFromJson(IdxESignDocument.class, eSignDocumentData);

			final SimpleDateFormat sdfWithoutTimezone = DateUtil.getEsDateFormat();
			final String currentDate = sdfWithoutTimezone.format(new Date());

			idxDocument.seteSignDocumentId(
					AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_DOCUMENT_ID));
			idxDocument.setCreatedBy(userId);
			idxDocument.setLastUpdatedBy(userId);
			idxDocument.setCreationDate(currentDate);
			idxDocument.setLastUpdateDate(currentDate);
			idxDocument.setCreatedByName(userData.getFullName());
			idxDocument.setLastUpdatedByName(userData.getFullName());
			idxDocument.setFirmId(firmId);
			idxDocument.setObjectStatus(AppConstants.OBJECT_STATUS_ACTIVE);
			idxDocument.setSignType(signType);

			if (idxDocument.getDocumentData() != null) {
				idxDocument.setDocumentData(
						URLDecoder.decode(idxDocument.getDocumentData(), AppConstants.URI_ENCODER_FORMAT));
			}

			if (idxDocument.getDocumentName() != null) {
				idxDocument.setDocumentName(
						URLDecoder.decode(idxDocument.getDocumentName(), AppConstants.URI_ENCODER_FORMAT));
			}
			idxDocument.setIsSent(false);

			idxDocument.setSource(idxDocument.getSource());
			idxDocument.setFileId(idxDocument.getFileId());
			idxDocument.setFileExt(idxDocument.getFileExt());

			final IdxObject senderDetails = new IdxObject();
			senderDetails.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
			senderDetails.setObjectRefId(userData.getEmployeeId());
			senderDetails.setObjectRefName(userData.getFullName());
			senderDetails.setEmailId(userData.getEmailId());
			senderDetails.setSourceRefId(userData.getUserId().toString());
			idxDocument.setSenderDetails(senderDetails);

			idxDocument.getAssignees().add(senderDetails);

			final IdxObject associatedObject = new IdxObject();
			associatedObject.setType(ESignConstants.DOCUMENT_PAPER_SIZE_A4);
			associatedObject.setObjectId(objectId);
			associatedObject.setObjectRefId(idxDocument.geteSignDocumentId());
			associatedObject.setObjectRefName(idxDocument.getDocumentName());
			idxDocument.setAssociatedObject(associatedObject);

			if (ESignConstants.SIGN_OWN.equals(idxDocument.getSignType())) {
				createDefaultSigner(idxDocument);
			} else if (ESignConstants.UPLOAD_TEMPLATE.equals(idxDocument.getSignType())) {
				createDefaultSigner(idxDocument);
				idxDocument.setIsTemplate(true);
			} else {
				logger.info(firmId, "ESignatureService:save:in else block:");
			}

			Map<String, Object> fileStatus = null;

			Map<String, Object> fileData = null;
			String filePath = null;

			// For First Level Phase - we're using PDF base64 from request
			if (idxDocument.getDocumentData() != null) {
				fileStatus = prepareESignDocumentPage(firmId, userId, idxDocument, null, idxDocument.getDocumentData());
			} else {
				// Multi-file Details
				final IdxObject mfd = new IdxObject();
				mfd.setId(0L);
				mfd.setName(idxDocument.getDocumentName());
				mfd.setSrc(idxDocument.getSource());
				mfd.setExt(idxDocument.getFileExt());

				fileData = getFileData(firmId, userId, idxDocument.geteSignDocumentId(), mfd, request);

				if (AppConstants.RESULT_STATUS_FAILURE.equals(fileData.get(AppConstants.RESULT_STATUS).toString())) {
					if (fileData.get(AppConstants.RESULT_REASON).toString() != null) {
                        result.put(AppConstants.STR_ERROR_CODE, fileData.get(AppConstants.STR_ERROR_CODE).toString());
                        result.put(AppConstants.RESULT_REASON, fileData.get(AppConstants.RESULT_REASON).toString());
                    }
					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
					return result;
				}

				filePath = (String) fileData.get(ESignConstants.FILE_NAME);

				final String fileContent = (String) fileData.get(ESignConstants.FILE_CONTENT);

				final String revId = idxDocument.geteSignDocumentId().toString() + "_0";
				saveESignDocRevision(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId, fileContent);

				fileStatus = calculateTotalPages(firmId, filePath);

				if (fileStatus != null
						&& AppConstants.RESULT_STATUS_SUCCESS.equals(fileStatus.get(AppConstants.RESULT_STATUS).toString())) {
					idxDocument.setTotalPages((long) fileStatus.get(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES));
					mfd.setPc(idxDocument.getTotalPages());
					idxDocument.getMfd().add(mfd);
				}
			}

			if (fileStatus != null &&
					AppConstants.RESULT_STATUS_FAILURE.equals(fileStatus.get(AppConstants.RESULT_STATUS).toString())) {
				return fileStatus;
			}

			createESignatureHistory(firmId, idxDocument, null, AppConstants.ESIGN_UPLOAD,
					AppConstants.ESIGN_DESC_UPLOAD, clientIpAddress, userAgent, null);

			updateESignDocument(firmId, idxDocument);

			// Storing Pages in IdxDocument
			if (fileData != null) {
				final PrepareDocPagesThread pageThread = new PrepareDocPagesThread(firmId, userId, filePath,
						idxDocument, session, idxDocument.getMfd().get(0));
				final Thread thread = new Thread(pageThread);
				thread.start();
			} else if (idxDocument.getDocumentData() != null) {
				final List<IdxEsignDocumentPage> idxESignDocPages = new ArrayList<>();
				idxESignDocPages.add(idxDocument.getDocumentPages().get(0));
				idxDocument.setDocumentPages(idxESignDocPages);
			}

			idxDocument.setDocumentData("");

			// Updating the doc count in firm plan history
			if (!ESignConstants.UPLOAD_TEMPLATE.equalsIgnoreCase(signType)) {
				final IdxFirmPlanHistory idxFirmPlanHistory = AppUtil.convertFromJson(IdxFirmPlanHistory.class,
						planDetails.get(AppConstants.CURRENT_PLAN_DETAILS).toString());
				idxFirmPlanHistory.setDocCount(idxFirmPlanHistory.getDocCount() - 1);
				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_HR_FIRM_PLAN_HISTORY,
						idxFirmPlanHistory.getFirmPlanHistoryId(), AppUtil.convertToJson(idxFirmPlanHistory));
			}

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			result.put(AppConstants.RESULT_DATA, idxDocument);
			result.put(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES, idxDocument.getTotalPages());
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:save:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to add the multi file
	 *
	 * @param firmId
	 * @param userId
	 * @param request
	 * @return
	 */
	public Map<String, Object> addMultiFile(final Long firmId, final Long userId, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String mfdata = AppHttpUtil.getStringParameter(request,ESignConstants.MFD, "");
		final HttpSession session = request.getSession();

		final Map<String, Object> result = new HashMap<>();

		try {
			final IdxObject mfd = AppUtil.convertFromJson(IdxObject.class, mfdata);

			final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);

			Map<String, Object> fileStatus = null;

			String filePath = null;

			final Map<String, Object> fileData = getFileData(firmId, userId, documentId, mfd, request);

			if (fileData != null && AppConstants.RESULT_STATUS_FAILURE.equals(fileData.get(AppConstants.RESULT_STATUS).toString())) {
				if (fileData.get(AppConstants.RESULT_REASON).toString() != null) {
					result.put(AppConstants.STR_ERROR_CODE, fileData.get(AppConstants.STR_ERROR_CODE).toString());
					result.put(AppConstants.RESULT_REASON, fileData.get(AppConstants.RESULT_REASON).toString());
				}
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				return result;
			}
			
			if(fileData == null)
			{
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				return result;
			}

			filePath = (String) fileData.get(ESignConstants.FILE_NAME);

			final String fileContent = (String) fileData.get(ESignConstants.FILE_CONTENT);

			final String revId = idxESignDocument.geteSignDocumentId().toString() + "_" + mfd.getId();
			saveESignDocRevision(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId, fileContent);

			fileStatus = calculateTotalPages(firmId, filePath);

			if (fileStatus != null && AppConstants.RESULT_STATUS_FAILURE
					.equals(fileStatus.get(AppConstants.RESULT_STATUS).toString())) {
				return fileStatus;
			}

			if (fileStatus != null
					&& AppConstants.RESULT_STATUS_SUCCESS.equals(fileStatus.get(AppConstants.RESULT_STATUS).toString())) {
				final Long totalPages = idxESignDocument.getTotalPages() + (long) fileStatus.get(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES);
				idxESignDocument.setTotalPages(totalPages);
				mfd.setPc((long) fileStatus.get(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES));
				idxESignDocument.getMfd().add(mfd);
			}

			updateESignDocument(firmId, idxESignDocument);

			final PrepareDocPagesThread pageThread = new PrepareDocPagesThread(firmId, userId, filePath,
					idxESignDocument, session, mfd);
			final Thread thread = new Thread(pageThread);
			thread.start();

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			result.put(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES, idxESignDocument.getTotalPages());
			result.put(ESignConstants.MFD, idxESignDocument.getMfd());
			return result;
		} catch(VersionConflictEngineException exception) {
			logger.error(firmId, "ESignatureService:addMultiFile:exception:", exception);
			addMultiFile(firmId, userId, request);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:addMultiFile:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to remove the multi File
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> removeMultiFile(final Long firmId, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String mfdata = AppHttpUtil.getStringParameter(request,ESignConstants.MFD, "");
		final Integer totalPages = AppHttpUtil.getIntParameter(request, ESignConstants.TOTAL_PAGES, null);

		final Map<String, Object> result = new HashMap<>();

		try {
			final IdxObject mfd = AppUtil.convertFromJson(IdxObject.class, mfdata);

			final Map<String, Object> scriptParams = new HashMap<>();
			scriptParams.put(AppConstants.FIRM_ID, firmId);
			scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
			scriptParams.put(AppConstants.ID, mfd.getId());
			scriptParams.put("pc", mfd.getPc());
			scriptParams.put(ESignConstants.TOTAL_PAGES, totalPages);

			final StringBuilder updateScript = new StringBuilder();
			updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
					+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

			updateScript.append("for (int i = 0; i < ctx._source.documentPages.size(); i++) {");

			updateScript.append("if(ctx._source.documentPages[i].sId > params.id) {");
			updateScript.append("ctx._source.documentPages[i].pageNumber -= params.pc;");
			updateScript.append("}");

			updateScript.append("if(ctx._source.documentPages[i].sId == params.id) {");
			updateScript.append("ctx._source.documentPages.remove(i);");
			updateScript.append("i--;");
			updateScript.append("}");

			updateScript.append("}");

			updateScript.append("for (int i = 0; i < ctx._source.mfd.size(); i++) {");
			updateScript.append("if(ctx._source.mfd[i].id == params.id) {");
			updateScript.append("ctx._source.mfd.remove(i);");
			updateScript.append("break;");
			updateScript.append("}");	
			updateScript.append("}");

			updateScript.append("ctx._source.totalPages = params.totalPages;");
			updateScript.append("}");

			final UpdateRequestBuilder updateRequestBuilder = ElasticSearchDAO
					.getInstance().getClient(firmId).prepareUpdate(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(),
							ESConstants._DOCS, documentId.toString())
					.setRouting(AppBaseDAO.getInstance().getShardId(firmId));
			updateRequestBuilder.setScript(
					ESAPIUtil.createScriptObject(updateScript.toString(), ScriptType.INLINE, null, scriptParams))
					.execute().actionGet();

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			return result;
		} catch(VersionConflictEngineException exception) {
			logger.error(firmId, "ESignatureService:removeMultiFile:exception:", exception);
			removeMultiFile(firmId, request);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:removeMultiFile:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to update the document while preparing - edit template
	 *
	 * @param firmId
	 * @param userId
	 * @param request
	 * @return
	 */
	public Map<String, Object> update(final Long firmId, final Long userId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();
		try {
			final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID,
					null);
			final String mfdata = AppHttpUtil.getStringParameter(request, ESignConstants.MFD, null);

			final IdxObject mfd = AppUtil.convertFromJson(IdxObject.class, mfdata);

			final String[] includeFields = {};
			final String[] excludeFields = { ESignConstants.ESIGN_DOCUMENT_DATA };

			final IdxESignDocument idxDocument = getDocument(firmId, documentId, includeFields, excludeFields);

			final HttpSession session = request.getSession();
			session.setAttribute(ESignConstants.ESIGN_DOCUMENT_CONV_PAGES + documentId + "_" + mfd.getId(), null);

			final Long oldTotalPages = idxDocument.getTotalPages() - mfd.getPc();

			final Map<String, Object> fileData = getFileData(firmId, userId, documentId, mfd, request);

			if (AppConstants.RESULT_STATUS_FAILURE.equals(fileData.get(AppConstants.RESULT_STATUS).toString())) {
				if (fileData.get(AppConstants.RESULT_REASON).toString() != null) {
					result.put(AppConstants.STR_ERROR_CODE, fileData.get(AppConstants.STR_ERROR_CODE).toString());
					result.put(AppConstants.RESULT_REASON, fileData.get(AppConstants.RESULT_REASON).toString());
				}
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				return result;
			}

			final String filePath = (String) fileData.get(ESignConstants.FILE_NAME);

			final String fileContent = (String) fileData.get(ESignConstants.FILE_CONTENT);

			final String revId = idxDocument.geteSignDocumentId().toString() + "_" + mfd.getId(); 
			final IdxESignDocRevisions idxDocRev = getESignDocReviByObjRefId(firmId,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, revId);
			if (idxDocRev != null) {
				idxDocRev.setDocData(fileContent);
				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESIGN_DOC_REVISIONS,
						idxDocRev.getId(), AppUtil.convertToJson(idxDocRev));
			} else {
				saveESignDocRevision(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId, fileContent);
			}

			final Map<String, Object> fileStatus = calculateTotalPages(firmId, filePath);

			if (fileStatus != null && AppConstants.RESULT_STATUS_FAILURE
					.equals(fileStatus.get(AppConstants.RESULT_STATUS).toString())) {
				return fileStatus;
			}

			if (fileStatus != null
					&& AppConstants.RESULT_STATUS_SUCCESS.equals(fileStatus.get(AppConstants.RESULT_STATUS).toString())) {
				final Long currentFileTotalPages = (long) fileStatus.get(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES);
				final Long totalPages = oldTotalPages + currentFileTotalPages;
				idxDocument.setTotalPages(totalPages);

				final IdxObject currentMfd = idxDocument.getMfdById(mfd.getId());
				if(currentMfd != null) {
					currentMfd.setPc(currentFileTotalPages);
				}
			}

			logger.info(firmId, "ESignatureService:update:mfd.getId():" + mfd.getId());

			// Resetting document Page's
			for (int i = 0; i < idxDocument.getDocumentPages().size(); i++) {
				final IdxEsignDocumentPage ideESignDocument = idxDocument.getDocumentPages().get(i);
					if (mfd.getId().equals(ideESignDocument.getsId())) {
						idxDocument.getDocumentPages().remove(i);
						i--;
					}
			}

			final IdxESignDocument oldIdx = (IdxESignDocument) idxDocument.clone();

			updateESignDocument(firmId, idxDocument);

			// Storing Pages in IdxDocument
			final PrepareDocPagesThread pageThread = new PrepareDocPagesThread(firmId, userId, filePath,
					oldIdx, session, mfd);
			final Thread thread = new Thread(pageThread);
			thread.start();

			idxDocument.setDocumentData("");
			idxDocument.setDocumentPages(null);

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			result.put(AppConstants.RESULT_DATA, idxDocument);
			result.put(ESignConstants.RESPONSE_PARAM_TOTAL_PAGES, idxDocument.getTotalPages());
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:update:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to delete the esignAttributes by unique id.
	 *
	 * @param firmId
	 * @param documentId
	 * @param strUniqueIds
	 * @return
	 */
	public IdxESignDocument deleteESignAttributeByUniqueId(final Long firmId, final Long documentId,
			final String strUniqueIds) {
		final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);

		if (idxESignDocument != null) {
			List<Long> uniqueIds = new ArrayList<>();
			if (strUniqueIds != null) {
				final NumberHelper numHelper = new Gson().fromJson(strUniqueIds, NumberHelper.class);
				uniqueIds = numHelper.getId();
			}

			for (IdxEsignDocumentPage idxESignDocumentPage : idxESignDocument.getDocumentPages()) {
				for (int i = 0; i < idxESignDocumentPage.geteSignAttributes().size(); i++) {
					IdxEsignAttribute idxESignAttribute = idxESignDocumentPage.geteSignAttributes().get(i);
					int isExist = uniqueIds.indexOf(idxESignAttribute.getUniqueId());
					if (isExist > -1) {
						uniqueIds.remove(isExist);
						idxESignDocumentPage.geteSignAttributes().remove(i);
						i--;
					}
				}
			}
			updateESignDocument(firmId, idxESignDocument);
		}
		return idxESignDocument;
	}

	/**
	 * This method used to save the signatures with limit of 6.
	 *
	 * @param firmId
	 * @param signatureData
	 * @return
	 */
	public IdxObjectSign saveSignature(final Long firmId, final String signatureData) {
		IdxObjectSign signature = AppUtil.convertFromJson(IdxObjectSign.class, signatureData);

		try {
			signature = prepareIdxObjectSign(firmId, signature);
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			signature.setCreationDate(currentDate);
			signature.setLastUpdateDate(currentDate);
			signature.setDateLastUsed(currentDate);

			signature.setSignature(URLDecoder.decode(signature.getSignature(), AppConstants.URI_ENCODER_FORMAT));

			indexSignature(signature);
			return signature;
		} catch (UnsupportedEncodingException exception) {
			logger.error(firmId, "ESignatureService:saveSignature:UnsupportedEncodingException:", exception);
		} catch (Exception exception) {
			logger.info(firmId, "ESignatureService:saveSignature:exception:" + exception);
		}
		return null;
	}

	/**
	 * This method used to save the re-arranged order of signature types
	 *
	 * @param firmId
	 * @param signatureTypes
	 * @return
	 */
	public IdxESignConfiguration reArrangeSignatureTypes(final Long firmId, final String signatureTypes) {
		try {
			final JSONParser parser = new JSONParser();
			final JSONArray signatureTypesArray = (JSONArray) parser.parse(signatureTypes);
			final List<IdxLookup> signatureTypesList = new ArrayList<>();
			for (int index = 0; index < signatureTypesArray.size(); index++) {
				JSONObject signTypes = (JSONObject) signatureTypesArray.get(index);
				IdxLookup eSignsignatureTypes = AppUtil.convertFromJson(IdxLookup.class, signTypes.toJSONString());
				signatureTypesList.add(eSignsignatureTypes);
			}
			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);
			idxESignConfiguration.setSignatureTypes(signatureTypesList);

			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));

			return idxESignConfiguration;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:reArrangeSignatureTypes:exception:", exception);
		}
		return null;
	}

	/**
	 * This method used to update the document by painless script
	 *
	 * @param <T>
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @param updateString
	 * @param params
	 * @param getDoc
	 * @param clazz
	 * @return
	 */
	public <T> T updateDocumentByScript(final Long firmId, final Long objectId, final String objectRefId,
			final String updateString, final Map<String, Object> params, final boolean getDoc,
			final Class<T> clazz) {
		final UpdateRequestBuilder request = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareUpdate(objectId.toString(), ESConstants._DOCS, objectRefId);

		if ((firmId != null) && (firmId > 0L)) {
			request.setRouting(AppBaseDAO.getInstance().getShardId(firmId));
		}
		UpdateResponse response = null;
		try {
			response = request.setScript(ESAPIUtil.createScriptObject(updateString, ScriptType.INLINE, null, params))
					.execute().actionGet();
		} catch (VersionConflictEngineException exception) {
			logger.error(firmId, "ESignatureService:updateDocumentByScript:version conflict exception:", exception);
			return updateDocumentByScript(firmId, objectId, objectRefId, updateString, params, getDoc, clazz);
		} catch (IllegalArgumentException exception) {
			logger.error("ESignatureService:updateDocumentByScript:Exception::", exception);
		} catch (Exception e) {
			logger.error("ESignatureService:updateDocumentByScript:Exception::", e);
		}

		if (getDoc) {
			if (response != null && response.getGetResult() != null) {
				return AppUtil.convertFromJson(clazz, response.getGetResult().sourceAsString());
			} else {
				return ElasticSearchDAO.getInstance().getDocument(firmId, clazz, objectId, objectRefId);
			}
		}
		return null;
	}

	/**
	 * This method used to get the document page by docmentId and pageNumber
	 *
	 * @param firmId
	 * @param documentId
	 * @param pageNumber
	 * @return
	 */
	public IdxEsignDocumentPage getDocumentPage(final Long firmId, final Long documentId, final Long pageNumber) {
		final String[] include = { AppConstants.FIRM_ID, ESignConstants.ESIGN_DOCUMENT_ID };
		final String[] exclude = {};

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString()).setSize(1)
				.setFetchSource(include, exclude);

		final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
		boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		boolQueryBuilder.must(QueryBuilders.termQuery(ESignConstants.ESIGN_DOCUMENT_ID, documentId));

		// To get the 0th index of document page alone in document.
		final InnerHitBuilder innerHitBuilder = new InnerHitBuilder(ESignConstants.ESIGN_DOCUMENT_PAGES);
		innerHitBuilder.setSize(1);
		innerHitBuilder.setFrom(pageNumber.intValue());
		final NestedQueryBuilder nestedQueryBuilder = QueryBuilders
				.nestedQuery(ESignConstants.ESIGN_DOCUMENT_PAGES, QueryBuilders.matchAllQuery(), ScoreMode.Total)
				.innerHit(innerHitBuilder);
		boolQueryBuilder.must(nestedQueryBuilder);

		builder.setQuery(boolQueryBuilder);
		logger.info(firmId, "ESignatureService:getDocumentPage:builder:" + builder.toString());

		final SearchResponse hits = builder.execute().actionGet();
		for (SearchHit hit : hits.getHits()) {
			// getting the inner hits of the document.
			final SearchHits innerHits = hit.getInnerHits().get(ESignConstants.ESIGN_DOCUMENT_PAGES);
			for (SearchHit innerhit : innerHits) {
				if (innerhit != null && innerhit.getSourceAsString() != null) {
					return AppUtil.convertFromJson(IdxEsignDocumentPage.class, innerhit.getSourceAsString());
				}
			}
		}
		return null;
	}

	/**
	 * This method used to update the document page by document  - painless script
	 *
	 * @param firmId
	 * @param documentId
	 * @param pageNumber
	 * @param idxEsignDocumentPage
	 * @return
	 */
	public IdxESignDocument updateDocumentPage(final Long firmId, final Long documentId, final int pageNumber,
			final IdxEsignDocumentPage idxEsignDocumentPage) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
		scriptParams.put(ESignConstants.PAGE_NUMBER, pageNumber);

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		try {
			scriptParams.put("idxEsignDocumentPage",
					new ObjectMapper().readValue(AppUtil.formatUrl(idxEsignDocumentPage), HashMap.class));
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateDocumentPage:exception:", exception);
		}
		updateScript.append("ctx._source.documentPages[params.pageNumber] = params.idxEsignDocumentPage;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to update the document page by document  - painless script
	 *
	 * @param firmId
	 * @param documentId
	 * @param vc
	 * @return
	 */
	public IdxESignDocument updateVC(final Long firmId, final Long documentId, final String vc) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
		scriptParams.put(ESignConstants.VC, vc);

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		updateScript.append("ctx._source.vc = params.vc;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to update the sender details by painless script
	 *
	 * @param firmId
	 * @param documentId
	 * @param senderDetails
	 * @return
	 */
	public IdxESignDocument updateSenderDetailsByScript(final Long firmId, final Long documentId, final IdxObject senderDetails) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		try {
			scriptParams.put("senderDetails",
					new ObjectMapper().readValue(AppUtil.formatUrl(senderDetails), HashMap.class));
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateSenderDetailsByScript:exception:", exception);
		}
		updateScript.append("ctx._source.senderDetails = params.senderDetails;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to save the e-sign attribute in eSignDocument
	 *
	 * @param firmId
	 * @param documentId
	 * @param eSignAttribute
	 * @param isNew
	 * @param signatureId
	 * @param vc
	 * @param attrActionObj
	 * @return
	 *
	 * @reference Bug 239683
	 * @date Dec 8,2022
	 * @author  Kanishka
	 */
	public String saveESignAttribute(final Long firmId, final Long documentId, final String eSignAttribute,
			final boolean isNew, final String signatureId, final String vc, final String attrActionObj) {
		try {
			final List<IdxEsignAttribute> esignAttributeValue = new Gson().fromJson(eSignAttribute,
					new TypeToken<List<IdxEsignAttribute>>() {
					}.getType());

			final Map<String, String> attrActionValue = new Gson().fromJson(attrActionObj,
					new TypeToken<Map<String, String>>() {
					}.getType());

			// Created list for maintaining the - add and update Attributes.
			final List<String> addAttribute = new ArrayList<>();
			final List<String> updateAttribute = new ArrayList<>();

			// Add attributes key in the list
			for (Map.Entry<String, String> entry : attrActionValue.entrySet()) {
				// Checking attribute actions based on ('S' / 'U')
				if (isNew || ESignConstants.ATTR_ACTION_SAVE.equals(entry.getValue())) {
					addAttribute.add(entry.getKey());
				} else if (!isNew || ESignConstants.ATTR_ACTION_UPDATE.equals(entry.getValue())) {
					updateAttribute.add(entry.getKey());
				}
			}

			// Decoding the eSignAttribute Values based on the URI Encoder Format.
			for (IdxEsignAttribute eSignattribute : esignAttributeValue) {
				// Check eSignattribute is Not Null & Not Empty
				if (AppUtil.checkStringNullOrNot(eSignattribute.getValue())) {
					// Decoding the eSignattributeValues
					final String decodedValue = URLDecoder.decode(eSignattribute.getValue(), AppConstants.URI_ENCODER_FORMAT);
					eSignattribute.setValue(decodedValue);
				} else {
					eSignattribute.setValue("");
				}
			}

			// Updating the eSignAttributes by Script in IdxESignDocument.
			final IdxESignDocument updateDocument = updateEsignAttributeByScript(firmId, documentId,
					esignAttributeValue, addAttribute, updateAttribute, isNew);

			if (updateDocument != null) {
				// Updating the Last Used Signature Details in OBJECT_SAVED_SIGNATURES if signatureid is not null.
				if (signatureId != null) {
					updateLastUsedSignature(firmId, signatureId);
				}

				// Updating the visibility condition details in eSignDocument.
				updateVC(firmId, documentId, vc);

				return AppConstants.STATUS_CODE_SUCCESS;
			} else {
				return AppConstants.STATUS_CODE_FAILURE;
			}

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:saveEsignAttribute:exception:", exception);
		}
		return AppConstants.STATUS_CODE_FAILURE;
	}

	/**
	 * This method used to delete the e-sign document
	 *
	 * @param firmId
	 * @param documentId
	 * @return
	 */
	public String delete(final Long firmId, final Long documentId) {
		final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);
		if (idxESignDocument != null) {
			idxESignDocument.setObjectStatus(AppConstants.OBJECT_STATUS_INACTIVE);
			updateESignDocument(firmId, idxESignDocument);
			return AppConstants.RESULT_STATUS_SUCCESS;
		}
		logger.info(firmId, "EsignatureService:delete:document is Empty:" + documentId);
		return AppConstants.STATUS_CODE_FAILURE;
	}

	/**
	 * This method used to delete the e-sign document from es.
	 *
	 * @param firmId
	 * @param documentId
	 * @param isFrom
	 * @param userData
	 * @return
	 */
	public String deleteForever(final Long firmId, final Long documentId, final String isFrom,
			final UserData userData) {
		final String[] include = {};
		final String[] exclude = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_SIGNERS,
				ESignConstants.ESIGN_SENDER_DETAILS, ESignConstants.ESIGN_DOCUMENT_PAGES };
		final IdxESignDocument idxESignDocument = getDocument(firmId, documentId,
				include, exclude);
		if (idxESignDocument != null) {
			ElasticSearchDAO.getInstance().deleteDocument(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);

			final Map<String, Object> planDetails = getPlanInformation(firmId, userData);
			if (planDetails!= null && ESignConstants.SOURCE_UPLOAD.equalsIgnoreCase(isFrom)) {
				final IdxFirmPlanHistory idxFirmPlanHistory = AppUtil.convertFromJson(IdxFirmPlanHistory.class,
						planDetails.get(AppConstants.CURRENT_PLAN_DETAILS).toString());
				idxFirmPlanHistory.setDocCount(idxFirmPlanHistory.getDocCount() + 1);
				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_HR_FIRM_PLAN_HISTORY,
						idxFirmPlanHistory.getFirmPlanHistoryId(), AppUtil.convertToJson(idxFirmPlanHistory));
			}
			return AppConstants.RESULT_STATUS_SUCCESS;
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to restore the e-sign document.
	 *
	 * @param firmId
	 * @param documentId
	 * @return
	 */
	public String restore(final Long firmId, final Long documentId) {
		final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);
		if (idxESignDocument != null) {
			idxESignDocument.setObjectStatus(AppConstants.OBJECT_STATUS_ACTIVE);
			updateESignDocument(firmId, idxESignDocument);
			return AppConstants.SUCCESSS_NOTE;
		}
		logger.info(firmId, "EsignatureService:restore:document is Empty:" + documentId);
		return AppConstants.STATUS_CODE_FAILURE;

	}

	/**
	 * This method used to sign document based on the sign type
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> signDocument(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String eSignAttributes = AppHttpUtil.getStringParameter(request,
				ESignConstants.REQUEST_PARAM_ESIGN_ATTRIBUTE, "");
		final String isSignOwn = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_IS_SIGN_OWN,
				AppConstants.BOOLEAN_FALSE);
		final boolean isTemplate = AppHttpUtil.getBooleanParameter(request, ESignConstants.IS_TEMPLATE, false);
		final boolean isSequential = AppHttpUtil.getBooleanParameter(request, ESignConstants.IS_SEQUENTIAL, false);
		final String customSubject = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_SUBJECT, "");
		final String customMessage = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_MESSAGE, "");

		final BigDecimal windowWidth = AppHttpUtil.getBigDecimalParameter(request, ESignConstants.REQUEST_PARAM_WINDOW_WIDTH, null);
		final BigDecimal windowHeight = AppHttpUtil.getBigDecimalParameter(request, ESignConstants.REQUEST_PARAM_WINDOW_HEIGHT, null);

		final String expiryDate = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_EXPIRY_DATE, null);

		/**
		 * For, Sign-Own is Completed or not. Send-Sign and In-Person Sign - If sender
		 * is the only one signer in that document.
		 */
		final boolean isCompleted = AppHttpUtil.getBooleanParameter(request, ESignConstants.IS_COMPLETED, false);

		final String vc = AppHttpUtil.getStringParameter(request, ESignConstants.VC, null);
		final String recipient = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_RECIPIENTS, null);
		final String brandId = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_BRAND_ID, null);

		final Map<String, Object> results = new HashMap<>();
		try {
			final String clientIpAddress = AppHttpUtil.getClientIPAddress(request);
			final String userAgent = AppHttpUtil.getUserAgent(request);
			final String creationDate = DateUtil.getEsDateFormat().format(new Date());

			final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);
			idxESignDocument.setIsSequential(isSequential);
			idxESignDocument.setIsSent(true);

			idxESignDocument.setWindowWidth(windowWidth);
			idxESignDocument.setWindowHeight(windowHeight);

			// Setting expiry date for the esign document
			if (expiryDate != null) {
				final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(userData.getDatePattern());
				final Date parsedDate = DateUtil.parseDate(expiryDate, simpleDateFormat, null);
				final SimpleDateFormat esFormat = new SimpleDateFormat(DateUtil.format_mdyhms);
				String expDate = esFormat.format(DateUtil.getEndOfDay(parsedDate, userData.getTimeZone()));
				idxESignDocument.setExpDate(expDate);
			}

			if (vc != null) {
				idxESignDocument.setVc(vc);
			}

			// Setting Brand Id
			idxESignDocument.setbId(brandId);

			if (isTemplate && idxESignDocument.getTemplateName() == null) {
				idxESignDocument.setTemplateName(idxESignDocument.getDocumentName());
				idxESignDocument.setIsEnabled(true);
				idxESignDocument.setIsTemplate(true);

				// Generating the completed PDF
				if(idxESignDocument.getDocumentData() == null) {
					final Map<String, String> combinedPDFData = generateCombinedPdf(firmId, idxESignDocument);
					if (combinedPDFData != null) {
						final String revId = idxESignDocument.geteSignDocumentId().toString() + "_o";
						IdxESignDocRevisions idxDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, revId);
						if(idxDocRev == null) {
							idxDocRev = saveESignDocRevision(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId,
									combinedPDFData.get(ESignConstants.FILE_CONTENT));
						} else {
							idxDocRev.setDocData(combinedPDFData.get(ESignConstants.FILE_CONTENT));
							ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_ESIGN_DOC_REVISIONS,
									idxDocRev.getId(), AppUtil.convertToJson(idxDocRev));
						}
						saveToBlockChain(firmId, idxDocRev.getId(), idxESignDocument.getCreatedByName(),
								combinedPDFData.get(ESignConstants.FILE_NAME));
						deleteFileIfExists(firmId, combinedPDFData.get(ESignConstants.FILE_NAME));
					}
				}
			} else if (!isTemplate){
				idxESignDocument.setIsTemplate(false);
			}

			idxESignDocument.clearESignAttributes();

			if (AppConstants.BOOLEAN_TRUE.equals(isSignOwn) && idxESignDocument.getSigners().size() > 1) {
				validateSignOwnSigners(idxESignDocument);
			}

			prepareESignAttributes(idxESignDocument, eSignAttributes, isSignOwn,
					creationDate, clientIpAddress, userAgent);

			setDocumentStatusBySignType(idxESignDocument, isCompleted);

			String signedPdfBase = null;

			IdxESignSigner idxESignSigner = idxESignDocument.getSigners().get(0);

			if (isCompleted) {
				final IdxEsignatureHistory idxEsignHistory = createESignatureHistory(firmId, idxESignDocument,
						idxESignSigner, AppConstants.ESIGN_SIGNED, AppConstants.ESIGN_DESC_SIGN, clientIpAddress, userAgent, null);

				final Map<String, String> result = prepareSignedPDFInBytes(idxESignDocument);

				if (result != null) {
					// Storing PDF base for Signer Signed history
					signedPdfBase = AppConstants.BASE64_PREFIX_PDF
							+ Base64.encodeBase64String(Base64.decodeBase64(result.get(AppConstants.BYTES_CONTENT)));
					final IdxESignDocRevisions idxDocRevSigner = saveESignDocRevision(firmId,
							ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString(), idxEsignHistory.getHistoryId(), signedPdfBase);
					saveToBlockChain(idxESignDocument.getFirmId(), idxDocRevSigner.getId(),
							idxESignSigner.getObjectRefName(), result.get(AppConstants.FILE_PATH));

//					generateCompletedPDF(idxESignDocument, result, userData.getTimeZone());

					// Storing PDF base for Document completion
//					completedPdfBase = AppConstants.BASE64_PREFIX_PDF 
//							+ Base64.encodeBase64String(Base64.decodeBase64(result.get(AppConstants.BYTES_CONTENT)));
					final IdxESignDocRevisions idxDocRevCompleted = saveESignDocRevision(firmId,
							ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(),
							idxESignDocument.geteSignDocumentId().toString(), signedPdfBase);
					saveToBlockChain(idxESignDocument.getFirmId(), idxDocRevCompleted.getId(),
							idxESignSigner.getObjectRefName(), result.get(AppConstants.FILE_PATH));

					deleteFileIfExists(firmId, result.get(AppConstants.FILE_PATH));
				}
			}
			// Preparing Document URL
			final String documentUrl = getDocumentRedirectionURL(firmId,
					idxESignDocument.geteSignDocumentId(), userData.getTimeZone().getID(),
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, userData.getDatePattern());

			// signType SIGN_OWN
			if (ESignConstants.SIGN_OWN.equals(idxESignDocument.getSignType()) && isCompleted) {
				idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED.toUpperCase());
				final byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, userData.getTimeZone());
				final String[] mailAttachment = getAttachmentsForEmail(idxESignDocument, signedPdfBase, auditTrailContent);
				notifyToSigner(firmId, idxESignDocument, idxESignSigner, documentUrl, mailAttachment);
				//Forward the document once its signed
				if (recipient != null) {
					notifyToRecipients(firmId, idxESignDocument, documentUrl, recipient, customSubject, customMessage,
							mailAttachment);
				}
			}

			// SignType SEND_SIGN
			if (ESignConstants.SEND_SIGN.equals(idxESignDocument.getSignType())) {
				// Setting custom subject and custom message in idxESignDocument
				idxESignDocument.setCustomSubject(customSubject);
				idxESignDocument.setCustomMessage(customMessage);

				if (Boolean.TRUE.equals(isCompleted)) {
					idxESignSigner = idxESignDocument
							.getESignSignerByEmailId(idxESignDocument.getSenderDetails().getEmailId());
					idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED.toUpperCase());

					byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, userData.getTimeZone());
					final String[] attachments = getAttachmentsForEmail(idxESignDocument, signedPdfBase, auditTrailContent);
					notifyDocumentCompletion(firmId, idxESignDocument, null, documentUrl, attachments);
				} else {
					// Generating the completed PDF
					if(idxESignDocument.getDocumentData() == null) {
						final Map<String, String> combinedPDFData = generateCombinedPdf(firmId, idxESignDocument);
						if (combinedPDFData != null) {
							final String revId = idxESignDocument.geteSignDocumentId().toString() + "_o";
							final IdxESignDocRevisions idxESignDocRevisions = saveESignDocRevision(firmId,
									ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId,
									combinedPDFData.get(ESignConstants.FILE_CONTENT));
							saveToBlockChain(firmId, idxESignDocRevisions.getId(), idxESignDocument.getCreatedByName(),
									combinedPDFData.get(ESignConstants.FILE_NAME));
							deleteFileIfExists(firmId, combinedPDFData.get(ESignConstants.FILE_NAME));
						}
					}

					// Sending initial notification mail to CC
					notifyToCC(firmId, idxESignDocument, documentUrl, null, null, null);

					updateStatusForOwnerAsSigner(firmId, idxESignDocument, documentUrl,
							clientIpAddress, userAgent);

					// For e-sign histories timing issue - completed status coming after the sent history
					AppExceptionService.logThreadSleep(idxESignDocument.getFirmId(), null, null, AppConstants.DELAY.intValue());
					Thread.sleep(AppConstants.DELAY);

					// Requesting sign from signers through mail.
					requestSignForESign(firmId, idxESignDocument, documentUrl, false);

					for (IdxESignSigner signer : idxESignDocument.getSignerForESign()) {
						createESignatureHistory(firmId, idxESignDocument, signer,
								AppConstants.ESIGN_SENT, AppConstants.ESIGN_DESC_SENT, clientIpAddress, userAgent, null);
						signer.setSignerStatus(ESignConstants.SIGNER_STATUS_SENT.toUpperCase());
						if (Boolean.TRUE.equals(idxESignDocument.getIsSequential())) {
							break;
						}
					}
				}
			}

			// SignType IN_PERSON_SIGN
			if (ESignConstants.IN_PERSON_SIGN.equals(idxESignDocument.getSignType())) {
				final String signerStatus = isCompleted ? ESignConstants.SIGNER_STATUS_SIGNED
						: ESignConstants.SIGNER_STATUS_VIEWED;

				for (IdxESignSigner idxESigner : idxESignDocument.getSigners()) {
					idxESigner.setSignerStatus(signerStatus.toUpperCase());
				}
				results.put(AppConstants.REDIRECT_URI, documentUrl);
				if (Boolean.TRUE.equals(isCompleted)) {
					idxESignSigner = idxESignDocument
							.getESignSignerByEmailId(idxESignDocument.getSenderDetails().getEmailId());
					idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_SIGNED.toUpperCase());

					byte[] auditTrailContent = generateAuditTrailContent(idxESignDocument, userData.getTimeZone());
					final String[] attachments = getAttachmentsForEmail(idxESignDocument, signedPdfBase,
							auditTrailContent);
					notifyDocumentCompletion(firmId, idxESignDocument, null, documentUrl, attachments);
				} else {
					// Generating the combined PDF
					final Map<String, String> combinedPDFData = generateCombinedPdf(firmId, idxESignDocument);
					if (combinedPDFData != null) {
						final String revId = idxESignDocument.geteSignDocumentId().toString() + "_o";
						final IdxESignDocRevisions idxESignDocRevisions = saveESignDocRevision(firmId,
								ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), revId,
								combinedPDFData.get(ESignConstants.FILE_CONTENT));
						saveToBlockChain(firmId, idxESignDocRevisions.getId(), idxESignDocument.getCreatedByName(),
								combinedPDFData.get(ESignConstants.FILE_NAME));
						deleteFileIfExists(firmId, combinedPDFData.get(ESignConstants.FILE_NAME));
					}
				}
			}
			// For index Document
			updateESignDocument(firmId, idxESignDocument);

			// Updating latest document sent date in Apptivo Customer
			final SignDocSentDateThread pageThread = new SignDocSentDateThread(firmId);
			final Thread thread = new Thread(pageThread);
			thread.start();

			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			return results;

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:signDocument:exception:", exception);
		}
		results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		return results;
	}

    /**
    * This method used to draw label value in PDF.
    *
    * @param firmId
     * @param eSignAttribute
     * @param contents
     * @param pageHeight
    */
	@SuppressWarnings("deprecation")
	public void writeLabel(final Long firmId, final PDDocument document, final IdxEsignAttribute eSignAttribute,
			final PDPageContentStream contents, final float pageHeight, final IdxObject associatedObject) {
		try {
			final String attributeAlign = eSignAttribute.getAl().getAlign();
			final Long attrNumColums = eSignAttribute.getCl();
			final String pageFormat = associatedObject.getType();
			final boolean isLandscape = associatedObject.isLandscape();
			final String labelName = eSignAttribute.getAl().getLabelName();
			String fontFace = eSignAttribute.getAl().getLf();
			String format = isLandscape ? ESignConstants.LANDSCAPE : ESignConstants.PORTRAIT;

			if(fontFace.equalsIgnoreCase(ESignConstants.HELVETICA)){
				fontFace= fontFace.toLowerCase();
			}

			final Long fontSizeInt = Long.valueOf(eSignAttribute.getAl().getLfs().replace("px", ""));
			final Float fontSize = BigDecimal.valueOf(Long.valueOf(fontSizeInt) / 1.3).floatValue();
//			final float locY = (float) (pageHeight - (eSignAttribute.getAl().getLocY() / ESignConstants.PAGE_RATIO)) - 8;
//			float columnRight = (float) ((eSignAttribute.getLocationX() / ESignConstants.PAGE_RATIO) - 20);

			float locY = (float) ((pageHeight - (eSignAttribute.getAl().getLocY() / ESignConstants.PAGE_RATIO)) - 8);
			if(!isLandscape && ESignConstants.labelOffsetByPageFormat.get(pageFormat)
					.get(attrNumColums.intValue()).get(eSignAttribute.getSignatureType() + ESignConstants.LOC_Y) != null)
			{
				locY += ESignConstants.labelOffsetByPageFormat.get(pageFormat)
						.get(attrNumColums.intValue()).get(eSignAttribute.getSignatureType() + ESignConstants.LOC_Y);
			}
			if(isLandscape && ESignConstants.labelOffsetByPageFormatLandscape.get(pageFormat)
					.get(attrNumColums.intValue()).get(eSignAttribute.getSignatureType() + ESignConstants.LOC_Y) != null)
			{
				locY += ESignConstants.labelOffsetByPageFormatLandscape.get(pageFormat)
						.get(attrNumColums.intValue()).get(eSignAttribute.getSignatureType() + ESignConstants.LOC_Y);
			}

			final PDType0Font fontStyle = getPdfLabelFontStyle(firmId, document, eSignAttribute);

			contents.setNonStrokingColor(eSignAttribute.getAl().getLfc()[0], eSignAttribute.getAl().getLfc()[1],
					eSignAttribute.getAl().getLfc()[2]);
			final String attributeValue = eSignAttribute.getAl().getLabelName().replaceAll("", "\n");

			final String[] lblValue = attributeValue.trim().split("\n");

			for (int i = 0; i < lblValue.length; i++) {
				contents.beginText();
				String text = lblValue[i];

				float columnAdj = 0f;

				Double columnAdjValue = null;

				try {
					setESignAttributeOffset();
					columnAdjValue = ESignConstants.offsetByPageType.get(pageFormat).get(format)
							.get(attrNumColums.toString()).get(attributeAlign).get(fontFace)
							.get(fontSizeInt.toString());

				} catch (Exception exception) {
					logger.info(firmId, "ESignatureService:writeLabel:exception:columnAdjValue:" + pageFormat + " "
							+ format + " " + attrNumColums + " " + attributeAlign + " " + fontFace + " " + fontSizeInt);
					logger.error(firmId, "ESignatureService:writeLabel:exception:", exception);
				}

				// For Old Approach
				if (columnAdjValue == null) {
					columnAdj = ESignConstants.LEFT_ALIGN.equals(attributeAlign) ? 100 : ESignConstants.CENTER_ALIGN.equals(attributeAlign) ? 80 : 20;
					contents.setFont(fontStyle != null ? fontStyle : PDType1Font.HELVETICA_BOLD, 8f);

					if (isLandscape)
						columnAdj = 20f;
				} else {
					columnAdj = columnAdjValue.floatValue();
					contents.setFont(fontStyle != null ? fontStyle : PDType1Font.HELVETICA_BOLD, fontSize);
				}

				float columnRight = (float) ((eSignAttribute.getLocationX() / ESignConstants.PAGE_RATIO) - columnAdj);
				int textWidthAdj = 0;
				float textWidth = 0f;
				if (columnAdjValue != null) {
					textWidthAdj = ESignConstants.LEFT_ALIGN.equals(attributeAlign) ? 0 : ESignConstants.CENTER_ALIGN.equals(attributeAlign) ? 3 : 9;

					if (ESignConstants.RIGHT_ALIGN.equals(attributeAlign)) {
						if (fontSizeInt.equals(11L)) {
							textWidthAdj = 8;
						}
						if (fontSizeInt.equals(12L)) {
							textWidthAdj = 9;
						}
						if(fontSizeInt.equals(14L)){
							textWidthAdj = 10;
						}
						if(fontSizeInt.equals(15L)){
							textWidthAdj = 11;
						}
						if (ESignConstants.A4.equals(pageFormat) && ESignConstants.TIMES_NEW_ROMAN.equals(fontFace)
								&& fontSizeInt.equals(12L)) {
							textWidthAdj = 8;
						}
						if (ESignConstants.LETTER.equals(pageFormat) && ESignConstants.TIMES_NEW_ROMAN.equals(fontFace)
								&& fontSizeInt.equals(11L)) {
							textWidthAdj = 9;
						}
					}
					if (fontStyle != null) {
						textWidth = (fontStyle.getStringWidth(text) / 1000.0f) * textWidthAdj;
					} else {
						textWidth = (PDType1Font.HELVETICA_BOLD.getStringWidth(text) / 1000.0f) * textWidthAdj;
					}
				}

				// For Old Approach
				if (columnAdjValue == null) {

					textWidthAdj = ESignConstants.LEFT_ALIGN.equals(attributeAlign) ? 0 : ESignConstants.CENTER_ALIGN.equals(attributeAlign) ? 2 : 8;

					if (fontStyle != null) {
						textWidth = (fontStyle.getStringWidth(text) / 1000.0f) * textWidthAdj;
					} else {
						textWidth = (PDType1Font.HELVETICA_BOLD.getStringWidth(text) / 1000.0f) * textWidthAdj;
					}
				}
				float offset = columnRight - textWidth;

				if (columnAdjValue == null) {
					if (!isLandscape) {
						offset = offset + ESignConstants.labelOffsetByPageFormat.get(pageFormat)
								.get(attrNumColums.intValue()).get(attributeAlign);
					} else {
						offset = offset + ESignConstants.labelOffsetByPageFormatLandscape.get(pageFormat)
								.get(attrNumColums.intValue()).get(attributeAlign);
					}
				}

				contents.newLineAtOffset((offset), (locY - (i * 12)));
				contents.showText(text);
				contents.endText();
			}
			// reset the color
			contents.setNonStrokingColor(0,0,0);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:writeLabel:exception:", exception);
		}
	}
	
	/**
	 * This method used to create contact.
	 *
	 * @param firmId
	 * @param userId
	 * @param contactData
	 * @return
	 */
	public IdxContact addAsContact(final Long firmId, final Long userId, final String contactData) {
		try {
			final IdxContact idxContact = AppUtil.convertFromJson(IdxContact.class, contactData);

			final Long contactId = AppBaseDAO.getInstance().getSequenceNextVal(firmId, "APP_SEQ_CONTACT_ID");
			idxContact.setContactId(contactId);

			idxContact.setFirmId(firmId);
			idxContact.setObjectStatus(AppConstants.OBJECT_STATUS_ACTIVE);

			idxContact.setCreatedBy(userId);
			idxContact.setLastUpdatedBy(userId);

			final String currentDate = DateUtil.getEsDateFormat().format(new Date());
			idxContact.setCreationDate(currentDate);
			idxContact.setLastUpdateDate(currentDate);

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_CONTACT, contactId,
					AppUtil.convertToJson(idxContact));
			return idxContact;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:addAsContact:exception:", exception);
		}
		return null;
	}

	/**
	 * This method used to get the template data, while selecting template from Add Template option
	 *
	 * @param firmId
	 * @param userId
	 * @param userData
	 * @param request
	 * @return
	 */
	public String getTemplateData(final Long firmId, final Long userId, final UserData userData,
			final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_ID, null);
		final String signType = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_SIGN_TYPE, null);

		final IdxESignDocument idxESignTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);

		// Validating the document limit
		Map<String, Object> planDetails = getPlanInformation(firmId, userData);
		final Long remainingDocCount = Long.valueOf(planDetails.get(AppConstants.REMAINING_DOC_COUNT).toString());
		if (remainingDocCount <= 0L) {
			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
			result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_DOC_LIMIT_EXISTS);
			return AppUtil.convertToJson(result);
		}

		final String clientIpAddress = AppHttpUtil.getClientIPAddress(request);
		final String userAgent = AppHttpUtil.getUserAgent(request);

		final IdxESignDocument idxESignDocument = new IdxESignDocument();

		try {
			idxESignDocument.seteSignDocumentId(
					AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_DOCUMENT_ID));

			final String revId = documentId.toString() + "_o";
			final IdxESignDocRevisions idxESignDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, revId);
			if(idxESignDocRev != null) {
				final String updatedRevId = idxESignDocument.geteSignDocumentId() + "_0";
				final IdxESignDocRevisions idxESignDocRevisions = saveESignDocRevision(firmId,
						ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(), updatedRevId, idxESignDocRev.getDocData());
				final String filePath = writeFile(firmId, idxESignDocument.getCreatedBy(), documentId, idxESignDocRev.getDocData());
				saveToBlockChain(firmId, idxESignDocRevisions.getId(), userData.getFullName(), filePath);
				deleteFileIfExists(firmId, filePath);
			} else {
				idxESignDocument.setDocumentData(idxESignTemplate.getDocumentData());
			}

			idxESignDocument.setDocumentPages(idxESignTemplate.getDocumentPages());
			idxESignDocument.setDocumentName(idxESignTemplate.getDocumentName());

			idxESignDocument.setSource(ESignConstants.SOURCE_TEMPLATE);
			idxESignDocument.setFileId(idxESignTemplate.geteSignDocumentId().toString());
			idxESignDocument.setFileExt(ESignConstants.FILE_EXT_PDF);

			final IdxObject senderDetails = new IdxObject();
			senderDetails.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
			senderDetails.setObjectRefId(userData.getEmployeeId());
			senderDetails.setObjectRefName(userData.getFullName());
			senderDetails.setEmailId(userData.getEmailId());
			senderDetails.setSourceRefId(userData.getUserId().toString());
			idxESignDocument.setSenderDetails(senderDetails);

			idxESignDocument.getAssignees().add(senderDetails);

			idxESignDocument.setSigners(idxESignTemplate.getSigners());
			idxESignDocument.setSignType(signType);
			idxESignDocument.setStatusCode(ESignConstants.ESIGN_DOCUMENT_STATUS_DRAFT.toUpperCase());
			idxESignDocument.setStatusName(ESignConstants.ESIGN_DOCUMENT_STATUS_DRAFT);
			idxESignDocument.setIsSent(false);
			idxESignDocument.setIsTemplate(false);
			idxESignDocument.setVc(idxESignTemplate.getVc());
			idxESignDocument.setFa(idxESignTemplate.getFa());

			// Multi-file Details
			final IdxObject mfd = new IdxObject();
			mfd.setId(0L);
			mfd.setName(idxESignTemplate.getDocumentName());
			mfd.setSrc(idxESignTemplate.getSource());
			mfd.setExt(idxESignTemplate.getFileExt());
			mfd.setPc(idxESignTemplate.getTotalPages());
			idxESignDocument.getMfd().add(mfd);

			final IdxObject associatedObjectdetails = new IdxObject();
			associatedObjectdetails.setType(idxESignTemplate.getAssociatedObject().getType());
			associatedObjectdetails.setLandscape(idxESignTemplate.getAssociatedObject().isLandscape());
			associatedObjectdetails.setObjectId(ObjectConstants.OBJECT_ESIGN_DOCUMENT);
			associatedObjectdetails.setObjectRefId(idxESignDocument.geteSignDocumentId());
			associatedObjectdetails.setObjectRefName(idxESignDocument.getDocumentName());

			idxESignDocument.setAssociatedObject(associatedObjectdetails);

			final String currentDate = DateUtil.getEsDateFormat().format(new Date());
			idxESignDocument.setCreatedBy(userId);
			idxESignDocument.setLastUpdatedBy(userId);
			idxESignDocument.setCreationDate(currentDate);
			idxESignDocument.setLastUpdateDate(currentDate);
			idxESignDocument.setCreatedByName(userData.getFullName());
			idxESignDocument.setLastUpdatedByName(userData.getFullName());
			idxESignDocument.setFirmId(firmId);
			idxESignDocument.setObjectStatus(AppConstants.OBJECT_STATUS_ACTIVE);
			idxESignDocument.setTotalPages((long) idxESignDocument.getDocumentPages().size());

			updateESignDocument(firmId, idxESignDocument);

			// Creating e-signature history for file import by Add as Template.
			createESignatureHistory(firmId, idxESignDocument, null, AppConstants.ESIGN_UPLOAD,
					AppConstants.ESIGN_DESC_UPLOAD, clientIpAddress, userAgent, null);

			// Deducting the document count for successful doc creation.
			final IdxFirmPlanHistory idxFirmPlanHistory = AppUtil.convertFromJson(IdxFirmPlanHistory.class,
					planDetails.get(AppConstants.CURRENT_PLAN_DETAILS).toString());
			idxFirmPlanHistory.setDocCount(idxFirmPlanHistory.getDocCount() - 1);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_HR_FIRM_PLAN_HISTORY,
					idxFirmPlanHistory.getFirmPlanHistoryId(), AppUtil.convertToJson(idxFirmPlanHistory));

			final List<IdxEsignDocumentPage> idxESignDocPages = new ArrayList<>();
			idxESignDocPages.add(idxESignDocument.getDocumentPages().get(0));
			idxESignDocument.setDocumentPages(idxESignDocPages);
			idxESignDocument.setDocumentData("");
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:getTemplateData:exception:", exception);
		}

		return AppUtil.convertToJson(idxESignDocument);
	}

	/**
	 * This method used to enable or disable the template in settings
	 *
	 * @param firmId
	 * @param documentId
	 * @param isEnabled
	 * @return
	 */
	public String enableOrDisableTemplate(final Long firmId, final Long documentId, final boolean isEnabled) {
		final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);
		if (idxESignDocument != null) {
			idxESignDocument.setIsEnabled(isEnabled);

			updateESignDocument(firmId, idxESignDocument);

			return AppConstants.STATUS_CODE_SUCCESS;
		}
		return AppConstants.STATUS_CODE_FAILURE;
	}

	/**
	 * This method used to enable or disable the sign type
	 * My Signature/ Type / Draw / Upload
	 *
	 * @param firmId
	 * @param id
	 * @param isEnabled
	 * @return
	 */
	public IdxESignConfiguration enableOrDisableSignType(final Long firmId, final Long id, final String isEnabled) {
		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);
		if (idxESignConfiguration != null) {
			for (IdxLookup signatureType : idxESignConfiguration.getSignatureTypes()) {
				if (signatureType.getId().equals(id)) {
					signatureType.setIsEnabled(isEnabled);
					break;
				}
			}
			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));
		}
		return idxESignConfiguration;
	}

	/**
	 * This method used to update the signer authentication.
	 * 
	 * @param firmId
	 * @param request
	 * @return
	 */
	public IdxESignConfiguration updateSignerAuth(final Long firmId, final HttpServletRequest request) {
		final Long id = AppHttpUtil.getLongParameter(request, AppConstants.ID, null);
		final String isEnabled = AppHttpUtil.getStringParameter(request, ESignConstants.IS_ENABLED, AppConstants.NO);
		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);
		if (idxESignConfiguration != null) {
			for (IdxLookup signerAuth : idxESignConfiguration.getSignerAuth()) {
				if (signerAuth.getId().equals(id)) {
					signerAuth.setIsEnabled(isEnabled);
					break;
				}
			}
			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));
		}
		return idxESignConfiguration;
	}

	/**
	 * This method used to delete the e-sign attribute by id
	 *
	 * @param firmId
	 * @param documentId
	 * @param uniqueId
	 * @param eSignAttrPageNumber
	 * @return
	 */
	public String deleteESignAttribute(final Long firmId, final Long documentId, final Long uniqueId,
			final Long eSignAttrPageNumber) {
		// Preparing scriptParams.
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
		scriptParams.put(ESignConstants.UNIQUE_ID, uniqueId);
		scriptParams.put(ESignConstants.PAGE_NUMBER, eSignAttrPageNumber);

		// Deleting the eSignattribute using ES painless script.
		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		updateScript.append("for (int i = 0; i < ctx._source.documentPages.size(); i++) {");
		updateScript.append("if(ctx._source.documentPages[i].pageNumber == params.pageNumber) {");
		updateScript.append("for (int j = 0; j < ctx._source.documentPages[i].eSignAttributes.size(); j++) {");
		updateScript.append("if(ctx._source.documentPages[i].eSignAttributes[j].uniqueId == params.uniqueId) {");
		updateScript.append("ctx._source.documentPages[i].eSignAttributes.remove(j);");
		updateScript.append("break;");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");

		// Updating the IdxESignDocument.
		final IdxESignDocument updateDocument = updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT,
				documentId.toString(), updateScript.toString(), scriptParams, true, IdxESignDocument.class);

		if (updateDocument != null) {
			return AppConstants.STATUS_CODE_SUCCESS;
		} else {
			return AppConstants.STATUS_CODE_FAILURE;
		}
	}

	/**
	 * This method used to add the signer in template
	 *
	 * @param firmId
	 * @param documentId
	 * @param signerData
	 * @return
	 */
	public String addTemplateSigner(final Long firmId, final Long documentId, 
			final String signerData) {
		try {
			final IdxESignDocument idxESignDocument = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxESignDocument.class, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId);

			final List<IdxESignSigner> signers = new Gson().fromJson(signerData, new TypeToken<List<IdxESignSigner>>() {
			}.getType());

			updateSignerByScript(firmId, documentId, signers);
			idxESignDocument.setSigners(signers);

			return AppConstants.STATUS_CODE_SUCCESS;
		} catch (final VersionConflictEngineException exception) {
			logger.error(firmId, "ESignatureService:addTemplateSigner:version conflict", exception);
			addTemplateSigner(firmId, documentId, signerData);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:addTemplateSigner:exception:", exception);
		}
		return AppConstants.STATUS_CODE_FAILURE;
	}

	/**
	 * This method used to get the plan payment information from customer record
	 *
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public Map<String, Object> getPlanInformation(final Long firmId, final UserData userData) {
		final Map<String, Object> resultMap = new HashMap<>();

		final IdxFirm clientIdxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		SimpleDateFormat sdf = new SimpleDateFormat(DateUtil.format_mdyhms);

		if(userData != null) {
			sdf = new SimpleDateFormat(userData.getDatePattern());
			sdf.setTimeZone(userData.getTimeZone());
		}

		final IdxCustomer idxCustomer = FirmEmpContactService.getInstance()
				.getCustomer(clientIdxFirm.getCustomerByAppCode(AppConstants.APP_CODE_SIGN));

		if (idxCustomer != null) {
		for (final IdxCustomAttribute idxCustomAttribute : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_PLAN_CODE.equals(idxCustomAttribute.getCustomAttributeId())
					|| AppConstants.ATTR_PLAN_TERM.equals(idxCustomAttribute.getCustomAttributeId())) {
				resultMap.put(idxCustomAttribute.getCustomAttributeId(), idxCustomAttribute.getCustomAttributeValue());
			} else if ((AppConstants.ATTR_PLAN_STR_DATE_TIME.equals(idxCustomAttribute.getCustomAttributeId())
					|| AppConstants.ATTR_PLAN_PURH_DATE_TIME.equals(idxCustomAttribute.getCustomAttributeId())
					|| AppConstants.ATTR_PLAN_EXP_DATE_TIME.equals(idxCustomAttribute.getCustomAttributeId())
					|| AppConstants.ATTR_TRAIL_EXP_DATE_TIME.equals(idxCustomAttribute.getCustomAttributeId()))
					&& AppUtil.checkStringNullOrNot(idxCustomAttribute.getDateValue())){
				final Date customAttrDateValue = DateUtil.getDateFromFormattedDate(idxCustomAttribute.getDateValue(),
						DateUtil.format_mdyhms);
				resultMap.put(idxCustomAttribute.getCustomAttributeId(), idxCustomAttribute.getDateValue());

				resultMap.put("sdf" + idxCustomAttribute.getCustomAttributeId(), sdf.format(customAttrDateValue));
			} else if (AppConstants.ATTR_IS_TRAIL.equals(idxCustomAttribute.getCustomAttributeId())
					|| AppConstants.ATTR_IS_TRAIL_EXT.equals(idxCustomAttribute.getCustomAttributeId())) {
					final String customAttrValue = (idxCustomAttribute.getAttributeValues() != null
							&& !idxCustomAttribute.getAttributeValues().isEmpty()) ? AppConstants.YES : AppConstants.NO;
				resultMap.put(idxCustomAttribute.getCustomAttributeId(), customAttrValue);
			} else if(AppConstants.ATTR_ORDER_DETAILS.equals(idxCustomAttribute.getCustomAttributeId())) {
				resultMap.put(AppConstants.STR_ORDER_ID, idxCustomAttribute.getObjectRefId());
				resultMap.put(AppConstants.STR_ORDER_NUMBER, idxCustomAttribute.getObjectRefName());
			}
		}

		final Calendar calendar = Calendar.getInstance();
		final Date currentDate = calendar.getTime();

		final Date planExpiryDate = resultMap.get(AppConstants.ATTR_PLAN_EXP_DATE_TIME) != null ? DateUtil.getDateFromFormattedDate(
								String.valueOf(resultMap.get(AppConstants.ATTR_PLAN_EXP_DATE_TIME)), DateUtil.format_mdyhms) : null;
		final Date trailExpiryDate = resultMap.get(AppConstants.ATTR_TRAIL_EXP_DATE_TIME) != null ? DateUtil.getDateFromFormattedDate(
								String.valueOf(resultMap.get(AppConstants.ATTR_TRAIL_EXP_DATE_TIME)), DateUtil.format_mdyhms) : null;

		// For Trail Plan
		if (AppConstants.YES.equals(resultMap.get(AppConstants.ATTR_IS_TRAIL)) && trailExpiryDate != null) {
			// For showing the notification for Trail Expire notification - before 5 days
			if (inRange(DateUtil.getDifferenceNumberOfDays(trailExpiryDate, currentDate).doubleValue(), 0d, 5d)) {
				resultMap.put(AppConstants.SHOW_TRIAL_EXPIRY, AppConstants.YES);
			} else {
				resultMap.put(AppConstants.SHOW_TRIAL_EXPIRY, AppConstants.NO);
			}

			// For showing the Trail Expired notification
			if (DateUtil.getDifferenceNumberOfDays(trailExpiryDate, currentDate).doubleValue() < 0) {
				resultMap.put(AppConstants.IS_TRIAL_EXPIRED, AppConstants.YES);
			} else {
				resultMap.put(AppConstants.IS_TRIAL_EXPIRED, AppConstants.NO);
			}

		} else if (planExpiryDate != null) {
			// For showing the notification for Plan Expire notification - before 5 days
			if (inRange(DateUtil.getDifferenceNumberOfDays(planExpiryDate, currentDate).doubleValue(), 0d, 5d)) {
				resultMap.put(AppConstants.SHOW_PLAN_EXPIRY, AppConstants.YES);
			} else {
				resultMap.put(AppConstants.SHOW_PLAN_EXPIRY, AppConstants.NO);
			}

			// For showing the Plan Expired notification
			if (DateUtil.getDifferenceNumberOfDays(planExpiryDate, currentDate).doubleValue() < 0) {
				resultMap.put(AppConstants.IS_PLAN_EXPIRED, AppConstants.YES);
			} else {
				resultMap.put(AppConstants.IS_PLAN_EXPIRED, AppConstants.NO);
			}
		}

		getDocRemainingCount(firmId, resultMap);
		}
		return resultMap;
	}

	/**
	 * This method used to get the plan details
	 *
	 * @param firmId
	 * @return
	 */
	public String getPlan(final Long firmId) {
		String planCode = ESignConstants.SPLAN_5;
		try {
			final IdxFirm clientIdxFirm = FirmDAO.getInstance().getByFirmId(firmId);

			final IdxCustomer idxCustomer = FirmEmpContactService.getInstance()
					.getCustomer(clientIdxFirm.getCustomerByAppCode(AppConstants.APP_CODE_SIGN));

			if (idxCustomer != null) {
				for (final IdxCustomAttribute idxCustomAttribute : idxCustomer.getCustomAttributes()) {
					if (AppConstants.ATTR_PLAN_CODE.equals(idxCustomAttribute.getCustomAttributeId())) {
						return idxCustomAttribute.getCustomAttributeValue();
					}
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getPlan:exception:", exception);
		}
		return planCode;
	}

	/**
	 * This method used to get the remaining document count based on customer plan details
	 *
	 * @param firmId
	 * @param resultMap
	 * @return
	 */
	public void getDocRemainingCount(final Long firmId, final Map<String, Object> resultMap) {
		Long remainingDocCount = 0L;
		IdxFirmPlanHistory recentUpgradedPlan = new IdxFirmPlanHistory();

		final SearchHits hits = getSignFirmPlanHistory(firmId, AppConstants.UPGRADE_SUCCESS, null, 1,
				AppConstants.UPGRADE_DATE, AppConstants.COMMON_SORT_DESC);

		final SearchHit[] documents = hits.getHits();
		for (final SearchHit document : documents) {
			recentUpgradedPlan = AppUtil.convertFromJson(IdxFirmPlanHistory.class, document.getSourceAsString());
			final Calendar calendar = Calendar.getInstance();
			if (AppConstants.YES.equals(resultMap.get(AppConstants.ATTR_IS_TRAIL)) && 
					recentUpgradedPlan.getPlanCode().equalsIgnoreCase(resultMap.get(AppConstants.ATTR_PLAN_CODE).toString())) {

				final Date trailExpiryDate = DateUtil.getDateFromFormattedDate(resultMap.get(AppConstants.ATTR_TRAIL_EXP_DATE_TIME).toString(),
						DateUtil.format_mdyhms);
				if(trailExpiryDate.compareTo(calendar.getTime()) >= 0) {
					remainingDocCount = recentUpgradedPlan.getDocCount();
				}
			} else if (resultMap.get(AppConstants.STR_ORDER_ID) != null && recentUpgradedPlan.getPlanOrderId() != null
					&& resultMap.get(AppConstants.STR_ORDER_ID).toString().equals(recentUpgradedPlan.getPlanOrderId().toString())) {
				final Date planExpiryDate = DateUtil.getDateFromFormattedDate(
						resultMap.get(AppConstants.ATTR_PLAN_EXP_DATE_TIME).toString(), DateUtil.format_mdyhms);
				if(planExpiryDate.compareTo(calendar.getTime()) >= 0) {
					remainingDocCount = recentUpgradedPlan.getDocCount();
				}
			}
		}
		resultMap.put(AppConstants.REMAINING_DOC_COUNT, remainingDocCount);
		resultMap.put(AppConstants.CURRENT_PLAN_DETAILS, AppUtil.convertToJson(recentUpgradedPlan));
	}

	/**
	 * This method used to update the doc limit usage.
	 *
	 * @param firmId
	 * @return
	 */
	public String updateDocLimitUsage(final Long firmId) {
		final SearchHits hits = getSignFirmPlanHistory(firmId, AppConstants.UPGRADE_SUCCESS, null,
				1, AppConstants.UPGRADE_DATE, AppConstants.COMMON_SORT_DESC);

		final SearchHit[] documents = hits.getHits();
		if(documents.length > 0) {
			IdxFirmPlanHistory recentUpgradedPlan = AppUtil.convertFromJson(IdxFirmPlanHistory.class,
					documents[0].getSourceAsString());
			recentUpgradedPlan.setDocCount(recentUpgradedPlan.getDocCount() - 1);
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_HR_FIRM_PLAN_HISTORY,
					recentUpgradedPlan.getFirmPlanHistoryId(), AppUtil.convertToJson(recentUpgradedPlan));
			return AppConstants.RESULT_STATUS_SUCCESS;
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to get the Sign Firm Plan history.
	 *
	 * @param firmId
	 * @param upgradeStatus
	 * @param startIndex
	 * @param numResults
	 * @param sortColumn
	 * @param sortOrder
	 * @return
	 */
	public SearchHits getSignFirmPlanHistory(final Long firmId, final String upgradeStatus,final Integer startIndex,
			final Integer numResults, final String sortColumn, final String sortOrder) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ElasticSearchDAO.getInstance().getIndexName(firmId,
						ObjectConstants.OBJECT_HR_FIRM_PLAN_HISTORY))
				.setSearchType(ESAPIUtil.SCAN).setExplain(false)
				.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();

		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		if (AppUtil.checkStringNullOrNot(upgradeStatus)) {
			andBuilder.must(QueryBuilders.termQuery("upgradeStatus", upgradeStatus));
		}

		andBuilder.must(QueryBuilders.termQuery(AppConstants.APP, AppConstants.APP_CODE_SIGN));

		builder.setPostFilter(andBuilder);

		if (AppUtil.checkStringNullOrNot(sortColumn)) {
			if ("asc".equalsIgnoreCase(sortOrder)) {
				builder.addSort(sortColumn, SortOrder.ASC);
			} else {
				builder.addSort(sortColumn, SortOrder.DESC);
			}
		}

		if (startIndex != null && startIndex > 0) {
			builder.setTrackTotalHits(true).setFrom(startIndex);
		} else {
			builder.setTrackTotalHits(true).setFrom(0);
		}

		if ((numResults != null) && (numResults > 0)) {
			builder.setSize(numResults);
		} else {
			builder.setSize(ElasticSearchDAO.DEFAULT_ES_500_RESULTS);
		}
		logger.info(firmId, "ESignatureService:getHrFirmPlanHistory:builder:" + builder.toString());

		return builder.execute().actionGet().getHits();
	}

	/**
	 * This method used to extend the trail plan
	 *
	 * @param firmId
	 * @return
	 */
	public Map<String, String> extendTrail(final Long firmId) {
		final Map<String, String> result = new HashMap<>();

		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		try {
			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);

			// Verifying the trail plan is already extended or not 
			final Map<String, Object> planDetails = getPlanInformation(adminFirmId, null);
			if(AppConstants.YES.equals(String.valueOf(planDetails.get(AppConstants.ATTR_IS_TRAIL_EXT)))) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				return result;
			}

			final IdxCustomer idxCustomer = FirmEmpContactService.getInstance()
					.getCustomer(idxFirm.getCustomerByAppCode(AppConstants.APP_CODE_SIGN));

			final Calendar calendar = Calendar.getInstance();
			calendar.add(Calendar.DAY_OF_MONTH, 7);
			final Date trailExpDate = calendar.getTime();
			final String sdfTrailExpDate = DateUtil.getEsDateFormat().format(trailExpDate);
			final String trialExpDate = new SimpleDateFormat(DateUtil.format_mdy).format(trailExpDate);

			for (final IdxCustomAttribute idxCustomAttribute : idxCustomer.getCustomAttributes()) {
				if (AppConstants.ATTR_TRAIL_EXP_DATE_TIME.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
					idxCustomAttribute.setCustomAttributeValue(trialExpDate);
					idxCustomAttribute.setCustomAttributeValue1(trialExpDate);
					idxCustomAttribute.setDateValue(sdfTrailExpDate);
					idxCustomAttribute.setFrd(sdfTrailExpDate);
					idxCustomAttribute.setCustomAttributeValue2(idxCustomAttribute.prepareTimeValue(trailExpDate));
				} else if (AppConstants.ATTR_IS_TRAIL_EXT.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
					final IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
					idxCustomAttributeValue.setAttributeId(AppConstants.ATTR_IS_TRAIL_EXT);
					idxCustomAttributeValue.setAttributeValue(AppConstants.CUSTOM_ATTRIBUTE_TAG_VALUE);
					if (idxCustomAttribute.getAttributeValues() == null) {
						idxCustomAttribute.setAttributeValues(new ArrayList<>());
					}
					idxCustomAttribute.getAttributeValues().add(idxCustomAttributeValue);
				}
			}
			ElasticSearchDAO.getInstance().indexDocument(adminFirmId, ObjectConstants.OBJECT_ACCOUNT,
					idxCustomer.getCustomerId(), AppUtil.convertToJson(idxCustomer));
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:extendTrail:exception:", exception);
		}
		return result;
	}

	/**
	 * This method used to enqueue a event for resetting the document limit count
	 *
	 * @param firmId
	 * @param userId
	 * @param orderId
	 * @param billingPeriod
	 * @param delayInMilli
	 * @return
	 */
	@SuppressWarnings({ "resource", "deprecation" })
	public String pushToFeatureRenewalQueue(final Long firmId, final Long userId, final Long orderId,
			final String billingPeriod, final Long delayInMilli) {

		final String queueInfraURL = AppBaseDAO.getInstance().getEnvProperty(AppConstants.PROP_TRIGGERS_ENQUE_URL, AppConstants.YES);
		logger.info(firmId, "ESignatureService:pushToFeatureRenewalQueue:queueInfraURL:" + queueInfraURL);

		final String dequeueUrl = AppGoogleUtil.getDequeueUrl();
		logger.info(firmId, "ESignatureService:pushToFeatureRenewalQueue:dequeueUrl:" + dequeueUrl);

		// Calculating delay based on billing period
		Long delay = null;
		if (delayInMilli == null) {
			final Calendar calendar = Calendar.getInstance();
			final Long startDateInMilli = calendar.getTimeInMillis();
			if (AppConstants.UPGRADE_BILLING_PERIOD_DAY.equalsIgnoreCase(billingPeriod)) {
				calendar.add(Calendar.DATE, 1);
			} else {
				calendar.add(Calendar.MONTH, 1);
			}
			delay = calendar.getTimeInMillis() - startDateInMilli;
		} else {
			delay = delayInMilli;
		}

		final Map<String, Object> messageTextMap = new HashMap<>();
		messageTextMap.put(AppConstants.FIRM_ID, firmId.toString());
		messageTextMap.put(AppConstants.APP, AppConstants.APP_CODE_SIGN);
		messageTextMap.put(AppConstants.STR_ORDER_ID, orderId.toString());
		messageTextMap.put(AppConstants.STR_USER_ID, userId.toString());
		messageTextMap.put("billingPeriod", billingPeriod);
		messageTextMap.put(MESSAGE_PROPERTIES.DESTINATION_NAME, AppConstants.ACCOUNT_RENEWAL_QUEUE);
		final String messageText = AppUtil.convertToJson(messageTextMap);

		final HttpClient client = new DefaultHttpClient();
		final HttpPost post = new HttpPost(queueInfraURL);

		// add header
		final List<NameValuePair> urlParameters = new ArrayList<>();
		urlParameters.add(new BasicNameValuePair("a", "enqueue"));
		urlParameters.add(new BasicNameValuePair(AppConstants.FIRM_ID, firmId.toString()));
		urlParameters.add(new BasicNameValuePair("destinationType", "queue"));
		urlParameters.add(new BasicNameValuePair("destinationName", AppConstants.ACCOUNT_RENEWAL_QUEUE));
		urlParameters.add(new BasicNameValuePair("messageType", "Text"));
		urlParameters.add(new BasicNameValuePair("delay", delay.toString()));
		urlParameters.add(new BasicNameValuePair("url", dequeueUrl));
		urlParameters.add(new BasicNameValuePair("messageText", messageText));
		try {
			post.setEntity(new UrlEncodedFormEntity(urlParameters));
			final HttpResponse response1 = client.execute(post);
			logger.info(firmId, "ESignatureService:pushToFeatureRenewalQueue:response1:"
					+ response1.getStatusLine().getStatusCode());
			int statusCode = response1.getStatusLine().getStatusCode();
			if (200 == statusCode) {
				return AppConstants.SUCCESSS_NOTE;
			}
		} catch (UnsupportedEncodingException e) {
			logger.error(firmId, "ESignatureService:pushToFeatureRenewalQueue:un supported Encoding exception", e);
			return AppConstants.ERROR_NOTE;
		} catch (ClientProtocolException e) {
			logger.error(firmId, "ESignatureService:pushToFeatureRenewalQueue:ClientProtocolException", e);
			return AppConstants.ERROR_NOTE;
		} catch (IOException e) {
			logger.error(firmId, "ESignatureService:pushToFeatureRenewalQueue:IOException", e);
			return AppConstants.ERROR_NOTE;
		}
		logger.info(firmId, "ESignatureService:pushToFeatureRenewalQueue:ends");
		return AppConstants.ERROR_NOTE;
	}

	/**
	 * This method used to get the legal disclosure
	 *
	 * @param firmId
	 * @return
	 */
	public IdxEmailTemplate getLegalDisclosure(final Long firmId) {
		final List<IdxEmailTemplate> idxLegalDisclosures = MessageTemplateDAO.getInstance().getEmailTemplates(firmId,
				 null, null, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, 1);
		if (AppUtil.checkListisNullOrNot(idxLegalDisclosures)) {
			return idxLegalDisclosures.get(0);
		}
		return null;
	}

	/**
	 * This method used to update the legal disclosure based on the isLglCntUpd
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 */
	public String updateLegalDisclosure(final Long firmId, final UserData  userData, 
			final HttpServletRequest request){
		final String isLglCntUpd = AppHttpUtil.getStringParameterFromRequest(request, "isLglCntUpd", null);
		final String lglDislData = AppHttpUtil.getStringParameterFromRequest(request, "lglDislData", null);

		final String isEnabled = AppHttpUtil.getStringParameterFromRequest(request, "isEnabled", null);
		final String mmc = AppHttpUtil.getStringParameterFromRequest(request, "mmc", null);
		final String mal = AppHttpUtil.getStringParameterFromRequest(request, "mal", null);

		final Map<String, Object> results = updateLglDisl(firmId, isEnabled, mmc, mal);

		if (AppConstants.YES.equals(isLglCntUpd)) {
			updateLglCnt(firmId, lglDislData, userData);
		}

		return AppUtil.convertToJson(results);
	}

	/**
	 * This method used to update the legal disclosure content
	 *
	 * @param firmId
	 * @param lglDislData
	 * @param userData
	 */
	public void updateLglCnt(final Long firmId, final String lglDislData, final UserData userData) {
		final String currentDate = DateUtil.getEsDateFormat().format(new Date());

		final IdxEmailTemplate lglDisl = AppUtil.convertFromJson(IdxEmailTemplate.class, lglDislData);

		final IdxEmailTemplate idxLglDisl = ElasticSearchDAO.getInstance().getDocument(firmId, IdxEmailTemplate.class,
				ObjectConstants.OBJECT_EMAIL_TEMPLATE, lglDisl.getId());
		logger.info(firmId, "ESignatureService:updateLglCnt:idxLglDisl:" + idxLglDisl);

		if (idxLglDisl != null) {
			idxLglDisl.setCustomMessage(lglDisl.getCustomMessage());
			idxLglDisl.setWidgets(lglDisl.getWidgets());

			idxLglDisl.setLastUpdateDate(currentDate);
			idxLglDisl.setLastUpdatedByName(userData.getFullName());
			idxLglDisl.setLastUpdatedBy(userData.getUserId());

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
					idxLglDisl.getId(), AppUtil.convertToJson(idxLglDisl));

			// Updating the email template revision
			AppSettingsDAO.getInstance().addEmailTemplateRevision(firmId, userData.getUserId(), userData.getFullName(),
					idxLglDisl.getObjectId(), idxLglDisl.getCustomMessage(), idxLglDisl.getId(),
					idxLglDisl.getWidgets(), null);
		}
	}

	/**
	 * This method used to update the legal disclosure toggle in settings
	 *
	 * @param firmId
	 * @param lglDisl
	 */
	public Map<String, Object> updateLglDisl(final Long firmId, final String isEnabled, final String mmc, final String mal) {
		final Map<String, Object> results = new HashMap<>();

		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);
		idxESignConfiguration.getLdc().get(0).setIsEnabled(isEnabled);
		idxESignConfiguration.getLdc().get(0).setMmc(mmc);
		idxESignConfiguration.getLdc().get(0).setMal(mal);

		ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
				ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
				AppUtil.convertToJson(idxESignConfiguration));

		results.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		results.put(AppConstants.RESULT_DATA, idxESignConfiguration);
		return results;
	}

	/**
	 * This method used to prepare the legal disclosure based on the signer status.
	 * 
	 * @param idxESignDocument
	 * @param signerId
	 *
	 * @return
	 */
	public Map<String, Object> prepareLegalDisclosure(final IdxESignDocument idxESignDocument, final Long signerId) {
		final Map<String, Object> result = new HashMap<>();

		final Long firmId = idxESignDocument.getFirmId();

		IdxESignSigner idxSigner;

		// In-Person Sign
		if (signerId == null && ESignConstants.IN_PERSON_SIGN.equals(idxESignDocument.getSignType())) {
			idxSigner = idxESignDocument.getSigners().get(0);
		} else {
			idxSigner = idxESignDocument.getESignSignerBySignerId(signerId);
		}

		String isLglDislEnab = AppConstants.NO;
		String lglDislCnt = null;

		if (idxSigner != null && !ESignConstants.SIGNER_STATUS_SIGNED.equalsIgnoreCase(idxSigner.getSignerStatus())) {
			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

			if (idxESignConfiguration != null) {
			final String isEnabled = AppUtil.checkListisNullOrNot(idxESignConfiguration.getLdc())
					? idxESignConfiguration.getLdc().get(0).getIsEnabled()
					: idxESignConfiguration.getIsLegalDisclosureEnab();

			if (AppConstants.YES.equals(isEnabled)) {
				final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

				isLglDislEnab = AppConstants.YES;

				if (AppUtil.checkListisNullOrNot(idxESignConfiguration.getLdc())) {
					result.put(ESignConstants.LEGAL_DISCLOSURE_CONTENT, idxESignConfiguration.getLdc().get(0));
				}

				final IdxEmailTemplate idxLglDisl = getLegalDisclosure(firmId);
				if (idxLglDisl != null) {
					lglDislCnt = idxLglDisl.getCustomMessage();

					// Business Information:
					lglDislCnt = lglDislCnt.replace(ESignConstants.BUSINESS_NAME, idxFirm.getFirmName());

					String phoneNumber = "";
					if (AppUtil.checkListisNullOrNot(idxFirm.getPhoneNumbers())) {
						phoneNumber = idxFirm.getPhoneNumbers().get(0).getPhoneNumber();
					}
					lglDislCnt = lglDislCnt.replace(ESignConstants.BUSINESS_PHONE, phoneNumber);

					String address = "";
					if (idxFirm.getAddress() != null) {
						address = idxFirm.getAddress().getFormattedAddressLines(false);
					}
					lglDislCnt = lglDislCnt.replace(ESignConstants.BUSINESS_ADDRESS, address);

					lglDislCnt = lglDislCnt.replace(ESignConstants.SENDER_NAME,
							idxESignDocument.getSenderDetails().getObjectRefName());
					lglDislCnt = lglDislCnt.replace(ESignConstants.SENDER_EMAIL_ID,
							idxESignDocument.getSenderDetails().getEmailId());

					lglDislCnt = lglDislCnt.replace(ESignConstants.SIGNER_NAME, idxSigner.getObjectRefName());
					lglDislCnt = lglDislCnt.replace(ESignConstants.SIGNER_EMAIL_ID, idxSigner.getPrimaryEmailId());
				}
			}
			}
		}

		result.put("isLglDislEnab", isLglDislEnab);
		result.put("lglDislCnt", lglDislCnt);
		return result;
	}
	
	/**
	 * This method used to update the assignees details based on the userId.
	 *
	 * @param idxESignDocument
	 */
	public void updateAssignees(final IdxESignDocument idxESignDocument) {
		final Long firmId = idxESignDocument.getFirmId();

		final Long employeeId = EmployeeDAO.getInstance().getEmployeeIdByUserId(firmId,
				idxESignDocument.getCreatedBy());
		if (employeeId != null) {

			// Setting objectId and ObjectRefId in senderDetails
			final IdxObject senderDetails = idxESignDocument.getSenderDetails();
			senderDetails.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
			senderDetails.setObjectRefId(employeeId);

			// Setting assignee details in idxESignDocument
			final IdxObject assignee = new IdxObject();
			assignee.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
			assignee.setObjectRefId(employeeId);
			assignee.setObjectRefName(senderDetails.getObjectRefName());
			assignee.setEmailId(senderDetails.getEmailId());
			assignee.setSourceRefId(senderDetails.getSourceRefId());

			idxESignDocument.getAssignees().add(assignee);
		}
	}

	/**
	 * This method used to generate the builder based on the access level.
	 *
	 * @param firmId
	 * @param userData
	 * @param andBuilder
	 */
	public void generateBuilderByAccessLevel(final Long firmId, final UserData userData,
			final BoolQueryBuilder andBuilder) {
		final List<Long> employeeIds = getEmployeeIdsByAccessLevel(firmId, userData);
		if (AppUtil.checkListisNullOrNot(employeeIds)) {
			final QueryBuilder objectRefIdNestedQuery = QueryBuilders.boolQuery()
					.must(QueryBuilders.termsQuery(ESignConstants.ASSIGNEES_OBJECT_REF_ID, employeeIds));

			andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSIGNEES, objectRefIdNestedQuery));
		}
	}

	/**
	 * This method used to get the document accessed by employee - Access Level
	 * 
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public List<Long> getEmployeeIdsByAccessLevel(final Long firmId, final UserData userData) {
		final List<Long> employeeIds = new ArrayList<>();
		final IdxESignConfiguration idxESignConfiguration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId);

		if (idxESignConfiguration != null) {
			final boolean isViewAccessEnabledException = idxESignConfiguration
					.isViewAccessEnabledForEmployeesAndTeams(ObjectConstants.OBJECT_EMPLOYEE, userData.getEmployeeId());

			if (userData.isSuperUser()
					|| AppConstants.COM_ACCESS_TYPE_FIRM.equals(idxESignConfiguration.getAccessLevel())
					|| isViewAccessEnabledException) {
				return employeeIds;
			} else if (AppConstants.COM_ACCESS_TYPE_EMPLOYEE.equals(idxESignConfiguration.getAccessLevel())) {
				return userData.getSubOrdinateEmployeeIds();
			}
		}
		return employeeIds;
	}

	/**
	 * This method used to create sign user role
	 * 
	 * @param firmId
	 * @return
	 */
	public IdxRole createSignUserRole(final Long firmId, String idxRoleId) {
//		final Long roleId = AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppsConstants.ROLE_SEQUENCE_ID);
		final IdxRole idxRole = new IdxRole(idxRoleId, ESignConstants.SIGN_USER, "Has access to view sign app",
				"Sign User", AppConstants.YES, firmId, AppConstants.APP_CODE_SIGN);

		final List<IdxRolePrivilege> idxRolePrivileges = new ArrayList<>();

		// ACCESS_SIGN_APP
		IdxRolePrivilege idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7001L);
		idxRolePrivileges.add(idxRolePrivilege);
		// VIEW_SIGN_APP
		idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7002L);
		idxRolePrivileges.add(idxRolePrivilege);
		// MANAGE_SIGN_APP
		idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7003L);
		idxRolePrivileges.add(idxRolePrivilege);

		idxRole.setRolePrivileges(idxRolePrivileges);
		return idxRole;
	}

	/**
	 * This method used to create the sign manager role
	 *
	 * @param firmId
	 * @return
	 */
	public IdxRole createSignManagerRole(final Long firmId, String idxRoleId) {
//		final Long roleId = AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppsConstants.ROLE_SEQUENCE_ID);
		final IdxRole idxRole = new IdxRole(idxRoleId, ESignConstants.SIGN_MANAGER,
				"Has access to view, update settings of sign app", "Sign Manager", AppConstants.YES, firmId,
				AppConstants.APP_CODE_SIGN);

		final List<IdxRolePrivilege> idxRolePrivileges = new ArrayList<>();

		// ACCESS_SIGN_APP
		IdxRolePrivilege idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7001L);
		idxRolePrivileges.add(idxRolePrivilege);
		// VIEW_SIGN_APP
		idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7002L);
		idxRolePrivileges.add(idxRolePrivilege);
		// MANAGE_SIGN_APP
		idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7003L);
		idxRolePrivileges.add(idxRolePrivilege);
		// LIMITED_CONFIG_SIGN_APP
		idxRolePrivilege = new IdxRolePrivilege(idxRoleId, 7005L);
		idxRolePrivileges.add(idxRolePrivilege);
		idxRole.setRolePrivileges(idxRolePrivileges);
		return idxRole;
	}

	/**
	 * This method used to get all sign.co roles
	 *
	 * @param firmId
	 * @return
	 */
	public List<IdxRole> getAllRoles (final Long firmId){
		final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
		boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		final BoolQueryBuilder orBuilder = QueryBuilders.boolQuery();
		orBuilder.should(QueryBuilders.termsQuery(AppConstants.APP, AppConstants.APP_CODE_SIGN));
		orBuilder.should(QueryBuilders.termsQuery(AppConstants.NAME, AppConstants.SUPER_USER_ROLE));
		boolQueryBuilder.must(orBuilder);

		return ElasticSearchDAO.getInstance().getAllDocumentsByBoolFilter(firmId,
				ObjectConstants.OBJECT_ROLE, boolQueryBuilder, IdxRole.class);
	}

	/**
	 * This method used to verify the sign is Accessable for the logged in user.
	 *
	 * @param userData
	 * @return
	 */
	public String isSignAccessable(final UserData userData) {
		if (userData == null || userData.isSuperUser()) {
			return AppConstants.YES;
		} else {
			if (userData.getUserPrivilegeMap() != null
					&& userData.getUserPrivilegeMap().containsKey(ESignConstants.SIGN_ACCESS)) {
				return AppConstants.YES;
			} else {
				return AppConstants.NO;
			}
		}
	}

	/**
	 * This method used to verify the settings in sign is Accessable for the logged in user.
	 *
	 * @param userData
	 * @return
	 */
	public String isSettingsAccessable(final UserData userData) {
		if (userData == null || userData.isSuperUser()) {
			return AppConstants.YES;
		} else {
			if (userData.getUserPrivilegeMap() != null
					&& userData.getUserPrivilegeMap().containsKey(ESignConstants.SIGN_CONFIG)) {
				return AppConstants.YES;
			} else {
				return AppConstants.NO;
			}
		}
	}

	/**
	 * This method used to verify the settings in sign is limited for the logged in user.
	 *
	 * @param userData
	 * @return
	 */
	public String isSettingsAccessLimited(final UserData userData) {
		if (userData == null || userData.isSuperUser()) {
			return AppConstants.YES;
		} else {
			if (userData.getUserPrivilegeMap() != null
					&& userData.getUserPrivilegeMap().containsKey(ESignConstants.SIGN_LIMITED_CONFIG)) {
				return AppConstants.YES;
			} else {
				return AppConstants.NO;
			}
		}
	}

	/**
	 * This method used to update the privilege settings in configuration
	 *
	 * @param firmId
	 * @param request
	 */
	public String updatePrivilegeSettings(final Long firmId, final HttpServletRequest request) {
		try {
			final String strPrivilegeSettings = AppHttpUtil.getStringParameterFromRequest(request,
					ESignConstants.REQUEST_PARAM_PRIVILEGE_SETTINGS, null);

			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

			final List<IdxActionPrivilege> privilegeSettings = new Gson().fromJson(strPrivilegeSettings,
					new TypeToken<List<IdxActionPrivilege>>() {
					}.getType());

			idxESignConfiguration.setPrivilegeSettings(privilegeSettings);

			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));
			return AppConstants.RESULT_STATUS_SUCCESS;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updatePrivilegeSettings:exception:", exception);

		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}
	
	/**
	 * To Save Estimate Status Assignment in Settings
	 * 
	 * @param firmId
	 * @param userId
	 * @param userData
	 * @param docObjectId
	 * @param eSignStatus
	 * @param esaUpdateAttributes
	 * @return
	 */
	public Map<String, Object> saveESA(final Long firmId, final Long userId, final UserData userData,
			final Long docObjectId, final String eSignStatus, final String esaUpdateAttributes,
			final String eSignSentUpdateStatus) {
		final Map<String, Object> result = new HashMap<>();

		if (docObjectId == null) {
			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
			result.put(AppConstants.RESULT_REASON, "docObjectId is null");
			return result;
		}

		IdxConfiguration idxConfig = AppSettingsDAO.getInstance().getConfigData(firmId, docObjectId);

		if (idxConfig != null) {
			if (AppConstants.ESIGN_COMPLETED.equalsIgnoreCase(eSignStatus)) {
				if (AppUtil.checkStringNullOrNot(esaUpdateAttributes)) {
					idxConfig.setEsaUpdateAttribute(esaUpdateAttributes);
				} else if (AppUtil.checkStringNullOrNot(eSignSentUpdateStatus)) {
					idxConfig.seteSignSentUpdateStatus(eSignSentUpdateStatus);
				}
			}

			Long configObjectId = AppConstants.objectConfigObjectIdMap.get(docObjectId);
			if(docObjectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
				configObjectId = ObjectConstants.OBJECT_CASES_SETTINGS_DATA;
			}
			AppBaseDAO.getInstance().indexSettingsPack(firmId, configObjectId, idxConfig, userId,
					userData.getFullName());

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			result.put(AppConstants.RESULT_CONFIG_DATA, idxConfig);
		}
		return result;
	}
	
	/**
	 * To Save ESA as enable or disable in Settings
	 * 
	 * @param firmId
	 * @param userId
	 * @param userData
	 * @param docObjectId
	 * @param showESA
	 * @return
	 */
	public Map<String, Object> enableOrDisableESA(final Long firmId, final Long userId, final UserData userData,
			final Long docObjectId, final String showESA) {
		IdxConfiguration idxConfig = AppSettingsDAO.getInstance().getConfigData(firmId, docObjectId);

		idxConfig.setShowESA(showESA);
		
		if (AppConstants.YES.equals(idxConfig.getShowESA())) {
			if (!AppUtil.checkStringNullOrNot(idxConfig.getEsaUpdateAttribute())) {
				if (ObjectConstants.OBJECT_ESTIMATE.equals(docObjectId)) {
					idxConfig.setEsaUpdateAttribute(EstimateElasticService.getInstance()
							.getDefaultUpdateAttribute(AppConstants.ESTIMATE_STATUS_NAME_APPROVED, "3"));
				} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(docObjectId)) {
					idxConfig.setEsaUpdateAttribute(WorkOrdersElasticService.getInstance()
							.getDefaultUpdateAttribute(AppConstants.WORK_ORDER_STATUS_APPROVED, "3"));
				} else if (ObjectConstants.OBJECT_CASE.equals(docObjectId)
						|| docObjectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
					idxConfig.setEsaUpdateAttribute(null);
				}
			}
			if (!AppUtil.checkStringNullOrNot(idxConfig.geteSignSentUpdateStatus())) {
				if (ObjectConstants.OBJECT_ESTIMATE.equals(docObjectId)) {
					idxConfig.seteSignSentUpdateStatus(EstimateElasticService.getInstance()
							.getDefaultUpdateAttribute(AppConstants.ESTIMATE_STATUS_NAME_SENT, "2"));
				} else if (ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(docObjectId)) {
					idxConfig.seteSignSentUpdateStatus(WorkOrdersElasticService.getInstance()
							.getDefaultUpdateAttribute(AppConstants.WORK_ORDER_STATUS_SUBMITTED, "2"));
				} else if (ObjectConstants.OBJECT_CASE.equals(docObjectId)
						|| docObjectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
					idxConfig.seteSignSentUpdateStatus(null);
				}
			}
		}

		Long configObjectId = AppConstants.objectConfigObjectIdMap.get(docObjectId);
		if(docObjectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			configObjectId = ObjectConstants.OBJECT_CASES_SETTINGS_DATA;
		}

		AppBaseDAO.getInstance().indexSettingsPack(firmId, configObjectId, idxConfig, userId, userData.getFullName());

		final Map<String, Object> result = new HashMap<>();
		result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
		result.put(AppConstants.RESULT_CONFIG_DATA, idxConfig);
		return result;
	}

	/**
	 * This method used to trigger the ESA for completed Document.
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @param objectId
	 * @param objectRefId
	 * @return
	 */
	public void triggerESA(final Long firmId, final IdxESignDocument idxESignDocument,
			final Long objectId, final Long objectRefId) {
		if (ObjectConstants.OBJECT_ESTIMATE.equals(objectId)
				|| ObjectConstants.OBJECT_SERVICE_WORK_ORDERS.equals(objectId)
				|| ObjectConstants.OBJECT_CASE.equals(objectId)
				|| objectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			final IdxConfiguration idxConfiguration = AppSettingsDAO.getInstance().getConfigData(firmId, objectId);
			if (idxConfiguration != null && AppConstants.YES.equals(idxConfiguration.getShowESA())) {
				final Long userId = idxESignDocument.getCreatedBy();
				final UserData userData = LoginDAO.getInstance().getUserData(firmId, userId);
				executeESAUpdateAttributeAction(firmId, userId, userData, idxConfiguration, objectId, objectRefId,
						null, AppConstants.ESIGN_COMPLETED);
			}
		}
	}

	/**
	 * To execute update attribute action configured in ESA
	 *
	 * @param firmId
	 * @param userId
	 * @param userData
	 * @param idxConfiguration
	 * @param docObjectId
	 * @param docObjectRefId
	 * @param request
	 * @return
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public String executeESAUpdateAttributeAction(final Long firmId, final Long userId, final UserData userData,
			final IdxConfiguration idxConfiguration, Long docObjectId, final Long docObjectRefId,
			final HttpServletRequest request, final String statusFor) {
		if (docObjectId == null || docObjectRefId == null) {
			return AppConstants.MSG_INVALID_PARAMS;
		}
		String result = "";
		Map<String, Object> resultMap;
		Long objectId = docObjectId;
		if (docObjectId >= AppConstants.APP_BUILDER_APPS_START_OBJECT_ID) {
			docObjectId = ObjectConstants.OBJECT_CASE;
		}

		Class clazz = ObjectConstants.getAppClassForObjectId(docObjectId);
		Object oldObject = ElasticSearchDAO.getInstance().getDocument(firmId, clazz, docObjectId, docObjectRefId);
		Object newObject = ElasticSearchDAO.getInstance().getDocument(firmId, clazz, docObjectId, docObjectRefId);

		if (idxConfiguration != null) {
			if (AppConstants.YES.equals(idxConfiguration.getShowESA()) && AppUtil.checkStringNullOrNot(statusFor)) {
				String updateAttributes = null;
				if (AppConstants.ESIGN_COMPLETED.equals(statusFor)) {
					updateAttributes = idxConfiguration.getEsaUpdateAttribute();
				} else if (AppConstants.ESIGN_SENT.equals(statusFor)) {
					updateAttributes = idxConfiguration.geteSignSentUpdateStatus();
				}
				if (AppUtil.checkStringNullOrNot(updateAttributes)) {
					Type idxObjectType = new TypeToken<ArrayList<IdxTriggerUpdateAttribute>>() {
					}.getType();
					List<IdxTriggerUpdateAttribute> updateAttributeList = AppUtil.convertFromJson(idxObjectType,
							updateAttributes);
					boolean isUpdatedNewObject = false;
					IdxTriggerAction triggerAction;
					if (AppUtil.checkListisNullOrNot(updateAttributeList)) {
						for (IdxTriggerUpdateAttribute triggerUpdateAttribute : updateAttributeList) {
							triggerAction = new IdxTriggerAction();
							triggerAction.setUpdateAttribute(triggerUpdateAttribute);
					
							try {
								resultMap = UpdateAttributeAction.getInstance().executeAction(firmId, objectId, docObjectRefId,
										newObject, triggerAction, null, userData, null, null, null);
								if (AppUtil.checkMapIsNullOrNot(resultMap) && resultMap.get(AppConstants.UPDATED_OBJECT) != null) {
									newObject = resultMap.get(AppConstants.UPDATED_OBJECT);
									isUpdatedNewObject = true;
								}
							} catch (Exception e) {
								logger.error(firmId, "ESignatureService:executeESAUpdateAttributeAction:UpdateAttribute:exception:", e);
							}
						}
					}
					if (newObject != null) {
						if (isUpdatedNewObject) {
							ElasticSearchDAO.getInstance().indexDocument(firmId, docObjectId, docObjectRefId,
									AppUtil.convertToJson(newObject));
						}
						final HashMap<String, Object> triggersResult = ProcessTriggerService.getInstance().processTriggers(firmId,
								userId, userData, objectId, AppConstants.TRIGGER_EVENT_TYPE_UPDATE, request,
								(IdxFirmBaseData) oldObject, (IdxFirmBaseData) newObject);
						if ((AppUtil.checkMapIsNullOrNot(triggersResult)) && (triggersResult.get(AppConstants.UPDATED_OBJECT) != null)) {
							newObject = triggersResult.get(AppConstants.UPDATED_OBJECT);
							ElasticSearchDAO.getInstance().indexDocument(firmId, clazz, docObjectId,
									docObjectRefId.toString(), AppUtil.convertToJson(newObject));
						}
						if (ObjectConstants.OBJECT_ESTIMATE.equals(docObjectId))
						{
						IdxEstimateConfiguration estimateConfig = (IdxEstimateConfiguration) idxConfiguration;
						IdxEstimate idxEstimate = ElasticSearchDAO.getInstance().getDocument(firmId,
								IdxEstimate.class, docObjectId, docObjectRefId);
						// Highlighting
						EstimateService.getInstance().updateHighlighting(firmId, userId, userData, estimateConfig,idxEstimate);
						}
						result = AppConstants.STATUS_CODE_SUCCESS;
					}
				}
			} else {
				result = "ESA Toggle is disabled";
			}
		}
		return result;
	}

	/**
	 * This method used to check the esign enabled or not based on the home configuration and idxFirm
	 *
	 * @param firmId
	 * @return
	 */
	public String isESignEnabled(final Long firmId) {
		try {
			final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

			if (idxFirm.geteSignEnabled() == null) {
				final IdxHomeConfiguration configuration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
						IdxHomeConfiguration.class, ObjectConstants.OBJECT_HOME_SETTINGS_DATA, firmId);
				if (configuration != null) {
					return configuration.getIsEsignEnabled();
				}
			}
			return idxFirm.geteSignEnabled();
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:isESignEnabled:exception:", exception);
			return AppConstants.NO;
		}
	}

	/**
	 * This method used to validate the esign document usage based on credit or sign.co doc limit
	 *
	 * @param firmId
	 * @return
	 */
	public Map<String, String> validateESignDocLimit(final Long firmId) {
		final Map<String, String> result = new HashMap<>();
		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		if (idxFirm.geteSignEnabled() == null) {
			final IdxHomeConfiguration configuration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
					IdxHomeConfiguration.class, ObjectConstants.OBJECT_HOME_SETTINGS_DATA, firmId);
			if (configuration != null) {
				final IdxQuotaBalance quotaBalance = ElasticSearchDAO.getInstance().getDocumentByFieldName(firmId,
						IdxQuotaBalance.class, ObjectConstants.OBJECT_QUOTA_BALANCE.toString(), AppConstants.FIRM_ID,
						firmId.toString());
				if (quotaBalance != null && (quotaBalance.getCurrentBalance() == null
						|| quotaBalance.getCurrentBalance().doubleValue() <= 0d)) {
					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
					result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_INSUFFICIENT_CREDITS);
				}
			}
		} else {
			final Map<String, Object> planDetails = getPlanInformation(firmId, null);
			logger.info(firmId, "ESignatureService:validateESignDocLimit:planDetails:" + planDetails);

			if (planDetails != null) {
				final Long remainingDocCount = Long
						.valueOf(planDetails.get(AppConstants.REMAINING_DOC_COUNT).toString());
				if (remainingDocCount <= 0L) {
					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
					result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_DOC_LIMIT_EXISTS);
				} else if (AppConstants.YES.equals(planDetails.get(AppConstants.IS_TRIAL_EXPIRED))) {
					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
					result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_TRAIL_PLAN_EXPIRED);
				} else if (AppConstants.YES.equals(planDetails.get(AppConstants.IS_PLAN_EXPIRED))) {
					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
					result.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_PLAN_EXPIRED);
				}
			} else {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			}
		}
		return result;
	}

	/**
	 * This method used to update the esign credit usage
	 *
	 * @param firmId
	 * @param userId
	 * @param docObjectId
	 * @param sourceRefId
	 * @param docObjectRefId
	 * @param userData
	 */
	public void updateESignCreditUsage(final Long firmId, final Long userId, final Long docObjectId, final String sourceRefId, 
			final Long docObjectRefId, final UserData userData) {
		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		if (idxFirm.geteSignEnabled() == null) {
			BillingServicesDAO.getInstance().recordUsage(firmId, userId, AppConstants.SERVICE_CODE_ESIGNATURE,
						BigDecimal.valueOf(1), docObjectId, sourceRefId, docObjectRefId, userData);
		} else {
			updateDocLimitUsage(firmId);
		}
	}

	/**
	 * This method used to get the esign integration data
	 *
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public Map<String, Object> getESignIntegrationData(final Long firmId, final UserData userData) {
		final Map<String, Object> result = new HashMap<>();

		final String id = firmId + "_" + AppConstants.APP_CODE_APPTIVO + "_" + AppConstants.APP_CODE_SIGN;

		final IdxAppIntegrationRequest idxAppIntegration = ElasticSearchDAO.getInstance().getDocument(firmId,
				IdxAppIntegrationRequest.class, ObjectConstants.OBJECT_APP_INTEGRATION_REQUEST, id);

		if (idxAppIntegration != null && ESignConstants.ENABLED.equalsIgnoreCase(idxAppIntegration.getStatusCode())) {
			result.put("integrationData", idxAppIntegration);

			final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);
			result.put("businessName", idxFirm.getFirmName());
			result.put("ownerEmail", idxFirm.getFirmOwnerEmailId());

			result.putAll(getPlanInformation(firmId, userData));
			result.put("planName", ESignConstants.SIGN_PLAN_NAMES.get(result.get(AppConstants.ATTR_PLAN_CODE)));
			result.put("totalDoc", ESignConstants.DOC_LIMIT_BY_PLAN_CODE.get(result.get(AppConstants.ATTR_PLAN_CODE)));

			result.put(AppConstants.RESULT_DATA, idxFirm.geteSignEnabled());

			// To get the redirection URL to the manage billing
			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);

			final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
			boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
			boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.APP, AppConstants.APP_CODE_SIGN));
			boolQueryBuilder.must(QueryBuilders.termsQuery(AppConstants.EMAIL_ID, userData.getEmailId()));

			final List<IdxFirmEmpContact> contact = ElasticSearchDAO.getInstance().getAllDocumentsByBoolFilter(
					adminFirmId, ObjectConstants.OBJECT_FIRM_EMP_CONTACT, boolQueryBuilder, IdxFirmEmpContact.class);
			logger.info(firmId, "ESignatureService:updateESignIntegration:contact:" + contact);

			if (userData.isSuperUser() && AppConstants.YES.equals(idxFirm.geteSignEnabled())
					&& AppUtil.checkListisNullOrNot(contact) && AppConstants.YES.equals(contact.get(0).getIsAppAccessEnabled())) {

				String redirectUrl = AppBaseDAO.getInstance().getEnvProperty(ESignConstants.SIGN_BASE_URL, AppConstants.YES);
				redirectUrl += "appsso?a=validateLogin&to=bil&vid=";

				final IdxUserSession userSession = AppSessionDAO.getInstance().getUserSession(userData.getSessionKey());
				userSession.setVid(UUIDs.base64UUID());
				AppSessionDAO.getInstance().updateUserSession(userSession);
				
				redirectUrl += userSession.getVid();

				AppExceptionService.logThreadSleep(firmId, null, null, AppConstants.DELAY.intValue());
				try {
					Thread.sleep(1000);
				} catch (Exception exception) {
					logger.error(firmId, "ESignatureService:getESignIntegrationData:exception:", exception);
				}
				result.put("manageAcctUrl", redirectUrl);
			}
		}
		return result;
	}

	/**
	 * This method used to update the esignIntegration Data.
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> updateESignIntegration(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final String isEnabled = AppHttpUtil.getStringParameter(request, ESignConstants.IS_ENABLED, AppConstants.BOOLEAN_FALSE);
		final String isOldESignEnabled = AppHttpUtil.getStringParameter(request, "isOldESignEnabled", AppConstants.BOOLEAN_FALSE);

		final Map<String, Object> result = new HashMap<>();

		if(userData.isSuperUser() || AppConstants.NO.equalsIgnoreCase(isEnabled)) {
			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);
			final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

			final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
			boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
			boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.APP, AppConstants.APP_CODE_SIGN));
			boolQueryBuilder.must(QueryBuilders.termsQuery(AppConstants.EMAIL_ID, userData.getEmailId()));

			final List<IdxFirmEmpContact> contact = ElasticSearchDAO.getInstance().getAllDocumentsByBoolFilter(
					adminFirmId, ObjectConstants.OBJECT_FIRM_EMP_CONTACT, boolQueryBuilder, IdxFirmEmpContact.class);
			logger.info(firmId, "ESignatureService:updateESignIntegration:contact:" + contact);

			if ((AppUtil.checkListisNullOrNot(contact) && AppConstants.YES.equals(contact.get(0).getIsAppAccessEnabled()))
					 || AppConstants.NO.equalsIgnoreCase(isEnabled)) {
				final String currentDate = DateUtil.getEsDateFormat().format(new Date());

				IdxAppIntegrationRequest idxAppIntReq = ElasticSearchDAO.getInstance().getDocument(firmId,
						IdxAppIntegrationRequest.class, ObjectConstants.OBJECT_APP_INTEGRATION_REQUEST,
						firmId + "_" + AppConstants.APP_CODE_APPTIVO + "_"
								+ AppConstants.APP_CODE_SIGN);
				if(idxAppIntReq == null) {
					final IdxSmplObj employeeObj = new IdxSmplObj();
					employeeObj.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
					employeeObj.setObjectRefId(userData.getEmployeeId());
					employeeObj.setObjectName(AppConstants.EMPLOYEE_OBJECT_NAME);
					employeeObj.setObjectRefName(userData.getFullName());

					idxAppIntReq = new IdxAppIntegrationRequest();
					idxAppIntReq.setFirmId(firmId);
					idxAppIntReq.setFromApp(AppConstants.APP_CODE_APPTIVO);
					idxAppIntReq.setToApp(AppConstants.APP_CODE_SIGN);
					idxAppIntReq.setStatusCode(ESignConstants.ENABLED);
					idxAppIntReq.setRqb(employeeObj);
					idxAppIntReq.setAby(employeeObj);
					idxAppIntReq.setCreationDate(currentDate);
					idxAppIntReq.setCreatedBy(userData.getUserId());
					idxAppIntReq.setCreatedByName(userData.getFullName());
					idxAppIntReq.setLastUpdateDate(currentDate);
					idxAppIntReq.setLastUpdatedBy(userData.getUserId());
					idxAppIntReq.setLastUpdatedByName(userData.getFullName());
				} else {
					final String statusCode = AppConstants.YES.equals(isEnabled) ? ESignConstants.ENABLED : ESignConstants.DISABLED;
					idxAppIntReq.setStatusCode(statusCode);
					idxAppIntReq.setLastUpdateDate(currentDate);
					idxAppIntReq.setLastUpdatedBy(userData.getUserId());
					idxAppIntReq.setLastUpdatedByName(userData.getFullName());
				}
				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_APP_INTEGRATION_REQUEST,
						idxAppIntReq.getId(), AppUtil.convertToJson(idxAppIntReq));

				idxFirm.seteSignEnabled(isEnabled);
				FirmDAO.getInstance().update(idxFirm);

				updateApptivoCustomer(firmId, isEnabled, true);

				if(AppConstants.YES.equals(isOldESignEnabled)) {
					final IdxHomeConfiguration homeConfiguration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
							IdxHomeConfiguration.class, ObjectConstants.OBJECT_HOME_SETTINGS_DATA, firmId);
					if (homeConfiguration != null) {
						homeConfiguration.setIsEsignEnabled(AppConstants.NO);
						ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxHomeConfiguration.class,
								ObjectConstants.OBJECT_HOME_SETTINGS_DATA, firmId,
								AppUtil.convertToJson(homeConfiguration));
					}
				}

				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				return result;
			} else if(AppUtil.checkListisNullOrNot(contact) && AppConstants.NO.equals(contact.get(0).getIsAppAccessEnabled())) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				result.put(AppConstants.RESULT_REASON, "Request Access");
			} else if(!AppUtil.checkListisNullOrNot(contact)) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				result.put(AppConstants.RESULT_REASON, "Need Signup");
				return result;
			}
			
		} else {
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			result.put(AppConstants.RESULT_REASON, "Request Access");
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to enable the sign account from Alert Prompt
	 * 
	 * @param firmId
	 * @return
	 */
	public Map<String, String> enableSignAccount(final Long firmId, final UserData userData) {
		final Map<String, String> result = new HashMap<>();

		try {
			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);
			final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

			// Is Customer exists in firm or not.
			final IdxFirmCustomer idxFirmCustomer = idxFirm.getCustomerByAppCode(AppConstants.APP_CODE_SIGN);
			if(idxFirmCustomer == null) {
				FirmEmpContactService.getInstance().createFirmEmpContactForExistFirm(adminFirmId, idxFirm,
						AppConstants.APP_CODE_SIGN);
			}

			idxFirm.seteSignEnabled(AppConstants.YES);
			FirmDAO.getInstance().update(idxFirm);

			updateApptivoCustomer(firmId, AppConstants.YES, false);

			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final IdxSmplObj employeeObj = new IdxSmplObj();
			employeeObj.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
			employeeObj.setObjectRefId(userData.getEmployeeId());
			employeeObj.setObjectName(AppConstants.EMPLOYEE_OBJECT_NAME);
			employeeObj.setObjectRefName(userData.getFullName());

			final IdxAppIntegrationRequest idxAppIntReq = new IdxAppIntegrationRequest();
			idxAppIntReq.setFirmId(firmId);
			idxAppIntReq.setFromApp(AppConstants.APP_CODE_APPTIVO);
			idxAppIntReq.setToApp(AppConstants.APP_CODE_SIGN);
			idxAppIntReq.setStatusCode(ESignConstants.ENABLED);
			idxAppIntReq.setRqb(employeeObj);
			idxAppIntReq.setAby(employeeObj);
			idxAppIntReq.setCreationDate(currentDate);
			idxAppIntReq.setCreatedBy(userData.getUserId());
			idxAppIntReq.setCreatedByName(userData.getFullName());
			idxAppIntReq.setLastUpdateDate(currentDate);
			idxAppIntReq.setLastUpdatedBy(userData.getUserId());
			idxAppIntReq.setLastUpdatedByName(userData.getFullName());
			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_APP_INTEGRATION_REQUEST,
					idxAppIntReq.getId(), AppUtil.convertToJson(idxAppIntReq));

			String redirectUrl = AppBaseDAO.getInstance().getEnvProperty(ESignConstants.SIGN_BASE_URL, AppConstants.YES);
			redirectUrl += "appsso?a=validateLogin&vid=";

			final IdxUserSession userSession = AppSessionDAO.getInstance().getUserSession(userData.getSessionKey());
			userSession.setVid(UUIDs.base64UUID());
			AppSessionDAO.getInstance().updateUserSession(userSession);

			redirectUrl += userSession.getVid();

			AppExceptionService.logThreadSleep(firmId, null, null, AppConstants.DELAY.intValue());
			Thread.sleep(1000);

			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			result.put("redirectURL", redirectUrl);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:enableSignAccount:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		}
		return result;
	}

	/**
	 * This Method used to request the access for integrating the Sign.co
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, String> requestAccess(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final Map<String, String> result = new HashMap<>();
		try {
			final String customMessage = AppHttpUtil.getStringParameter(request, "customMessage", null);

			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);

			final List<Long> empIds = EmployeeDAO.getInstance().getSuperUserEmployeeIds(firmId);

			final IdxEmployee idxEmployee = EmployeeDAO.getInstance().getById(firmId, empIds.get(0));

			final IdxConfiguration customerConfiguration = ElasticSearchDAO.getInstance().getConfigDocument(adminFirmId,
					IdxCustomersConfiguration.class, ObjectConstants.OBJECT_CUSTOMERS_SETTINGS_DATA, adminFirmId);

			final IdxEmailTemplate idxEmailTemplate = getEmailTemplateByTemplateName(ESignConstants.REQUEST_SIGN_ACCESS,
					customerConfiguration);

			final Map<String, String> mailSubjectValues = new HashMap<>();

			// Preparing mail body for template.
			final Map<String, String> mailBodyValues = new HashMap<>();
			mailBodyValues.put("ADMIN_NAME", idxEmployee.getFullName());
			mailBodyValues.put("USER_NAME", userData.getFullName());
			mailBodyValues.put("BUSINESS_NAME", userData.getBusinessName());

			if (AppUtil.checkStringNullOrNot(customMessage)) {
				mailBodyValues.put("CUSTOM_MESSAGE",
						"You have a message from " + userData.getFullName() + "</td></tr><tr><td>" + customMessage);
			} else {
				mailBodyValues.put("CUSTOM_MESSAGE", "");
			}

			idxEmailTemplate.setFromEmailId(getFromAddressForTemplate(null));
			idxEmailTemplate.setReplyToEmailId(getFromAddressForTemplate(null));
			idxEmailTemplate.setFromName(ESignConstants.ESIGN_FROM_EMAIL_NAME);
			idxEmailTemplate.setToEmailId(idxEmployee.getEmailId());

			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);

			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:requestAccess:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to validate the active session
	 *
	 * @param vid
	 * @param request
	 * @param response
	 *
	 * @return
	 */
	public boolean validateActiveSession(final String vid, final HttpServletRequest request,
			final HttpServletResponse response) {
		final String ipAddress = HttpUtil.getClientIPAddress(request);
		final String userAgent = AppHttpUtil.getUserAgent(request);

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(AppConstants.CFDB_ID)
				.prepareSearch(ElasticSearchDAO.getInstance().getIndexName(0L, ObjectConstants.OBJECT_SESSION_KEY))
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();

		//FIXME
		String evid = AppEncryptionService.encrypt(vid, AppEncryptionService.KV_1, AppEncryptionService.NIV1);
		
		andBuilder.must(QueryBuilders.termQuery("isActive", AppConstants.YES));
		andBuilder.must(QueryBuilders.termQuery("vid", evid));

		if (ipAddress != null) {
			andBuilder.must(QueryBuilders.termQuery("clientIpAddress", ipAddress));
		} else {
			andBuilder.mustNot(QueryBuilders.existsQuery("clientIpAddress"));
		}

		if (userAgent != null) {
			andBuilder.must(QueryBuilders.termQuery("userAgent", userAgent));
		} else {
			andBuilder.mustNot(QueryBuilders.existsQuery("userAgent"));
		}

		builder.setPostFilter(andBuilder);
		builder.setSize(1);

		final SearchResponse searchResponse = builder.execute().actionGet();
		final SearchHits searchHits = searchResponse.getHits();

		if (searchHits.getHits().length > 0) {
			final IdxUserSession valSession = AppUtil.convertFromJson(IdxUserSession.class,
					searchHits.getHits()[0].getSourceAsString());
			logger.info(0L, "AppSessionFilter:doFilter:valSession:" + valSession);

			if (valSession != null) {
				request.setAttribute("loggedin", AppConstants.STR_TRUE);
				request.setAttribute(AppConstants.EMAIL_ID, valSession.getEmailId());

				request.getSession().setAttribute("loggedin", AppConstants.STR_TRUE);
				request.getSession().setAttribute(AppConstants.EMAIL_ID, valSession.getEmailId());
				request.getSession().setAttribute("loggedinTime", new Date());
				request.getSession().setAttribute("registeredUserSession", "LOGIN");

				request.getSession().setAttribute(AppConstants.FIRM_ID, valSession.getFirmId());
				request.setAttribute(AppConstants.FIRM_ID, valSession.getFirmId());

				request.getSession().setAttribute("userId", valSession.getUserId());
				request.setAttribute("userId", valSession.getUserId());

				final AppUserConfiguration userConfiguration = new AppUserConfiguration();
				userConfiguration.initialize(valSession.getFirmId(), valSession.getUserId(), request, response);

				request.getSession().setAttribute("sessionToken", userConfiguration.getSessionToken());
				request.setAttribute("sessionToken", userConfiguration.getSessionToken());

				request.getSession().setAttribute("sessionKey", userConfiguration.getSessionKey());
				request.setAttribute("sessionKey", userConfiguration.getSessionKey());

				return true;
			}
		}
		return false;
	}

	/**
	 * This method used to verify the document is expired or not.
	 *
	 * @param idxESignDocument
	 * @return
	 */
	public boolean isDocExpired(final IdxESignDocument idxESignDocument) {
		boolean isExpired = false;
		if (idxESignDocument != null && ESignConstants.SEND_SIGN.equalsIgnoreCase(idxESignDocument.getSignType())
				&& idxESignDocument.getExpDate() != null) {
			final Date startDate = DateUtil.parseDate(idxESignDocument.getExpDate(), DateUtil.getEsDateFormat(), null);
			final Date currentDate = new Date();

			if (currentDate.compareTo(startDate) > 0) {
				isExpired = true;
			}
		}
		return isExpired;
	}

	/**
	 * This method used to send the remainder while clicking on the overview page
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public String sendReminder(final Long firmId, final UserData userData, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String customMessage = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_MESSAGE, "");

		final String[] include = {};
		final String[] exclude = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
				ESignConstants.ESIGN_SIGNED_DOCUMENT };
		final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, include, exclude);

		if (idxESignDocument != null) {
			final IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
					ESignConstants.DOCUMENT_REMINDER);
			idxESignDocument.setCustomSubject(idxEmailTemplate.getSubject());
			sendEmail(firmId, idxEmailTemplate, idxESignDocument, customMessage);

			return AppConstants.RESULT_STATUS_SUCCESS;
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to add or update the reminder.
	 *
	 * @param firmId
	 * @param userId
	 * @param objectId
	 * @param userData
	 * @param request
	 * @return
	 */
	public String addOrUpdateReminder(final Long firmId, final Long userId, final Long objectId,
			final UserData userData, final HttpServletRequest request) {
		final String reminderLineData = AppHttpUtil.getStringParameter(request, "reminderLineData", null);
		final IdxReminderLine reminderLine = AppUtil.convertFromJson(IdxReminderLine.class, reminderLineData);

		final IdxESignConfiguration idxESignConfiguration = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId);

		final Map<String, Object> result = new HashMap<>();
		if (idxESignConfiguration != null) {
			List<IdxReminderLine> reminderLines = idxESignConfiguration.getReminderLines();
			if (reminderLines == null) {
				reminderLines = new ArrayList<>();
			}
			IdxReminderLine tmpReminderLine = new IdxReminderLine();
			for (final IdxReminderLine tmpRemLine : reminderLines) {
				if ((reminderLine.getId() != null) && tmpRemLine.getId().equals(reminderLine.getId())) {
					tmpReminderLine = tmpRemLine;
					break;
				}
			}
			IdxAutoReminderConfigLine tmpReminderConfigLine;
			if (reminderLine.getId() != null) {
				tmpReminderConfigLine = EstimatesDAO.getInstance().getAutoReminderConfigLine(firmId,
						reminderLine.getId(), objectId);
			} else {
				tmpReminderConfigLine = new IdxAutoReminderConfigLine();
				tmpReminderConfigLine.setFirmId(firmId);
//				final IdxAutoReminderConfig idxAutoReminderConfig = CommonDAO.getInstance()
//						.getAutoReminderConfigByObjectId(objectId);
//				tmpReminderConfigLine.setAutoReminderConfigId(idxAutoReminderConfig.getAutoReminderConfigId());
				tmpReminderConfigLine.setAutoReminderConfigLineId(AppBaseDAO.getInstance().getSequenceNextVal(firmId,
						AppConstants.APP_SEQ_AUTO_REMINDER_CONFIG_LINE_ID));
			}

			tmpReminderConfigLine.setMessageTemplateId(Long.valueOf(reminderLine.getEmailTemplateId()));
			tmpReminderConfigLine.setDaysBeforeAfterCheckDate(reminderLine.getDaysBeforeAfterCheckDate().longValue());
			tmpReminderConfigLine.setReminderSendOption(reminderLine.getReminderSendOption());
			tmpReminderConfigLine.setFirmId(firmId);
			tmpReminderConfigLine.setObjectId(objectId);
			tmpReminderConfigLine.setEnabled(reminderLine.getIsEnabled());
			ElasticSearchDAO.getInstance().setCommonProperties(tmpReminderConfigLine, userId);

			if (reminderLine.getId() != null) {
				ElasticSearchDAO.getInstance().indexDocument(firmId, IdxAutoReminderConfigLine.class,
						ObjectConstants.OBJECT_REMAINDER_CONFIG_LINE,
						tmpReminderConfigLine.getAutoReminderConfigLineId(),
						AppUtil.convertToJson(tmpReminderConfigLine));
			} else {
				tmpReminderConfigLine = ElasticSearchDAO.getInstance().createDocument(firmId,
						IdxAutoReminderConfigLine.class, ObjectConstants.OBJECT_REMAINDER_CONFIG_LINE,
						tmpReminderConfigLine.getAutoReminderConfigLineId(),
						AppUtil.convertToJson(tmpReminderConfigLine));
				tmpReminderLine.setId(tmpReminderConfigLine.getAutoReminderConfigLineId());
				reminderLines.add(tmpReminderLine);
			}

			tmpReminderLine.setDaysBeforeAfterCheckDate(reminderLine.getDaysBeforeAfterCheckDate());
			tmpReminderLine.setReminderSendOption(reminderLine.getReminderSendOption());
			tmpReminderLine.setEmailTemplateId(reminderLine.getEmailTemplateId());
			tmpReminderLine.setIsEnabled(reminderLine.getIsEnabled());
			idxESignConfiguration.setReminderLines(reminderLines);
			AppBaseDAO.getInstance().indexSettingsPack(firmId, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA,
					idxESignConfiguration, userId, userData.getFullName());

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			result.put("reminderLine", tmpReminderLine);
		} else {
			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
			result.put(AppConstants.RESULT_REASON, AppConstants.IDX_CONFIG_NOT_FOUND);
		}
		return AppUtil.convertToJson(result);
	}

	/**
	 * This method used to delete the reminder line from configuration
	 *
	 * @param firmId
	 * @param userId
	 * @param objectId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, String> deleteReminderConfig(final Long firmId, final Long userId, final Long objectId,
			final UserData userData, final HttpServletRequest request) {
		final Long reminderLineId = AppHttpUtil.getLongParameter(request, "reminderLineId", null);

		final Map<String, String> result = new HashMap<>();

		final IdxESignConfiguration idxConfig = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId);

		if (idxConfig != null) {
			final boolean isDeleted = EstimatesDAO.getInstance().deleteAutoReminderConfigLine(firmId, reminderLineId,
					objectId);
			logger.info(firmId, "ESigatureService:deleteReminderConfig:isDeleted:" + isDeleted);

			if (isDeleted) {
				final List<IdxReminderLine> reminderLines = idxConfig.getReminderLines();

				final Iterator<IdxReminderLine> iterator = reminderLines.iterator();

				while (iterator.hasNext()) {
					final IdxReminderLine tmpReminderLine = iterator.next();
					if (tmpReminderLine.getId().equals(reminderLineId)) {
						iterator.remove();
					}
				}
				AppBaseDAO.getInstance().indexSettingsPack(firmId, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA,
						idxConfig, userId, userData.getFullName());

				result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
				return result;
			}
			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		} else {
			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
			result.put(AppConstants.RESULT_REASON, AppConstants.IDX_CONFIG_NOT_FOUND);
		}
		return result;
	}

	/**
	 * This method used to set the expired template details.
	 *
	 * @param firmId
	 * @param config
	 * @param strReminderDates
	 * @param numDaysRemLineMap
	 */
	public void setExpiredTemplate(final Long firmId, final IdxESignConfiguration config,
			final List<String> strReminderDates, final Map<Integer, IdxReminderLine> numDaysRemLineMap, final TimeZone timeZone) {
		final SimpleDateFormat esFormat = DateUtil.getEsDateFormat();
		esFormat.setTimeZone(timeZone);

		final IdxEmailTemplate expiredEmailTemplate = config
				.getEmailTemplateByMessageType(ESignConstants.DOCUMENT_EXPIRED);
		logger.info(firmId, "ESignatureService:setExpiredTemplate:expiredEmailTemplate:" + expiredEmailTemplate);

		if (expiredEmailTemplate != null) {
			final String yesterdayDateStr = DateUtil.formatDate(DateUtil.getEndOfYesterday(), esFormat);
			strReminderDates.add(yesterdayDateStr);

			final String emailTemplateId = String.valueOf(expiredEmailTemplate.getId());
			final IdxReminderLine expiredReminderLine = new IdxReminderLine();
			expiredReminderLine.setEmailTemplateId(emailTemplateId);
			numDaysRemLineMap.put(-1, expiredReminderLine);
			logger.info(firmId, "ESignatureService:setExpiredTemplate:numDaysRemLineMap:" + numDaysRemLineMap);
		}
	}

	/**
	 * This method used to get the already sent expired reminders document ids 
	 * @param firmId
	 * @return
	 */
	public List<Long> alreadySentExpiredReminderDoc(final Long firmId, final TimeZone timeZone) {
		final SimpleDateFormat esFormat = DateUtil.getEsDateFormat();
		esFormat.setTimeZone(timeZone);
		final Calendar calendar = Calendar.getInstance();
		final Date startDate = DateUtil.getStartOfDay(calendar);
		final Date endDate = DateUtil.getEndOfDay(calendar);

		final String startDateStr = DateUtil.formatDate(startDate, esFormat);
		final String endDateStr = DateUtil.formatDate(endDate, esFormat);
		final BoolQueryBuilder query = QueryBuilders.boolQuery();
		query.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		query.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_ID, ObjectConstants.OBJECT_ESIGN_DOCUMENT));

		final RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery("reminderSentDate").gte(startDateStr)
				.lte(endDateStr);
		query.must(rangeQueryBuilder);
		return ElasticSearchDAO.getInstance().getAllSelectedFieldIds(firmId, ObjectConstants.OBJECT_AUTO_REMAINDER,
				query, AppConstants.STR_OBJECT_REF_ID);
	}

	/**
	 * This method used to update the status field by document id.
	 *
	 * @param firmId
	 * @param documentId
	 * @param documentStatus
	 */
	public void updateStatusFieldByDocId(final Long firmId, final Long documentId, final String documentStatus) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + "){");
		updateScript.append(AppUtil.appendScript("ctx._source.statusCode", documentStatus.toUpperCase(),
				ESignConstants.STATUS_CODE, scriptParams));
		updateScript.append(AppUtil.appendScript("ctx._source.statusName", documentStatus,
				ESignConstants.STATUS_NAME, scriptParams));
		AppUtil.appendLastUpdatedDate(updateScript, scriptParams);
		updateScript.append("}");

		updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}
	
	/**
	 * This method used to send email based on the email Template.
	 *
	 * @param firmId
	 * @param idxEmailTemplate
	 * @param idxESignDocument
	 * @param customMessage
	 */
	public void sendEmail(final Long firmId, final IdxEmailTemplate idxEmailTemplate,
			final IdxESignDocument idxESignDocument, final String customMessage) {
		final String documentUrl = getDocumentRedirectionURL(firmId, idxESignDocument.geteSignDocumentId(), null,
				ObjectConstants.OBJECT_ESIGN_DOCUMENT, null);

		if(customMessage != null) {
			idxESignDocument.setCustomMessage(customMessage);
			customizeMailTemplateContent(idxEmailTemplate, idxESignDocument);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// For preparing mail subject and body for email template.
		final Map<String, String> mailSubjectValues = new HashMap<>();
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);

		updateBrandingContent(firmId, idxESignDocument.getbId(), mailBodyValues);
		// Sending Email to signers.
		for (IdxESignSigner idxSigner : idxESignDocument.getSignerForReminder()) {
			// Preparing toAddress for Email Template.
			idxEmailTemplate.setToEmailId(idxSigner.getPrimaryEmailId());

			prepareESignAttrForRequestSign(idxESignDocument, idxSigner, documentUrl, mailSubjectValues, mailBodyValues);

			prepareEmailAddresses(idxESignDocument, idxEmailTemplate, false);

			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);

			// If isSequential is true, request sign to first signer of the document alone.
			if (Boolean.TRUE.equals(idxESignDocument.getIsSequential())) {
				break;
			}
		}
	}

	/**
	 * This method used to save the auto reminder.
	 *
	 * @param firmId
	 * @param userId
	 * @param configLineId
	 * @param objRefId
	 */
	public void saveAutoReminder(final Long firmId, final Long userId, final Long configLineId, final Long objRefId) {
		final IdxAutoReminder reminderQueue = new IdxAutoReminder();
		reminderQueue.setAutoReminderConfigLineId(configLineId);
		reminderQueue.setObjectRefId(objRefId);
		reminderQueue.setFirmId(firmId);
		reminderQueue.setObjectId(ObjectConstants.OBJECT_ESIGN_DOCUMENT);
		reminderQueue.setReminderSentDate(DateUtil.getEsDateFormat().format(new Date()));
		reminderQueue.setAutoReminderId(
				AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_AUTO_REMINDER_ID));
		ElasticSearchDAO.getInstance().setCommonProperties(reminderQueue, userId);
		ElasticSearchDAO.getInstance().createDocument(firmId, IdxAutoReminder.class,
				ObjectConstants.OBJECT_AUTO_REMAINDER, reminderQueue.getAutoReminderId(),
				AppUtil.convertToJson(reminderQueue));
	}

	/**
	 * This method used to send the expiry reminder.
	 *
	 * @param firmId
	 * @param userId
	 */
	public String sendExpiryReminder(final Long firmId, final IdxComUser idxComUser) {
		try {
			final Long userId = idxComUser.getUserId();

			final TimeZone timeZone = CommonDAO.getInstance().getTimeZone(idxComUser.getTimezoneId());

			final Calendar cal = Calendar.getInstance();
			cal.setTimeZone(timeZone);
			cal.set(Calendar.HOUR_OF_DAY, cal.getActualMaximum(Calendar.HOUR_OF_DAY));
			cal.set(Calendar.MINUTE, cal.getActualMaximum(Calendar.MINUTE));
			cal.set(Calendar.SECOND, cal.getActualMaximum(Calendar.SECOND));
			cal.set(Calendar.MILLISECOND, cal.getActualMaximum(Calendar.MILLISECOND));
			final Date currentDate = cal.getTime();
			final SimpleDateFormat esFormat = DateUtil.getEsDateFormat();

			final IdxESignConfiguration config = ElasticSearchDAO.getInstance().getConfigDocument(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId);

			if (config != null) {
				final List<IdxReminderLine> reminderLines = new ArrayList<>();
				for (final IdxReminderLine reminderLine : config.getReminderLines()) {
					if (AppConstants.YES.equals(reminderLine.getIsEnabled())) {
						reminderLines.add(reminderLine);
					}
				}
				logger.info(firmId, "ESignatureService:sendExpiryReminder:reminderLines:size:" + reminderLines.size());

				if (!reminderLines.isEmpty()) {
					final Map<String, IdxEmailTemplate> emailTmplIdTmplMap = new HashMap<>();
					for (final IdxEmailTemplate configEmailTemplate : config.getEmailTemplates()) {
						final IdxEmailTemplate emailTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
								IdxEmailTemplate.class, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
								configEmailTemplate.getId());
						emailTmplIdTmplMap.put(configEmailTemplate.getId().toString(), emailTemplate);
					}

					final List<String> strReminderDates = new ArrayList<>();
					final Map<Integer, IdxReminderLine> numDaysRemLineMap = new HashMap<>();
					for (final IdxReminderLine reminderLine : reminderLines) {
						cal.setTime(currentDate);
						cal.add(Calendar.DAY_OF_MONTH, reminderLine.getDaysBeforeAfterCheckDate());
						strReminderDates.add(DateUtil.formatDate(cal.getTime(), esFormat));

						numDaysRemLineMap.put(reminderLine.getDaysBeforeAfterCheckDate(), reminderLine);
					}

					// For Expired Template, Setting the Expired Template
					cal.setTime(currentDate);
					setExpiredTemplate(firmId, config, strReminderDates, numDaysRemLineMap, timeZone);

					// Already Send reminders esign
					final List<Long> alreadyRemindedESignDocumentIds = alreadySentExpiredReminderDoc(firmId, timeZone);
					logger.info(firmId, "ESignatureService:sendExpiryReminder:alreadyRemindedESignDocumentIds:size:"
							+ alreadyRemindedESignDocumentIds.size());

					// Sending expiry reminder based on the expiry date.
					final String[] includes = {};
					final String[] excludes = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
							ESignConstants.ESIGN_SIGNED_DOCUMENT };

					final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
							.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString())
							.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setFetchSource(includes, excludes)
							.setExplain(false);

					builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

					final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
					boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
					boolQueryBuilder.must(
							QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, AppConstants.OBJECT_STATUS_ACTIVE));
					boolQueryBuilder.mustNot(QueryBuilders.termsQuery(ESignConstants.ESIGN_DOCUMENT_ID,
							alreadyRemindedESignDocumentIds));

					boolQueryBuilder.must(QueryBuilders.termsQuery(ESignConstants.EXP_DATE, strReminderDates));

					final BoolQueryBuilder orBuilder = QueryBuilders.boolQuery();
					final QueryBuilder newDocuments = QueryBuilders.termQuery(ESignConstants.STATUS_CODE,
							ESignConstants.ESIGN_DOCUMENT_STATUS_NEW.toUpperCase());
					orBuilder.should(newDocuments);
					final QueryBuilder pendingDocuments = QueryBuilders.termQuery(ESignConstants.STATUS_CODE,
							ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING.toUpperCase());
					orBuilder.should(pendingDocuments);
					final QueryBuilder sentDocuments = QueryBuilders.termQuery(ESignConstants.STATUS_CODE,
							ESignConstants.ESIGN_DOCUMENT_STATUS_SENT.toUpperCase());
					orBuilder.should(sentDocuments);
					boolQueryBuilder.must(orBuilder);

					builder.setQuery(boolQueryBuilder);

					int batchSize = ElasticSearchDAO.DEFAULT_ES_500_RESULTS;
					builder.setSize(batchSize);
					builder.setScroll(new TimeValue(ElasticSearchDAO.DEFAULT_ES_60K_SCROLL_TIME_VALUE));

					logger.info(firmId,
							"ESignatureService:sendExpiryReminder:boolQueryBuilder:" + boolQueryBuilder.toString());

					SearchResponse response = builder.execute().actionGet();

					if (response.getHits().getHits().length != 0) {
						do {
							for (SearchHit hit : response.getHits().getHits()) {
								final IdxESignDocument idxESignDocument = AppUtil
										.convertFromJson(IdxESignDocument.class, hit.getSourceAsString());
								final Date expiryDate = DateUtil.parseDate(idxESignDocument.getExpDate(), DateUtil.getEsDateFormat(),
										null);
								final Long numDaysPast = DateUtil.getDifferenceNumberOfDays(expiryDate,
										DateUtil.getEndOfDay(currentDate));
								logger.info(firmId, "ESignatureService:sendExpiryReminder:numDaysPast:" + numDaysPast);

								final IdxReminderLine reminderLine = numDaysRemLineMap.get(numDaysPast.intValue());
								if (reminderLine != null) {
									// Updating the document status end of the expiry date
									if (numDaysPast == -1) {
										updateStatusFieldByDocId(firmId, idxESignDocument.geteSignDocumentId(),
												ESignConstants.ESIGN_DOCUMENT_STATUS_EXPIRED);
									}
									// Send email by Template
									sendEmail(firmId, emailTmplIdTmplMap.get(reminderLine.getEmailTemplateId()),
											idxESignDocument, null);

									// Saving reminder queue
									saveAutoReminder(firmId, userId, reminderLine.getId(),
											idxESignDocument.geteSignDocumentId());
								}

							}
							if (response.getHits().getHits().length < batchSize) {
								break;
							}
							response = ElasticSearchDAO.getInstance().getClient(firmId)
									.prepareSearchScroll(response.getScrollId())
									.setScroll(new TimeValue(ElasticSearchDAO.DEFAULT_ES_60K_SCROLL_TIME_VALUE))
									.execute().actionGet();
						} while (response.getHits().getHits().length != 0);
						ESAPIUtil.freeSearchResponse(firmId, response);
					} else {
						logger.info(firmId, "ESignatureService:sendExpiryReminder:no hits:");
					}
					return AppConstants.RESULT_STATUS_SUCCESS;
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:sendExpiryReminder:exception:", exception);
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * 
	 * This method used to get the signed e-sign history by signer id
	 *
	 * @param firmId
	 * @param documentId
	 * @return
	 */
	public IdxEsignatureHistory getESignHistoryBySignerId(final Long firmId, final Long documentId) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery("documentId", documentId));
		andBuilder.must(QueryBuilders.termQuery("status.untouched", AppConstants.ESIGN_SIGNED.toUpperCase()));
//		andBuilder.must(QueryBuilders.termQuery("signedUserId", signerId));

		builder.addSort(ESignConstants.HISTORY_DATE, SortOrder.DESC);
		builder.setPostFilter(andBuilder);
		builder.setSize(1);

		logger.info(firmId, "ESignatureService:getESignHistoryBySignerId:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		if (hits != null && hits.length > 0) {
			final IdxEsignatureHistory idxESignHis = AppUtil.convertFromJson(IdxEsignatureHistory.class,
					hits[0].getSourceAsString());
			idxESignHis.setHistoryId(hits[0].getId());
			return idxESignHis;
		}
		return null;
	}

	/**
	 * This method used to get the latest esign history by document id.
	 *
	 * @param firmId
	 * @param documentId
	 * @return
	 */
	public IdxEsignatureHistory getLatestESignHistoryByDocId(final Long firmId, final Long documentId) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGNATURE_HISTORY.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery("documentId.untouched", documentId));
		andBuilder.must(QueryBuilders.termQuery("status.untouched", AppConstants.ESIGN_SIGNED.toUpperCase()));

		builder.addSort(ESignConstants.HISTORY_DATE, SortOrder.DESC);
		builder.setPostFilter(andBuilder);
		builder.setSize(1);

		logger.info(firmId, "ESignatureService:getLatestESignHistoryByDocId:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		if (hits != null && hits.length > 0) {
			final IdxEsignatureHistory idxESignHis = AppUtil.convertFromJson(IdxEsignatureHistory.class,
					hits[0].getSourceAsString());
			idxESignHis.setHistoryId(hits[0].getId());
			return idxESignHis;
		}
		return null;
	}

	/**
	 * This method used to get the esign document revision by objectRefId.
	 * 
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @return
	 */
	public IdxESignDocRevisions getESignDocReviByObjRefId(final Long firmId, final Long objectId, final String objectRefId) {
		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOC_REVISIONS.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_ID, objectId));
		andBuilder.must(QueryBuilders.termQuery(AppConstants.STR_OBJECT_REF_ID, objectRefId));

		builder.setPostFilter(andBuilder);
		builder.setSize(1);

		logger.info(firmId, "ESignatureService:getESignDocReviByObjRefId:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		if (hits != null && hits.length > 0) {
			final IdxESignDocRevisions idxDocRev = AppUtil.convertFromJson(IdxESignDocRevisions.class, hits[0].getSourceAsString());
			idxDocRev.setId(hits[0].getId());
			return idxDocRev;
		}
		return null;
	}

	/**
	 * This method used to save the esign document revision.
	 *
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @param docData
	 * @return
	 */
	public IdxESignDocRevisions saveESignDocRevision(final Long firmId, final String objectId, final String objectRefId,
			final String docData) {
		final IdxESignDocRevisions idxDocRev = new IdxESignDocRevisions(firmId, objectId, objectRefId, docData);

		final IndexResponse response = ElasticSearchDAO.getInstance().indexDocument(firmId,
				ObjectConstants.OBJECT_ESIGN_DOC_REVISIONS, AppUtil.convertToJson(idxDocRev), true);
		idxDocRev.setId(response.getId());
		return idxDocRev;
	}

	/**
	 * This method used to get the doc preview
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, String> getDocPreview(final Long firmId, final HttpServletRequest request) {
		final Map<String, String> result = new HashMap<>();

		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);

		if(documentId == null) {
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			return result;
		}

		String docBase = null;
		IdxESignDocRevisions idxDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT,
				documentId.toString());
		if (idxDocRev != null) {
			docBase = idxDocRev.getDocData();
		}

		if (idxDocRev == null) {
			final IdxEsignatureHistory idxEsignHist = getLatestESignHistoryByDocId(firmId, documentId);
			if (idxEsignHist != null) {
				idxDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGNATURE_HISTORY,
						idxEsignHist.getHistoryId());
				if (idxDocRev != null) {
					docBase = idxDocRev.getDocData();
				}
			}
		}

		if (idxDocRev == null) {
			idxDocRev = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT,
					documentId.toString() + "_o");
			if (idxDocRev != null) {
				docBase = idxDocRev.getDocData();
			}
		}

		if (idxDocRev == null) {
			final String[] include = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_SIGNED_DOCUMENT };
			final String[] exclude = {};

			final IdxESignDocument idxESignDocument = ESignatureService.getInstance().getDocument(firmId, documentId,
					include, exclude);
			if(idxESignDocument == null) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
				return result;
			}
			docBase = idxESignDocument.getSignedDocument() != null ? idxESignDocument.getSignedDocument()
					: idxESignDocument.getDocumentData();
		}
		result.put(AppConstants.RESULT_DATA, docBase);
		return result;
	}

	/**
	 * This method used to save the user Agent by Web or Mobile.
	 *
	 * @param idxEsignatureHistory
	 * @param userAgent
	 */
	public void saveUserAgent(final IdxEsignatureHistory idxEsignatureHistory, final String userAgent) {
		idxEsignatureHistory.setUserAgent(userAgent);

		// Saving OS, version and browser details based on Web / Mobile Application
		if(userAgent.contains("Android") || userAgent.contains("iPhone")) {
			saveMobileDetailInESignHistory(idxEsignatureHistory);
		} else {
			saveBrowserDetailInESignHistory(idxEsignatureHistory);
		}
	}

	/**
	 * This method used to save the mobile details in esign history.
	 *
	 * @param idxEsignatureHistory
	 */
	public void saveMobileDetailInESignHistory(final IdxEsignatureHistory idxEsignatureHistory) {
		try {
			final String userAgent = idxEsignatureHistory.getUserAgent();
			final String os = "Unknown OS";
			final String version = null;
			final String browser = "Unknown Browser";

			if (userAgent.contains("Dalvik") || userAgent.contains("Darwin")) {
				mobileUserAgentForInBuild(idxEsignatureHistory, userAgent, os, version, browser);
			} else if (userAgent.contains("Android")) {
				mobileUserAgentForAndroid(idxEsignatureHistory, userAgent, os, version, browser);
			} else if (userAgent.contains("iPhone")) {
				mobileUserAgentForiPhone(idxEsignatureHistory, userAgent,  os, version, browser);
			}
		} catch (Exception exception) {
			logger.info(0L, "ESignatureService:saveMobileDetailInESignHistory:userAgent:" + idxEsignatureHistory.getUserAgent());
			logger.error(0L, "ESignatureService:saveMobileDetailInESignHistory:eexception:", exception);
		}
	}

	/**
	 * This method used to save the browser details from user agent.
	 *
	 * @param idxEsignatureHistory
	 */
	public void saveBrowserDetailInESignHistory(final IdxEsignatureHistory idxEsignatureHistory) {
		final Long firmId = idxEsignatureHistory.getFirmId();
		final String userAgent = idxEsignatureHistory.getUserAgent();

		try {
			// Getting Operation System Details from User Agent
			String os = "Unknown OS";
			if (userAgent.contains("Win")) { os = "Windows"; }
			if (userAgent.contains("Mac")) { os = "MacOs"; }
			if (userAgent.contains("X11")) { os = "UNIX"; }
			if (userAgent.contains("Linux")) { os = "Linux"; }
			idxEsignatureHistory.setOs(os);
	
			// Getting Browser and Version Details from User Agent
			String browser = "Unknown Browser";
			String version = "";
			final String[] arr = userAgent.split(" ");
			for (int i = 0; i < arr.length; i++) {
				String entry = arr[i];
				if (entry.indexOf("Trident") != -1) {
					browser = "IE";
					String[] versionArr = entry.split("/");
					if (versionArr[1] != null) {
						version = versionArr[1];
						break;
					}
				}
	
				if (entry.indexOf("Firefox") != -1) {
					browser = "Firefox";
					String[] versionArr = entry.split("/");
					if (versionArr[1] != null) {
						version = versionArr[1];
						break;
					}
				}
	
				if (entry.indexOf("OPR") != -1 || entry.indexOf("Opera") != -1 || entry.indexOf("Edge") != -1) {
					browser = "Opera";
					String[] versionArr = entry.split("/");
					if (versionArr[1] != null) {
						version = versionArr[1];
						break;
					}
				}
	
				if (userAgent.contains("Mac") && entry.indexOf("Safari") != -1) {
					browser = "Safari";
				}
	
				if (entry.indexOf("Version") != -1) {
					String[] versionArr = entry.split("/");
					if (versionArr[1] != null) {
						version = versionArr[1];
					}
				}
	
				if (entry.indexOf("Chrome") != -1) {
					browser = "Chrome";
					if (userAgent.indexOf("OPR") != -1 || userAgent.indexOf("Opera") != -1
							|| userAgent.indexOf("Edge") != -1) {
						continue;
					}
					String[] versionArr = entry.split("/");
					if (versionArr[1] != null) {
						version = versionArr[1];
						break;
					}
				}
			}
			idxEsignatureHistory.setBrowser(browser);
			idxEsignatureHistory.setVersion(version);
		} catch(Exception exception) {
			logger.error(firmId, "ESignatureService:saveBrowserDetailInESignHistory:exception:", exception);
		}
	}

	/**
	 * This method used to delete the Account
	 *
	 * @param firmId
	 * @param userId
	 * @param userData
	 * @param dateFormatStr
	 * @param request
	 * @param response
	 * @return
	 */
	public String deleteAccount(final Long firmId, final Long userId, final UserData userData,
			final String dateFormatStr, final HttpServletRequest request, final HttpServletResponse response) {
		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		updateAttrFirmDeleteDate(idxFirm);

		if (idxFirm.getAffiliateFirmId() != null) {
			return AccountManagementService.getInstance().deleteAccount(firmId, userId, userData, dateFormatStr,
					request, response);
		} else {
			return deleteSignAccount(idxFirm, userData, request);
		}
	}

	/**
	 * This method used to cancel the subscription and the order status in Admin firm
	 *
	 * @param adminFirmId
	 * @param idxFirm
	 * @param userId
	 */
	public void cancelSubscription(final Long adminFirmId, final IdxFirm idxFirm, final Long userId) {
		final Long firmId = idxFirm.getFirmId();

		try {
			final SearchHits hits = CommonDAO.getInstance().getHrFirmPlanHistory(firmId, AppConstants.UPGRADE_SUCCESS,
					null, 1, AppConstants.UPGRADE_DATE, AppConstants.COMMON_SORT_DESC);
			final SearchHit[] documents = hits.getHits();

			IdxFirmPlanHistory hrFirmPlanHistory = null;
			for (final SearchHit document : documents) {
				hrFirmPlanHistory = AppUtil.convertFromJson(IdxFirmPlanHistory.class, document.getSourceAsString());
			}

			if (hrFirmPlanHistory != null && !ESignConstants.SPLAN_5.equals(hrFirmPlanHistory.getPlanCode())
					&& hrFirmPlanHistory.getPlanOrderId() != null) {
				IdxOrder planOrder = ElasticSearchDAO.getInstance().getDocument(adminFirmId, IdxOrder.class,
						ObjectConstants.OBJECT_ORDER, hrFirmPlanHistory.getPlanOrderId());
				final IdxOrdersConfiguration configuration = ElasticSearchDAO.getInstance().getConfigDocument(
						adminFirmId, IdxOrdersConfiguration.class, ObjectConstants.OBJECT_ORDERS_SETTINGS_DATA,
						adminFirmId);
				final IdxStatus idxStatus = OrdersActions.getInstance().getOrderStatusById(configuration.getStatuses(),
						OrderConstants.ORDER_STATUS_CANCELLED, null);

				if (planOrder != null && !planOrder.getOrderStatusId().equals(idxStatus.getStatusId())) {
					planOrder = OrdersActions.getInstance().cancelPlanSubscription(adminFirmId,
							hrFirmPlanHistory.getPlanOrderId(), userId);

					CommonDAO.getInstance().saveFirmPlanHistory(firmId, userId, null, null, planOrder.getOrderId(),
							AppConstants.CANCEL_PREV_ORDER_SUCCESS, null, idxFirm.getNumUsers(),
							"Previous order canceled. Prev order number:" + planOrder.getOrderNumber(), null);

					NotesDAO.getInstance().addNote(adminFirmId,
							"Current plan order canceled. Order number:" + planOrder.getOrderNumber(),
							ObjectConstants.OBJECT_ACCOUNT, planOrder.getCustomerId(), 0L);
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:cancelSubscription:exception:", exception);
		}
	}

	/**
	 * This method used to send the mail notification of firm deletion.
	 *
	 * @param adminFirmId
	 * @param idxFirm
	 * @param userData
	 * @param deleteReason
	 * @param moreDetails
	 */
	public void notifyFirmDeletionNotification(final Long adminFirmId, final IdxFirm idxFirm, final UserData userData,
			final String deleteReason, final String moreDetails) {
		final Long firmId = idxFirm.getFirmId();

		try {
			final Map<String, Object> planDetails = getPlanInformation(firmId, null);

			final String planCode = (String) planDetails.get(AppConstants.ATTR_PLAN_CODE);

			final String planPurchaseDate = (String) planDetails.get("sdf" + AppConstants.ATTR_PLAN_PURH_DATE_TIME);

			final Long orderId = (Long) planDetails.get(AppConstants.STR_ORDER_ID);

			final IdxEmployee idxEmployee = EmployeeDAO.getInstance().getById(firmId, userData.getEmployeeId());

			final IdxCustomersConfiguration configuration = ElasticSearchDAO.getInstance().getConfigDocument(
					adminFirmId, IdxCustomersConfiguration.class, ObjectConstants.OBJECT_CUSTOMERS_SETTINGS_DATA,
					adminFirmId);

			final IdxEmailTemplate message = configuration
					.getEmailTemplate(AppConstants.EmailTemplateMessageNames.FIRM_DELETED);

			if (message != null) {
				final HashMap<String, String> mailBodyValues = new HashMap<>();
				mailBodyValues.put("FIRM_NAME", idxFirm.getFirmName());
				mailBodyValues.put("EMPLOYEE_NAME",
						(idxEmployee.getFirstName() != null ? idxEmployee.getFirstName() + " " : "")
								+ idxEmployee.getLastName());
				MessageTemplateDAO.getInstance().sendNotificationEmailFromMessage(adminFirmId, message.getFromEmailId(),
						message.getFromName(), idxEmployee.getEmailId(), null, null, message, null, mailBodyValues,
						null, EmailUtil.getSenderId(AppConstants.APP_CODE_SIGN), null);
			}

			EmailUtil.sendAlertEmail(firmId, "Firm deleted", "Firm deleted.<br/>firm name:" + idxFirm.getFirmName());

			EmailUtil.sendAlertEmail(firmId, "Firm Deleted - " + firmId, "Reason for deleting:" + deleteReason + "\n"
					+ moreDetails + "\n email id:" + userData.getEmailId());

			final StringBuilder messageBody = new StringBuilder(firmId + "\n<br/>Firm name:" + idxFirm.getFirmName()
					+ "\n<br/>Plan code:" + planCode + "\n<br/>Plan purchase date:" + planPurchaseDate
					+ "\n<br/>Email id:" + userData.getEmailId() + "\n<br/>Reason for deleting:" + deleteReason + "\n"
					+ moreDetails);

			final String toEmailId = RegistrationDAO.getInstance().getToEmailId(idxFirm.getFirmId(),
					userData.getEmailId());
			if (!ESignConstants.SPLAN_5.equals(planCode) && orderId != null) {
				EmailUtil.sendSystemAlertEmail(0L, toEmailId,
						"Account Deleted - " + planCode + " was upgraded on " + planPurchaseDate,
						messageBody.toString());
			} else if (ESignConstants.SPLAN_5.equals(planCode)) {
				EmailUtil.sendSystemAlertEmail(0L, toEmailId, "Account Deleted - " + planCode + " - Standard Plan",
						messageBody.toString());
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:notifyFirmDeletionNotification:exception:", exception);
		}
	}

	/**
	 * This method used to update the customer Delete Details Section.
	 *
	 * @param adminFirmId
	 * @param idxFirm
	 * @param deleteReason
	 * @param moreDetails
	 * @param canContact
	 */
	public void updateCustomerDeleteDetails(final Long adminFirmId, final IdxFirm idxFirm, final String deleteReason,
			final String moreDetails, final boolean canContact) {
		final Long firmId = idxFirm.getFirmId();

		try {
			List<Long> deleteReasons = null;
			if (AppUtil.checkStringNullOrNot(deleteReason)) {
				final NumberHelper numHelper = new Gson().fromJson(deleteReason, NumberHelper.class);
				deleteReasons = numHelper.getId();
			}

			final IdxCustomer idxCustomer = FirmEmpContactService.getInstance()
					.getCustomer(idxFirm.getCustomerByAppCode(AppConstants.APP_CODE_SIGN));

			final IdxCustomersConfiguration configuration = ElasticSearchDAO.getInstance().getConfigDocument(
					adminFirmId, IdxCustomersConfiguration.class, ObjectConstants.OBJECT_CUSTOMERS_SETTINGS_DATA,
					adminFirmId);

			// Getting the InActive Status from configuration
			IdxStatus inActiveStatus = null;
			for (final IdxStatus customerStatus : configuration.getCustomerStatusList()) {
				if (AppConstants.CUSTOMER_INACTIVE_STATUS_ID.equals(customerStatus.getStatusId())) {
					inActiveStatus = customerStatus;
					break;
				}
			}

			// Setting inActive status for the customer record.
			if (inActiveStatus != null) {
				idxCustomer.setStatusId(inActiveStatus.getStatusId());
				idxCustomer.setStatusName(inActiveStatus.getStatusName());
			}

			// Setting the delete reason.
			IdxCustomAttribute idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_DELETE_REASON);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_DELETE_REASON);
			idxCustomAttribute.setCustomAttributeType(AppConstants.STR_CHECK_ATTR);
			idxCustomAttribute.setCustomAttributeValue("");

			final List<IdxCustomAtributeValue> idxCustomAttrValues = new ArrayList<>();
			if (deleteReasons != null && !deleteReasons.isEmpty()) {
				if (deleteReasons.contains(1L)) {
					final IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
					idxCustomAttributeValue.setAttributeId(AppConstants.ATTR_COULD_NOT_IMPLEMENT);
					idxCustomAttributeValue.setAttributeValue(AppConstants.ATTR_COULD_NOT_IMPLEMENT);
					idxCustomAttrValues.add(idxCustomAttributeValue);
				}
				if (deleteReasons.contains(2L)) {
					final IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
					idxCustomAttributeValue.setAttributeId(AppConstants.ATTR_UN_RESOLVED_ISSUES);
					idxCustomAttributeValue.setAttributeValue(AppConstants.ATTR_UN_RESOLVED_ISSUES);
					idxCustomAttrValues.add(idxCustomAttributeValue);
				}
				if (deleteReasons.contains(3L)) {
					final IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
					idxCustomAttributeValue.setAttributeId(AppConstants.ATTR_PENDING_ENHANCEMENT);
					idxCustomAttributeValue.setAttributeValue(AppConstants.ATTR_PENDING_ENHANCEMENT);
					idxCustomAttrValues.add(idxCustomAttributeValue);
				}
				if (deleteReasons.contains(4L)) {
					final IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
					idxCustomAttributeValue.setAttributeId(AppConstants.ATTR_DATA_NOT_LOADED);
					idxCustomAttributeValue.setAttributeValue(AppConstants.ATTR_DATA_NOT_LOADED);
					idxCustomAttrValues.add(idxCustomAttributeValue);
				}
			}
			idxCustomAttribute.setAttributeValues(idxCustomAttrValues);
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);

			if (moreDetails != null) {
				idxCustomAttribute = new IdxCustomAttribute();
				idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_ADDT_DELETE_REASON);
				idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_ADDT_DELETE_REASON);
				idxCustomAttribute.setCustomAttributeType("textarea");
				idxCustomAttribute.setCustomAttributeValue(moreDetails);
				idxCustomer.getCustomAttributes().add(idxCustomAttribute);
			}

			// To Set the Can Contact field
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_CAN_CONTACT);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_CAN_CONTACT);
			idxCustomAttribute.setCustomAttributeType(AppConstants.STR_CHECK_ATTR);
			idxCustomAttribute.setCustomAttributeValue("");

			if (canContact) {
				IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
				idxCustomAttributeValue.setAttributeId(AppConstants.STR_YES);
				idxCustomAttributeValue.setAttributeValue(AppConstants.STR_YES);
				idxCustomAttribute.getAttributeValues().add(idxCustomAttributeValue);
			} else {
				IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
				idxCustomAttributeValue.setAttributeId(AppConstants.STR_NO);
				idxCustomAttributeValue.setAttributeValue(AppConstants.STR_NO);
				idxCustomAttribute.getAttributeValues().add(idxCustomAttributeValue);
			}
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);

			ElasticSearchDAO.getInstance().indexDocument(adminFirmId, IdxCustomer.class, ObjectConstants.OBJECT_ACCOUNT,
					idxCustomer.getCustomerId(), AppUtil.convertToJson(idxCustomer));
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateCustomerDeleteDetails:exception:", exception);
		}
	}

	/**
	 * This method used to update the firm login
	 * - deleting firm Customer in idxFirm
	 * - deleting firmEmpContact
	 *
	 * @param adminFirmId
	 * @param idxFirm
	 */
	public void updateFirmLogin(final Long adminFirmId, final IdxFirm idxFirm) {
		final Long firmId = idxFirm.getFirmId();

		try {
			Long custIndex = null;
			for (int i = 0; i < idxFirm.getCustomers().size(); i++) {
				if (AppConstants.APP_CODE_SIGN.equals(idxFirm.getCustomers().get(i).getApp())) {
					custIndex = Long.valueOf(i);
				}
			}
			if (custIndex != null) {
				idxFirm.getCustomers().remove(custIndex.intValue());
				FirmDAO.getInstance().update(idxFirm);
			}

			// Firm Employee Contacts
			final BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
			boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
			boolQueryBuilder.must(QueryBuilders.termQuery(AppConstants.APP, AppConstants.APP_CODE_SIGN));

			final List<IdxFirmEmpContact> contacts = ElasticSearchDAO.getInstance().getAllDocumentsByBoolFilter(
					adminFirmId, ObjectConstants.OBJECT_FIRM_EMP_CONTACT, boolQueryBuilder, IdxFirmEmpContact.class);
			if (AppUtil.checkListisNullOrNot(contacts)) {
				for (IdxFirmEmpContact contact : contacts) {
					ElasticSearchDAO.getInstance().deleteDocumentIfExists(adminFirmId,
							ObjectConstants.OBJECT_FIRM_EMP_CONTACT.toString(), contact.getId());
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateFirmLogin:exception:", exception);
		}
	}

	/**
	 * This method used to disable and delete the integration details.
	 *
	 * @param idxFirm
	 */
	public void deleteSignIntegration(final IdxFirm idxFirm) {
		final Long firmId = idxFirm.getFirmId();
		try {
			idxFirm.seteSignEnabled(AppConstants.NO);

			ElasticSearchDAO.getInstance().deleteDocumentIfExists(firmId,
					ObjectConstants.OBJECT_APP_INTEGRATION_REQUEST.toString(),
					firmId + "_" + AppConstants.APP_CODE_APPTIVO + "_" + AppConstants.APP_CODE_SIGN);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:deleteSignIntegration:exception:", exception);
		}
	}

	/**
	 * This method used to delete the sign account
	 *
	 * @param idxFirm
	 * @param userData
	 * @param request
	 * @return
	 */
	public String deleteSignAccount(final IdxFirm idxFirm, final UserData userData, final HttpServletRequest request) {
		final String deleteReason = AppHttpUtil.getStringParameter(request, "deleteReason", null);
		final String moreDetails = AppHttpUtil.getStringParameter(request, "moreDetails", null);
		final boolean canContact = AppConstants.YES
				.equals(AppHttpUtil.getStringParameter(request, "canContact", AppConstants.NO));

		if (userData.isAdmin()) {
			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);

			cancelSubscription(adminFirmId, idxFirm, userData.getUserId());

			updateCustomerDeleteDetails(adminFirmId, idxFirm, deleteReason, moreDetails, canContact);

			deleteSignIntegration(idxFirm);

			notifyFirmDeletionNotification(adminFirmId, idxFirm, userData, deleteReason, moreDetails);

			updateFirmLogin(adminFirmId, idxFirm);

			request.getSession().invalidate();
			request.getSession().setAttribute("isDeleted", AppConstants.YES);
			return AppUtil.convertStringToJson("isSuccess", AppConstants.STR_YES);
		} else {
			return AppUtil.convertStringToJson("isSuccess", AppConstants.STR_NO);
		}
	}

	/**
	 * This method used to update the Sign Firm Deletion date in Customer's record - Apptivo Firm 
	 * @param idxFirm
	 */
	public void updateAttrFirmDeleteDate(final IdxFirm idxFirm) {
		final IdxCustomer idxCustomer = ElasticSearchDAO.getInstance().getDocument(AppConstants.APPTIVO_FIRM_ID,
				IdxCustomer.class, ObjectConstants.OBJECT_ACCOUNT, idxFirm.getApptivoAccountId());

		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_SIGN_FIRM_DELETE_DATE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;
		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_FIRM_DELETE_DATE);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_FIRM_DELETE_DATE);
			idxCustomAttribute.setCustomAttributeType(AppConstants.DATE);
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}

		final Calendar calendar = Calendar.getInstance();
		String currentDate = new SimpleDateFormat(DateUtil.format_mdyhms).format(calendar.getTime());

		idxCustomAttribute.setCustomAttributeValue(new SimpleDateFormat(DateUtil.format_mdy).format(calendar.getTime()));
		idxCustomAttribute.setDateValue(currentDate);
		idxCustomAttribute.setFrd(currentDate);

		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}

		ElasticSearchDAO.getInstance().indexDocument(AppConstants.APPTIVO_FIRM_ID, ObjectConstants.OBJECT_ACCOUNT,
				idxCustomer.getCustomerId(), AppUtil.convertToJson(idxCustomer));
	}

	/**
	 * This method used to update the customer Attribute - Is ESign Enabled
	 * @param idxCustomer
	 * @param isESignEnabled
	 */
	public void updateAttrESignEnab(final IdxCustomer idxCustomer, final String isESignEnabled) {
		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_IS_ESIGN_ENABLED.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;
		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_IS_ESIGN_ENABLED);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_IS_ESIGN_ENABLED);
			idxCustomAttribute.setCustomAttributeValue("");
			idxCustomAttribute.setCustomAttributeType(AppConstants.STR_CHECK_ATTR);
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}

		if (AppConstants.YES.equals(isESignEnabled)) {
			final IdxCustomAtributeValue idxCustomAttributeValue = new IdxCustomAtributeValue();
			idxCustomAttributeValue.setAttributeId(AppConstants.ATTR_IS_ESIGN_ENABLED);
			idxCustomAttributeValue.setAttributeValue(AppConstants.CUSTOM_ATTRIBUTE_TAG_VALUE);
			if (idxCustomAttribute.getAttributeValues() == null) {
				idxCustomAttribute.setAttributeValues(new ArrayList<>());
			}
			idxCustomAttribute.getAttributeValues().add(idxCustomAttributeValue);
		} else {
			idxCustomAttribute.setAttributeValues(new ArrayList<>());
		}

		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}
	}

	/**
	 * This method used to update the esig enabled date in customer's record.
	 *
	 * @param idxCustomer
	 * @param isESignEnabled
	 */
	public void updateESignEnabDate(final IdxCustomer idxCustomer, final String isESignEnabled) {
		if (AppConstants.NO.equals(isESignEnabled)) {
			return;
		}

		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_SIGN_ESIGN_ENABLED_DATE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;
		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_ESIGN_ENABLED_DATE);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_ESIGN_ENABLED_DATE);
			idxCustomAttribute.setCustomAttributeType(AppConstants.DATE);
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}

		final Calendar calendar = Calendar.getInstance();
		String currentDate = new SimpleDateFormat(DateUtil.format_mdyhms).format(calendar.getTime());
		
		idxCustomAttribute.setCustomAttributeValue(new SimpleDateFormat(DateUtil.format_mdy).format(calendar.getTime()));
		idxCustomAttribute.setDateValue(currentDate);
		idxCustomAttribute.setFrd(currentDate);

		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}
	}

	/**
	 * This method used to save the subscription type in customer attribute
	 * @param idxCustomer
	 * @param planCode
	 */
	public void saveAttrSubsType(final IdxCustomer idxCustomer, final String planCode) {
		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_SIGN_SUBSCRIPTION_TYPE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;
		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_SUBSCRIPTION_TYPE);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_SUBSCRIPTION_TYPE);
			idxCustomAttribute.setCustomAttributeType(AppConstants.FIELD_TYPE_SELECT.toLowerCase());
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}

		final String subsType = ESignConstants.SPLAN_5.equalsIgnoreCase(planCode) ? "TRIAL" : "PAID";
		idxCustomAttribute.setCustomAttributeValue(subsType); 
		idxCustomAttribute.setCustomAttributeValueId(subsType);

		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}
	}

	/**
	 * This method used to save the plan code attribute in customer record.
	 *
	 * @param idxCustomer
	 * @param idxSignCustomer
	 * @param planCode
	 */
	public void saveAttrPlanCode(final IdxCustomer idxCustomer, final IdxCustomer idxSignCustomer, String planCode) {
		if(idxSignCustomer != null) {
			for (final IdxCustomAttribute idxCustomAttribute : idxSignCustomer.getCustomAttributes()) {
				if (AppConstants.ATTR_PLAN_CODE.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
					planCode = idxCustomAttribute.getCustomAttributeValue();
					break;
				}
			}
		}

		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_SIGN_PLAN_CODE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;

		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_PLAN_CODE);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_PLAN_CODE);
			idxCustomAttribute.setCustomAttributeType(AppConstants.FIELD_TYPE_SELECT.toLowerCase());
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}
		idxCustomAttribute.setCustomAttributeValue(planCode);
		idxCustomAttribute.setCustomAttributeValueId(planCode);
		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}
	}

	/**
	 * This method used to save the trial sign up date in Customer record.
	 *
	 * @param idxCustomer
	 * @param idxSignCustomer
	 * @param planCode
	 */
	public void saveAttrTrialSignupDate(final IdxCustomer idxCustomer, final IdxCustomer idxSignCustomer,
			final String planCode) {
		final Calendar calendar = Calendar.getInstance();
		String currentDate = new SimpleDateFormat(DateUtil.format_mdyhms).format(calendar.getTime());

		final SimpleDateFormat sdfWithoutTimezone = new SimpleDateFormat(DateUtil.format_mdyhms);

		if (idxSignCustomer != null && ESignConstants.SPLAN_5.equalsIgnoreCase(planCode)) {
			currentDate = idxCustomer.getCreationDate();

			final Date creationDate = DateUtil.parseDate(idxCustomer.getCreationDate(), sdfWithoutTimezone, null);
			calendar.setTime(creationDate);
		}

		if (ESignConstants.SPLAN_5.equalsIgnoreCase(planCode)) {
			IdxCustomAttribute idxCustomAttribute = null;
			for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
				if (AppConstants.ATTR_SIGN_TRIAL_SIGNUP_DATE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
					idxCustomAttribute = IdxCustAttr;
					break;
				}
			}

			boolean isNewAttr = false;

			if (idxCustomAttribute == null) {
				idxCustomAttribute = new IdxCustomAttribute();
				idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_TRIAL_SIGNUP_DATE);
				idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_TRIAL_SIGNUP_DATE);
				idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
				idxCustomAttribute.setT(AppConstants.YES);
				idxCustomAttribute.setCustomAttributeType(AppConstants.DATE);
				isNewAttr = true;
			}

			idxCustomAttribute.setCustomAttributeValue(new SimpleDateFormat(DateUtil.format_mdy).format(calendar.getTime()));
			idxCustomAttribute.setDateValue(currentDate);
			idxCustomAttribute.setFrd(currentDate);

			if (isNewAttr) {
				idxCustomer.getCustomAttributes().add(idxCustomAttribute);
			}
		}
	}

	/**
	 * This method used to save the Plan Period Attribute in Customer record.
	 *
	 * @param idxCustomer
	 * @param idxSignCustomer
	 * @return
	 */
	public String saveAttrPlanPeriod(final IdxCustomer idxCustomer, final IdxCustomer idxSignCustomer) {
		String planPeriod = null;
		for (final IdxCustomAttribute idxCustomAttribute : idxSignCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_PLAN_TERM.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
				planPeriod = idxCustomAttribute.getCustomAttributeValue();
				break;
			}
		}

		if (planPeriod != null) {
			IdxCustomAttribute idxCustomAttribute = null;
			for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
				if (AppConstants.ATTR_SIGN_PLAN_TERM.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
					idxCustomAttribute = IdxCustAttr;
					break;
				}
			}

			boolean isNewAttr = false;

			if (idxCustomAttribute == null) {
				idxCustomAttribute = new IdxCustomAttribute();
				idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_PLAN_TERM);
				idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_PLAN_TERM);
				idxCustomAttribute.setCustomAttributeType(AppConstants.FIELD_TYPE_SELECT.toLowerCase());
				idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
				idxCustomAttribute.setT(AppConstants.YES);
				isNewAttr = true;
			}

			idxCustomAttribute.setCustomAttributeValue(planPeriod);
			idxCustomAttribute.setCustomAttributeValueId(planPeriod);

			if (isNewAttr) {
				idxCustomer.getCustomAttributes().add(idxCustomAttribute);
			}
		}
		return planPeriod;
	}

	/**
	 * This method used to save the plan purchase date in Customer record.
	 *
	 * @param idxCustomer
	 * @param idxSignCustomer
	 */
	public void saveAttrPlanPurchaseDate(final IdxCustomer idxCustomer, final IdxCustomer idxSignCustomer) {
		IdxCustomAttribute purchaseCustAttribute = null;
		for (final IdxCustomAttribute idxCustomAttribute : idxSignCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_PLAN_PURH_DATE_TIME.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
				purchaseCustAttribute = idxCustomAttribute;
				break;
			}
		}

		if (purchaseCustAttribute != null) {
			IdxCustomAttribute idxCustomAttribute = null;
			for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
				if (AppConstants.ATTR_SIGN_PURH_DATE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
					idxCustomAttribute = IdxCustAttr;
					break;
				}
			}

			boolean isNewAttr = false;

			if (idxCustomAttribute == null) {
				idxCustomAttribute = new IdxCustomAttribute();
				idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_PURH_DATE);
				idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_PURH_DATE);
				idxCustomAttribute.setCustomAttributeType(AppConstants.DATE);
				idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
				idxCustomAttribute.setT(AppConstants.YES);
				isNewAttr = true;
			}

			idxCustomAttribute.setCustomAttributeValue(purchaseCustAttribute.getCustomAttributeValue());
			idxCustomAttribute.setDateValue(purchaseCustAttribute.getDateValue());
			idxCustomAttribute.setFrd(purchaseCustAttribute.getFrd());

			if (isNewAttr) {
				idxCustomer.getCustomAttributes().add(idxCustomAttribute);
			}
		}
	}

	/**
	 * This method used to save the plan expiry date in customer record.
	 *
	 * @param idxCustomer
	 * @param idxSignCustomer
	 */
	public void saveAttrPlanExpiryDate(final IdxCustomer idxCustomer, final IdxCustomer idxSignCustomer) {
		IdxCustomAttribute planExpiryCustAttribute = null;
		IdxCustomAttribute trialExpiryCustAttribute = null;
		if (idxSignCustomer != null) {
			for (final IdxCustomAttribute idxCustomAttribute : idxSignCustomer.getCustomAttributes()) {
				if (AppConstants.ATTR_PLAN_EXP_DATE_TIME.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
					planExpiryCustAttribute = idxCustomAttribute;
				} else if (AppConstants.ATTR_TRAIL_EXP_DATE_TIME.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
					trialExpiryCustAttribute = idxCustomAttribute;
				}
			}
		}

		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (AppConstants.ATTR_SIGN_EXP_DATE.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;

		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(AppConstants.ATTR_SIGN_EXP_DATE);
			idxCustomAttribute.setCustomAttributeName(AppConstants.ATTR_SIGN_EXP_DATE);
			idxCustomAttribute.setCustomAttributeType(AppConstants.DATE);
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}

		if (planExpiryCustAttribute != null && planExpiryCustAttribute.getCustomAttributeValue() != null) {
			idxCustomAttribute.setCustomAttributeValue(planExpiryCustAttribute.getCustomAttributeValue());
			idxCustomAttribute.setDateValue(planExpiryCustAttribute.getDateValue());
			idxCustomAttribute.setFrd(planExpiryCustAttribute.getFrd());
		} else if (trialExpiryCustAttribute != null && trialExpiryCustAttribute.getCustomAttributeValue() != null) {
			idxCustomAttribute.setCustomAttributeValue(trialExpiryCustAttribute.getCustomAttributeValue());
			idxCustomAttribute.setDateValue(trialExpiryCustAttribute.getDateValue());
			idxCustomAttribute.setFrd(trialExpiryCustAttribute.getFrd());
		} else {
			final Calendar calendar = Calendar.getInstance();
			calendar.add(Calendar.DAY_OF_MONTH, 7);
			final Date endOfDay = DateUtil.getEndOfDay(calendar.getTime());
			final String enOfDy = new SimpleDateFormat(DateUtil.format_mdyhms).format(endOfDay);

			idxCustomAttribute.setCustomAttributeValue(new SimpleDateFormat(DateUtil.format_mdy).format(endOfDay));
			idxCustomAttribute.setDateValue(enOfDy);
			idxCustomAttribute.setFrd(enOfDy);
		}

		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}
	}

	/**
	 * This method used to update the esign details in Apptivo customer record
	 *
	 * @param firmId
	 * @param isESignEnabled
	 */
	public void updateApptivoCustomer(final Long firmId, final String isESignEnabled, final boolean isUpdate) {
		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		final IdxCustomer idxCustomer = ElasticSearchDAO.getInstance().getDocument(AppConstants.APPTIVO_FIRM_ID,
				IdxCustomer.class, ObjectConstants.OBJECT_ACCOUNT, idxFirm.getApptivoAccountId());

		updateAttrESignEnab(idxCustomer, isESignEnabled);

		updateESignEnabDate(idxCustomer, isESignEnabled);

		if (!isUpdate) {
			final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);

			final IdxFirmCustomer idxFirmCustomer = idxFirm.getCustomerByAppCode(AppConstants.APP_CODE_SIGN);

			final IdxCustomer idxSignCustomer = ElasticSearchDAO.getInstance().getDocument(adminFirmId,
					IdxCustomer.class, ObjectConstants.OBJECT_ACCOUNT, idxFirmCustomer.getCustomerId());

			String planCode = AppConstants.startUpPlanCodeByApp.get(AppConstants.APP_CODE_SIGN);

			if (idxSignCustomer != null) {
				for (final IdxCustomAttribute idxCustomAttribute : idxSignCustomer.getCustomAttributes()) {
					if (AppConstants.ATTR_PLAN_CODE.equalsIgnoreCase(idxCustomAttribute.getCustomAttributeId())) {
						planCode = idxCustomAttribute.getCustomAttributeValue();
						break;
					}
				}
			}

			saveAttrSubsType(idxCustomer, planCode);

			saveAttrPlanCode(idxCustomer, null, planCode);

			saveAttrTrialSignupDate(idxCustomer, idxSignCustomer, planCode);

			saveAttrPlanExpiryDate(idxCustomer, idxSignCustomer);

			if(idxSignCustomer != null && !ESignConstants.SPLAN_5.equalsIgnoreCase(planCode)) {
				saveAttrPlanPeriod(idxCustomer, idxSignCustomer);

				saveAttrPlanPurchaseDate(idxCustomer, idxSignCustomer);

				saveAttrPlanExpiryDate(idxCustomer, idxSignCustomer);
			}
		}

		ElasticSearchDAO.getInstance().indexDocument(AppConstants.APPTIVO_FIRM_ID, ObjectConstants.OBJECT_ACCOUNT,
				idxCustomer.getCustomerId(), AppUtil.convertToJson(idxCustomer));
	}

	/**
	 * This method used to get custom subject and message for email template.
	 *
	 * @param firmId
	 * @return
	 */
	public Map<String, Object> getEmailCustSubAndMsg(final Long firmId, final Boolean isResend) {
		final Map<String, Object> results = new HashMap<>();

		final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(firmId);

		if (AppConstants.YES.equals(idxFirm.geteSignEnabled())) {
			 IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
					ESignConstants.SEND_DOCUMENT_FOR_ESIGN);
 
			 //Get custom subject and message from Resend Template. 
			if (Boolean.TRUE.equals(isResend)) {
				idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.RESEND_DOCUMENT_FOR_ESIGN);
				if (idxEmailTemplate == null) {
					idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.RESEND_DOCUMENT_FOR_ESIGN);
				}
			}

			if (idxEmailTemplate != null) {
				results.put(ESignConstants.IS_SIGN_ENABLED, AppConstants.YES);
				results.put("subject", idxEmailTemplate.getSubject());
				results.put("message", idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1]);
			} else {
				results.put(ESignConstants.IS_SIGN_ENABLED, AppConstants.NO);
			}
		} else {
			results.put(ESignConstants.IS_SIGN_ENABLED, AppConstants.NO);
		}
		return results;
	}

	/**
	 * This method used to get the standard templates
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> getStandardTemplates(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		try {
			final String categoryId = AppHttpUtil.getStringParameter(request, "categoryId", null);

			final List<IdxEmailTemplate> standardTemplates = new ArrayList<>();

			final String[] includes = {};
			final String[] excludes = { "customMessage" };

			final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
					.prepareSearch(ObjectConstants.OBJECT_EMAIL_TEMPLATE.toString())
					.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setFetchSource(includes, excludes).setExplain(false);
			builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

			final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
			andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

			andBuilder.must(QueryBuilders.termQuery("messageType", categoryId));

			andBuilder.must(QueryBuilders.termsQuery("code", "TEMPLATE_LIBRARY"));

			logger.info(firmId, "ESignatureService:getStandardTemplates:andBuilder:" + andBuilder.toString());

			builder.setPostFilter(andBuilder);

			builder.addSort(AppConstants.ID, SortOrder.ASC);
			builder.setSize(ElasticSearchDAO.DEFAULT_ES_MAX_RESULTS);

			final SearchResponse response = builder.execute().actionGet();
			final SearchHit[] hits = response.getHits().getHits();

			for (final SearchHit hit : hits) {
				final IdxEmailTemplate standardTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class,
						hit.getSourceAsString());
				standardTemplates.add(standardTemplate);
			}

			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			result.put(AppConstants.RESULT_DATA, standardTemplates);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getStandardTemplates:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to get the template details
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> getTemplate(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final String id = AppHttpUtil.getStringParameter(request, AppConstants.ID, null);

		try {
			final IdxEmailTemplate standardTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxEmailTemplate.class, ObjectConstants.OBJECT_EMAIL_TEMPLATE, id);

			if (standardTemplate != null) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				result.put(AppConstants.RESULT_DATA, standardTemplate);
			} else {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			}
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getTemplate:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to update the template
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> updateTemplate(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final Long id = AppHttpUtil.getLongParameter(request, AppConstants.ID, null);
		final String templateData = AppHttpUtil.getStringParameter(request, "templateData", null);

		try {
			final IdxEmailTemplate standTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class, templateData);

			final IdxEmailTemplate idxEmailTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxEmailTemplate.class, ObjectConstants.OBJECT_EMAIL_TEMPLATE, id);
			if (idxEmailTemplate != null) {
				idxEmailTemplate.setName(standTemplate.getName());
				idxEmailTemplate.setMessageName(standTemplate.getMessageName());
				idxEmailTemplate.setMessageType(standTemplate.getMessageType());

				if (AppUtil.checkStringNullOrNot(standTemplate.getCustomMessage())) {
					idxEmailTemplate.setCustomMessage(standTemplate.getCustomMessage());
				}
				idxEmailTemplate.setIsEnabled(standTemplate.getIsEnabled());

				final String currentDate = DateUtil.getEsDateFormat().format(new Date());

				idxEmailTemplate.setLastUpdateDate(currentDate);
				idxEmailTemplate.setLastUpdatedBy(userData.getUserId());
				idxEmailTemplate.setLastUpdatedByName(userData.getFullName());

				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
						idxEmailTemplate.getId(), AppUtil.convertToJson(idxEmailTemplate));

				AppSettingsDAO.getInstance().addEmailTemplateRevision(firmId, userData.getUserId(),
						userData.getFullName(), idxEmailTemplate.getObjectId(), idxEmailTemplate.getCustomMessage(),
						idxEmailTemplate.getId(), null, null);

				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				return result;
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateTemplate:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to create template - Library
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> createTemplate(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final String templateData = AppHttpUtil.getStringParameter(request, "templateData", null);

		try {
			final IdxEmailTemplate standTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class, templateData);

			standTemplate.setId(AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_MESSAGE_ID));
			standTemplate.setFirmId(firmId);

			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			standTemplate.setCreationDate(currentDate);
			standTemplate.setCreatedBy(userData.getUserId());
			standTemplate.setCreatedByName(userData.getFullName());

			standTemplate.setLastUpdateDate(currentDate);
			standTemplate.setLastUpdatedBy(userData.getUserId());
			standTemplate.setLastUpdatedByName(userData.getFullName());

			ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
					standTemplate.getId(), AppUtil.convertToJson(standTemplate));

			AppSettingsDAO.getInstance().addEmailTemplateRevision(firmId, userData.getUserId(),
					userData.getFullName(), standTemplate.getObjectId(), standTemplate.getCustomMessage(),
					standTemplate.getId(), null, null);

			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			result.put(AppConstants.RESULT_DATA, standTemplate);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateStdTemplate:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to delete the template
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> deleteTemplate(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final Long id = AppHttpUtil.getLongParameter(request, AppConstants.ID, null);
		try {
			boolean isDeleted = ElasticSearchDAO.getInstance().deleteDocumentIfExists(firmId,
					ObjectConstants.OBJECT_EMAIL_TEMPLATE.toString(), id.toString());
			if (isDeleted) {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			} else {
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			}
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:deleteTemplate:exception:", exception);

		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to reset the template
	 *
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> resetTemplate(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final String id = AppHttpUtil.getStringParameter(request, AppConstants.ID, null);
		final String messageName = AppHttpUtil.getStringParameter(request, "messageName", null);

		try {
			final IdxEmailTemplate standardTemplate = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxEmailTemplate.class, ObjectConstants.OBJECT_EMAIL_TEMPLATE, id);

			final String templateData = AppFileUtil.getInstance()
					.readFileFromClassPath(ESignConstants.STANDARD_TEMPLATE_FILE_PATH);
			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			final JSONParser parser = new JSONParser();
			final JSONArray emailTemplates = (JSONArray) parser.parse(templateData);
			for (int i = 0; i < emailTemplates.size(); i++) {
				final IdxEmailTemplate emailTemplate = AppUtil.convertFromJson(IdxEmailTemplate.class,
						emailTemplates.get(i).toString());
				if (emailTemplate.getMessageName().equals(messageName)) {
					// Updating standard template
					standardTemplate.setCustomMessage(emailTemplate.getCustomMessage());

					standardTemplate.setLastUpdatedBy(userData.getUserId());
					standardTemplate.setLastUpdatedByName(userData.getFullName());
					standardTemplate.setLastUpdateDate(currentDate);

					ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_EMAIL_TEMPLATE,
							standardTemplate.getId(), AppUtil.convertToJson(standardTemplate));

					// Updating the email template revision
					AppSettingsDAO.getInstance().addEmailTemplateRevision(firmId, userData.getUserId(),
							userData.getFullName(), standardTemplate.getObjectId(), standardTemplate.getCustomMessage(),
							standardTemplate.getId(), standardTemplate.getWidgets(), null);

					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
					result.put(AppConstants.RESULT_DATA, standardTemplate);
					return result;
				}
			}
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:resetTemplate:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to create the category in esign configuration.
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> createCategory(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final String categoryName = AppHttpUtil.getStringParameter(request, "categoryName", null);

		try {
			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

			Long id = Long.valueOf(idxESignConfiguration.getTemplateCategories().size());

			final IdxLookup category = new IdxLookup(++id, null, null, AppConstants.YES, categoryName.toUpperCase(),
					AppConstants.ATTRIBUTE_TYPE_CUSTOM.toUpperCase(), categoryName);

			idxESignConfiguration.getTemplateCategories().add(category);

			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			result.put(AppConstants.RESULT_DATA, category);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:createCategory:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to update the category in esign configuration
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> updateCategory(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final Long categoryId = AppHttpUtil.getLongParameter(request, AppConstants.ID, null);
		final String categoryData = AppHttpUtil.getStringParameter(request, "categoryData", null);

		try {
			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

			final IdxLookup updatedCategory = AppUtil.convertFromJson(IdxLookup.class, categoryData);

			for (IdxLookup category : idxESignConfiguration.getTemplateCategories()) {
				if (categoryId.equals(category.getId())) {
					category.setIsEnabled(updatedCategory.getIsEnabled());
					category.setMeaning(updatedCategory.getMeaning());

					ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
							ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
							AppUtil.convertToJson(idxESignConfiguration));
					result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
					return result;
				}
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateCategory:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to delete the category
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> deleteCategory(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final Long categoryId = AppHttpUtil.getLongParameter(request, AppConstants.ID, null);

		try {
			int index = -1;

			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

			for (int i = 0; i < idxESignConfiguration.getTemplateCategories().size(); i++) {
				IdxLookup category = idxESignConfiguration.getTemplateCategories().get(i);
				if (categoryId.equals(category.getId())) {
					index = i;
					break;
				}
			}

			if (index >= 0) {
				idxESignConfiguration.getTemplateCategories().remove(index);
				ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
						ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
						AppUtil.convertToJson(idxESignConfiguration));
				result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
				return result;
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:deleteCategory:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to convert HTML to PDF by wkhtml
	 *
	 * @param firmId
	 * @param htmlPath
	 * @param pdfPath
	 * @return
	 */
	public String convertHtmlToPDF(final Long firmId, final String htmlPath, final String pdfPath) {
		try {
			final boolean useProxy = ApplicationProperties.useProxy();

			final int proxyPort = ApplicationProperties.getProxyPort();

			final String proxyHost = ApplicationProperties.getProxyHost();

			String wkhtmlToPdfCmdName = System.getProperty("wkhtml.cmd.name");

			if (!AppUtil.checkStringNullOrNot(wkhtmlToPdfCmdName)) {
				wkhtmlToPdfCmdName = "wkhtmltopdf-amd64";
			}

			final StringBuilder commandSB = new StringBuilder(wkhtmlToPdfCmdName);

			if (useProxy) {
				commandSB.append(" --proxy " + proxyHost + ":" + proxyPort);
			}

			commandSB.append(" " + htmlPath + " " + pdfPath);

			logger.info("ESignatureService:convertHtmlToPDF:cmd String:" + commandSB);

			logger.info("ESignatureService:convertHtmlToPDF:Conversion from HTML to PDF : START");

			final Date startTime = new Date();
			final Process process = Runtime.getRuntime().exec(commandSB.toString());

			final int processResults = process.waitFor();

			logger.info("ESignatureService:convertHtmlToPDF:process exit code:" + process.exitValue());
			logger.info(firmId, "ESignatureService:convertHtmlToPDF:process results:" + processResults);
			logger.info("ESignatureService:convertHtmlToPDF:Time taken to wait for:"
					+ (new Date().getTime() - startTime.getTime()));

			return AppConstants.RESULT_STATUS_SUCCESS;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:convertHtmlToPDF:exception:", exception);
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to save the Attribute date in customer record
	 *
	 * @param idxCustomer
	 * @param attrId
	 * @param attrValue
	 */
	public void saveAttrDate(final IdxCustomer idxCustomer, final String attrId, final Date attrValue) {
		IdxCustomAttribute idxCustomAttribute = null;
		for (final IdxCustomAttribute IdxCustAttr : idxCustomer.getCustomAttributes()) {
			if (attrId.equalsIgnoreCase(IdxCustAttr.getCustomAttributeId())) {
				idxCustomAttribute = IdxCustAttr;
				break;
			}
		}

		boolean isNewAttr = false;
		if (idxCustomAttribute == null) {
			idxCustomAttribute = new IdxCustomAttribute();
			idxCustomAttribute.setCustomAttributeId(attrId);
			idxCustomAttribute.setCustomAttributeName(attrId);
			idxCustomAttribute.setCustomAttributeType(AppConstants.DATE);
			idxCustomAttribute.setFieldType(AppConstants.FIELD_TYPE_NUMBER);
			idxCustomAttribute.setT(AppConstants.YES);
			isNewAttr = true;
		}

		final Calendar calendar = Calendar.getInstance();
		calendar.setTime(attrValue);
		String currentDate = new SimpleDateFormat(DateUtil.format_mdyhms).format(calendar.getTime());

		idxCustomAttribute.setCustomAttributeValue(new SimpleDateFormat(DateUtil.format_mdy).format(calendar.getTime()));
		idxCustomAttribute.setDateValue(currentDate);
		idxCustomAttribute.setFrd(currentDate);

		if (isNewAttr) {
			idxCustomer.getCustomAttributes().add(idxCustomAttribute);
		}
	}

	/**
	 * This method used to update the sign plan details in Apptivo customer record.
	 *
	 * @param clientFirmId
	 * @param idxSignCustomer
	 */
	public void updateSignPlanInApptCust(final Long clientFirmId, final IdxCustomer idxSignCustomer) {
		try {
			final IdxFirm idxFirm = FirmDAO.getInstance().getByFirmId(clientFirmId);

			final IdxCustomer idxCustomer = ElasticSearchDAO.getInstance().getDocument(AppConstants.APPTIVO_FIRM_ID,
					IdxCustomer.class, ObjectConstants.OBJECT_ACCOUNT, idxFirm.getApptivoAccountId());

			final String planPeriod = saveAttrPlanPeriod(idxCustomer, idxSignCustomer);

			saveAttrSubsType(idxCustomer, ESignConstants.SPLAN_E);

			saveAttrPlanPurchaseDate(idxCustomer, idxSignCustomer);

			saveAttrPlanExpiryDate(idxCustomer, idxSignCustomer);

			saveAttrPlanCode(idxCustomer, idxSignCustomer, null);

			final Calendar calendar = Calendar.getInstance();
			final Date currentDate = calendar.getTime();

			saveAttrDate(idxCustomer, AppConstants.ATTR_SIGN_UPGRADE_DATE, currentDate);

			saveAttrDate(idxCustomer, AppConstants.ATTR_SIGN_LAST_BILLED_DATE, currentDate);

			if (AppConstants.UPGRADE_BILLING_PERIOD_YEARLY.equalsIgnoreCase(planPeriod)) {
				calendar.add(Calendar.YEAR, 1);
			} else {
				calendar.add(Calendar.MONTH, 1);
			}
			saveAttrDate(idxCustomer, AppConstants.ATTR_SIGN_NEXT_PAYMENT_DATE, calendar.getTime());

			ElasticSearchDAO.getInstance().indexDocument(AppConstants.APPTIVO_FIRM_ID, ObjectConstants.OBJECT_ACCOUNT,
					idxCustomer.getCustomerId(), AppUtil.convertToJson(idxCustomer));
		} catch (Exception exception) {
			logger.error(0L, "ESignatureService:updateSignPlanInApptCust:exception:", exception);
		}
	}

	/**
	 * This method used to update the Supplementary Files in IdxESignDocument
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> updateSF(final Long firmId, final HttpServletRequest request) {
		final Map<String, Object> result = new HashMap<>();

		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String fas = AppHttpUtil.getStringParameter(request, ESignConstants.FA, null);
		try {
			final List<IdxObject> fa = new Gson().fromJson(fas, new TypeToken<List<IdxObject>>() {
			}.getType());

			final Map<String, Object> scriptParams = new HashMap<>();
			scriptParams.put(AppConstants.FIRM_ID, firmId);
			scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
			scriptParams.put(ESignConstants.FA, new ObjectMapper().readValue(AppUtil.formatUrl(fa), ArrayList.class));

			final StringBuilder updateScript = new StringBuilder();
			updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
					+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");
			updateScript.append("ctx._source.fa = params.fa;");

			updateScript.append("}");

			updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
					updateScript.toString(), scriptParams, false, IdxESignDocument.class);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:addSF:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to compress image
	 *
	 * @param firmId
	 * @param fileName
	 */
	public String compressImage(final Long firmId, final String fileName) {
		InputStream is = null;
		OutputStream os = null;
		ImageOutputStream ios = null; 
		try {
			final File imageFile = new File(fileName + AppConstants.JPEG_FILE_EXTENSION);
			final File compressedImageFile = new File(fileName + "_compressed" + AppConstants.JPEG_FILE_EXTENSION);

			is = new FileInputStream(imageFile);
			os = new FileOutputStream(compressedImageFile);

			float quality = 0.3f;

			final BufferedImage image = ImageIO.read(is);

			final Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpeg");

			if (!writers.hasNext()) {
				is.close();
				os.close();
				throw new IllegalStateException("No writers found");
			}

			final ImageWriter writer = writers.next();
			ios = ImageIO.createImageOutputStream(os);
			writer.setOutput(ios);

			final ImageWriteParam param = writer.getDefaultWriteParam();

			if (param.canWriteCompressed()) {
				param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
				param.setCompressionQuality(quality);
			}

			writer.write(null, new IIOImage(image, null, null), param);

			writer.dispose();

			return AppConstants.RESULT_STATUS_SUCCESS;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:compressImage:exception:", exception);
		} finally
		{
			if(is != null)
			{
				try {
					is.close();
				} catch (IOException e) {
					logger.error(firmId, "ESignatureService:compressImage:IOException:is:e:", e);
				}
			}
			
			if(os != null)
			{
				try {
					os.close();
				} catch (IOException e) {
					logger.error(firmId, "ESignatureService:compressImage:IOException:os:e:", e);
				}
			}
			
			if(ios != null)
			{
				try {
					ios.close();
				} catch (IOException e) {
					logger.error(firmId, "ESignatureService:compressImage:IOException:ios:e:", e);
				}
			}
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to generate the combined pdf
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @return
	 */
	public Map<String, String> generateCombinedPdf(final Long firmId, final IdxESignDocument idxESignDocument) {
		final Map<String, String> result = new HashMap<>();
		FileInputStream fileInputStream = null;
		try {
			final String destFilePath = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
					+ idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId()
					+ "_combined_" + System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;
			final File destFile = new File(destFilePath);

			final Long documentId = idxESignDocument.geteSignDocumentId();

			final PDFMergerUtility pdfmerger = new PDFMergerUtility();

			// Setting the destination file
			pdfmerger.setDestinationFileName(destFilePath);

			for (IdxObject md : idxESignDocument.getMfd()) {
				final String revId = documentId.toString() + "_" + md.getId();
				final IdxESignDocRevisions docRevision = getESignDocReviByObjRefId(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, revId);
				final byte[] decodedPDF = Base64.decodeBase64(docRevision.getDocData().split(",")[1]);

				final String filePath = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/"
						+ idxESignDocument.getFirmId() + "_" + idxESignDocument.geteSignDocumentId() + "_"
						+ md.getId() + "_" + System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;

				final File pdfFile = new File(filePath);
				FileUtils.writeByteArrayToFile(pdfFile, decodedPDF);

				// adding the source files
				pdfmerger.addSource(pdfFile);
			}

			// Merging the two documents
			pdfmerger.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());

			fileInputStream = new FileInputStream(destFilePath);
			byte[] byteInput = new byte[(int) destFile.length()];
			int numRead = fileInputStream.read(byteInput);

			logger.info(firmId, "ESignatureService:generateCombinedPdf:numRead:" + numRead);
			final String documentData = AppConstants.BASE64_PREFIX_PDF + Base64.encodeBase64String(byteInput);
			result.put(ESignConstants.FILE_NAME, destFilePath);
			result.put(ESignConstants.FILE_CONTENT, documentData);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:generateCombinedPdf:exception:", exception);
		} finally {
			if (fileInputStream != null) {
				try {
					fileInputStream.close();
				} catch (IOException e) {
					logger.error(firmId, "ESignatureService:generateCombinedPdf:e:", e);
				}
			}
		}
		return null;
	}

	/**
	 * This method used to update the document name.
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> updateDocumentName(final Long firmId, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String docName = AppHttpUtil.getStringParameter(request, ESignConstants.DOC_NAME, null);

		final Map<String, Object> result = new HashMap<>();

		try {
			final Map<String, Object> scriptParams = new HashMap<>();
			scriptParams.put(AppConstants.FIRM_ID, firmId);
			scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
			scriptParams.put(ESignConstants.DOC_NAME, docName);

			final StringBuilder updateScript = new StringBuilder();
			updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
					+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");
			updateScript.append("ctx._source.documentName = params.documentName;");

			updateScript.append("ctx._source.associatedObject.objectRefName = params.documentName;");

			updateScript.append("}");

			final UpdateRequestBuilder updateRequestBuilder = ElasticSearchDAO
					.getInstance().getClient(firmId).prepareUpdate(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString(),
							ESConstants._DOCS, documentId.toString())
					.setRouting(AppBaseDAO.getInstance().getShardId(firmId));
			updateRequestBuilder.setScript(
					ESAPIUtil.createScriptObject(updateScript.toString(), ScriptType.INLINE, null, scriptParams))
					.execute().actionGet();

			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			return result;
		} catch (VersionConflictEngineException exception) {
			updateDocumentName(firmId, request);
			logger.error(firmId, "ESignatureService:updateDocumentName:exception:", exception);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:updateDocumentName:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to delete the attribute by unique Ids in specific page.
	 *
	 * @param firmId
	 * @param request
	 * @return
	 */
	public Map<String, Object> deleteAttrByIds(final Long firmId, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		Long pageNumber = AppHttpUtil.getLongParameter(request, ESignConstants.PAGE_NUMBER, null);
		final String strAttrIds = AppHttpUtil.getStringParameter(request, "attrIds", null);

		final Map<String, Object> result = new HashMap<>();

		try {
			final List<Long> attrIds = new Gson().fromJson(strAttrIds, new TypeToken<List<Long>>() {
			}.getType());

			final IdxEsignDocumentPage page = getDocPageByIndex(firmId, documentId, pageNumber);
			if (page != null) {
				for (int i = 0; i < page.geteSignAttributes().size(); i++) {
					final IdxEsignAttribute attr = page.geteSignAttributes().get(i);
					if (attrIds.indexOf(attr.getUniqueId()) > -1) {
						page.geteSignAttributes().remove(i);
						i--;
					}
				}

				pageNumber -= 1L;
				updateDocumentPage(firmId, documentId, pageNumber.intValue(), page);
				result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
				result.put(AppConstants.RESULT_DATA, page);
				return result;
			}
		} catch (VersionConflictEngineException exception) {
			deleteAttrByIds(firmId, request);
			logger.error(firmId, "ESignatureService:deleteAttrByIds:version conflict:exception:", exception);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:deleteAttrByIds:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to verify the signer is logged in or not.
	 *
	 * @param firmId
	 * @param signerEmailId
	 * @param request
	 * @return
	 */
	public boolean isSignerLoggedIn(final Long firmId, final String signerEmailId, final HttpServletRequest request) {
		final Long loggedInFirmId = AppHttpUtil.getFirmId(request);
		if (loggedInFirmId != null && firmId.equals(loggedInFirmId)) {
			final Long loggedInUserId = AppHttpUtil.getUserId(request, loggedInFirmId);
			if (loggedInUserId != null) {
				final UserData userData = AppHttpUtil.getUserData(request, loggedInFirmId, loggedInUserId);
				if (userData != null && signerEmailId.equals(userData.getEmailId())) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * This method used to execute the Email signer authentication
	 * 
	 * @param idxESignDocument
	 * @param signerId
	 * @param request
	 * @return
	 */
	public Map<String, Object> signerAuthEmail(final IdxESignDocument idxESignDocument, final Long signerId,
			final HttpServletRequest request) {
		final Map<String, Object> results = new HashMap<>();

		final Long firmId = idxESignDocument.getFirmId();
		final Long documentId = idxESignDocument.geteSignDocumentId();
		final IdxESignSigner idxESigner = idxESignDocument.getESignSignerBySignerId(signerId);
		final IdxObject senderDetails = idxESignDocument.getSenderDetails();

		String emailId = null;
		if (idxESigner != null) {
			emailId = idxESigner.getPrimaryEmailId();
		} else if (signerId.equals(idxESignDocument.getCreatedBy())) {
			emailId = senderDetails.getEmailId();
		}

		// Excluding the Signer Authentication check for the logged in User
		if (emailId != null && isSignerLoggedIn(firmId, emailId, request)) {
			results.put("isMfaEnabled", AppConstants.NO);
			return results;
		}

		// Sending OTP Mail to Owner - not a signer
		if (idxESigner == null && signerId.equals(idxESignDocument.getCreatedBy()) && senderDetails.getTId() == null) {
			// ctxId = firmId_documentId_signerId
			final String ctxId = firmId + "_" + documentId + "_" + signerId;

			final Calendar calendar = Calendar.getInstance();
			calendar.add(Calendar.HOUR, 1);
			final String expirationDate = DateUtil.getEsDateFormat().format(calendar.getTime());

			// Creating the Cf Token
			final IdxCfToken idxCfToken = CfTokenService.getInstance().createCfToken(ctxId,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(), expirationDate);

			// Updating the tokenId in IdxESignSigner
			senderDetails.setTId(idxCfToken.getId());
			updateSenderDetailsByScript(firmId, documentId, senderDetails);

			// Sending Authentication Email to Signer
			sendAuthMail(firmId, idxESignDocument, senderDetails.getObjectRefName(), emailId,
					AppEncryptionUtil.dycrypt(idxCfToken.getOtp()));

			results.put("isMailSent", AppConstants.YES);
		}

		// Sending OTP Mail to the Signers.
		if (idxESigner != null && idxESigner.gettId() == null) {
			// ctxId = firmId_documentId_signerId
			final String ctxId = firmId + "_" + documentId + "_" + signerId;

			final Calendar calendar = Calendar.getInstance();
			calendar.add(Calendar.HOUR, 1);
			final String expirationDate = DateUtil.getEsDateFormat().format(calendar.getTime());

			// Creating the Cf Token
			final IdxCfToken idxCfToken = CfTokenService.getInstance().createCfToken(ctxId,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(), expirationDate);

			// Updating the tokenId in IdxESignSigner
			idxESigner.settId(idxCfToken.getId());
			updateSignerByScript(firmId, documentId, idxESignDocument.getSigners());

			// Sending Authentication Email to Signer
			sendAuthMail(firmId, idxESignDocument, idxESigner.getObjectRefName(), emailId,
					AppEncryptionUtil.dycrypt(idxCfToken.getOtp()));

			results.put("isMailSent", AppConstants.YES);
		}
		results.put("isMfaEnabled", AppConstants.YES);
		return results;
	}

	/**
	 * This method used to send the Auth mail to signer.
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @param name
	 * @param emailId
	 * @param otp
	 */
	public void sendAuthMail(Long firmId, final IdxESignDocument idxESignDocument, final String name,
			final String emailId, final String otp) {
		final Long adminFirmId = AppConstants.adminAppFirmIdMap.get(AppConstants.APP_CODE_SIGN);

		IdxEmailTemplate message = getEmailTemplateByMessageType(firmId, ESignConstants.SIGNER_AUTHENTICATION);
		if (message == null) {
			message = getEmailTemplateByName(adminFirmId, ESignConstants.SIGNER_AUTHENTICATION);
		} else {
			message.setCustomMessage(message.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		final String documentUrl = getDocumentRedirectionURL(firmId, idxESignDocument.geteSignDocumentId(), null,
				ObjectConstants.OBJECT_ESIGN_DOCUMENT, null);

		// Preparing mail subject and mail body variables.
		final HashMap<String, String> mailSubjectValues = new HashMap<>();
		final HashMap<String, String> mailBodyValues = new HashMap<>();
		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
		prepareESignAttrForRequestSign(idxESignDocument, null, documentUrl, mailSubjectValues, mailBodyValues);
		mailSubjectValues.put(ESignConstants.SIGNER_NAME, name);
		mailSubjectValues.put(ESignConstants.SIGNER_EMAIL_ID, emailId);

		mailBodyValues.put(AppConstants.VERIFICATION_CODE, otp);
		mailBodyValues.put(ESignConstants.SIGNER_NAME, name);
		mailBodyValues.put(ESignConstants.SIGNER_EMAIL_ID, emailId);

		message.setToEmailId(emailId);

		prepareEmailAddresses(idxESignDocument, message, isSpfDkimEnabled);

		MessageTemplateDAO.getInstance().sendNotificationEmailFromMessage(firmId,
				ESignConstants.ESIGN_NOTIFICATION_EMAIL_ID, ESignConstants.ESIGN_FROM_EMAIL_NAME, emailId, null, null,
				message, mailSubjectValues, mailBodyValues, null, EmailUtil.getSenderId(AppConstants.APP_CODE_SIGN), null);
	}

	/**
	 * This method used to verify the signer auth code is valid or not.
	 *
	 * @param firmId
	 * @param signerId
	 * @param idxESignDocument
	 * @param otp
	 * @param ipAddress
	 * @param userAgent
	 * @param request
	 *
	 * @return
	 */
	public final Map<String, String> isSignerAuthCodeValid(final Long firmId, final Long signerId,
			final IdxESignDocument idxESignDocument, final String otp, final String ipAddress,
			final String userAgent, final HttpServletRequest request) {
		final Map<String, String> result = new HashMap<>();
		try {
			final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
					IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);
			if (idxESignConfiguration != null
					&& ESignConstants.SIGNER_AUTH_EMAIL.equals(idxESignConfiguration.getActiveSignerAuthType())) {
				result.put("IS_SIGNER_AUTH_ENABLED", AppConstants.YES);

				final IdxESignSigner idxESigner = idxESignDocument.getESignSignerBySignerId(signerId);
				final IdxObject senderDetails = idxESignDocument.getSenderDetails();

				String emailId = null;
				if (idxESigner != null) {
					emailId = idxESigner.getPrimaryEmailId();
				} else if (signerId.equals(idxESignDocument.getCreatedBy())) {
					emailId = senderDetails.getEmailId();
				}

				// Excluding the mfa check for the logged in User
				if (isSignerLoggedIn(firmId, emailId, request)) {
					result.put("IS_SIGNER_AUTHORIZED", AppConstants.YES);
					return result;
				}

				final String ctxId = firmId + "_" + idxESignDocument.geteSignDocumentId() + "_" + signerId;

				final IdxCfToken idxCfToken = CfTokenService.getInstance().getCfToken(ctxId, AppConstants.YES);
				if (idxCfToken != null) {

					final Calendar calendar = Calendar.getInstance();
					final Date currentDate = calendar.getTime();

					final SimpleDateFormat sdfWithoutTimezone = new SimpleDateFormat(DateUtil.format_mdyhms);

					final Date expirationDate = DateUtil.parseDate(idxCfToken.getExpirationDate(), sdfWithoutTimezone,
							null);

					if (currentDate.compareTo(expirationDate) >= 0) {
						result.put("TOKEN_EXPIRED", AppConstants.YES);
						return result;
					}

					if (!otp.equals(AppEncryptionUtil.dycrypt(idxCfToken.getOtp()))) {
						result.put("IS_SIGNER_AUTHORIZED", AppConstants.NO);
						return result;
					}

					// Updating cf token validation timing
					final String strCurrentDate = DateUtil.getEsDateFormat().format(new Date());
					idxCfToken.setIpAddress(ipAddress);
					idxCfToken.setUserAgent(userAgent);
					idxCfToken.setIsValid(AppConstants.NO);
					idxCfToken.setValidationTime(strCurrentDate);
					idxCfToken.setLastUpdateDate(strCurrentDate);
					CfTokenService.getInstance().updateCfToken(idxCfToken);
					result.put("IS_SIGNER_AUTHORIZED", AppConstants.YES);
				} else {
					result.put("INVALID_TOKEN", AppConstants.YES);
				}
			} else {
				result.put("IS_SIGNER_AUTH_ENABLED", AppConstants.NO);
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:isSignerAuthCodeValid:exception:", exception);
		}
		return result;
	}

	/**
	 * This method used to void the document
	 *
	 * @param firmId
	 * @param documentId
	 * @param reasons
	 * @return
	 */
	public Map<String, Object> voidDocument(final Long firmId, final Long documentId, final String reasons) {
		final Map<String, Object> result = new HashMap<>();
		try {
			final String[] includes = {};
			final String[] excludes = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
					ESignConstants.ESIGN_SIGNED_DOCUMENT };

			final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, includes, excludes);

			// Updating the document status
			updateStatusFieldByDocId(firmId, documentId, ESignConstants.ESIGN_DOCUMENT_STATUS_VOID);

			final String documentUrl = getDocumentRedirectionURL(firmId, documentId, null,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, null);
			notifyVoidDocument(firmId, idxESignDocument, documentUrl, reasons);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:voidDocument:exception:", exception);
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		}
		return result;

	}

	/**
	 * This method used to notify void doc
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @param documentUrl
	 * @param reasons
	 */
	public void notifyVoidDocument(final Long firmId, final IdxESignDocument idxESignDocument, final String documentUrl,
			final String reasons) {
		for (final IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {

			// Getting the email template from Sign.co
			IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.VOID_DOCUMENT);
			if (idxEmailTemplate == null) {
				// Getting email template from Sign customer configuration.
				idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.VOID_DOCUMENT);
			} else {
				idxEmailTemplate
						.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
			}

			// Checking SPF/DKIM enabled or not.
			final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

			// Preparing mail subject and mail body of variables for template.
			final Map<String, String> mailSubjectValues = new HashMap<>();
			final Map<String, String> mailBodyValues = new HashMap<>();

			prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
			prepareESignAttrForRequestSign(idxESignDocument, idxESignSigner, documentUrl, mailSubjectValues, mailBodyValues);

			if (reasons != null) {
				mailBodyValues.put(ESignConstants.REASON.toUpperCase(), "for the following reason <br>" + reasons);
			} else {
				mailBodyValues.put(ESignConstants.REASON.toUpperCase(), "");
			}

			idxEmailTemplate.setToEmailId(idxESignSigner.getPrimaryEmailId());

			prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

			sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);
		}
	}

	/**
	 * This method used to get existing esign document and expiring it, while Resend the document in E-Sign.
	 *
	 * @param firmId
	 * @param objectId
	 * @param objectRefId
	 * @param userData
	 *
	*/
	public void invalidateExistingEsignDoc(final Long firmId, final Long objectId, final Long objectRefId,
			final UserData userData) {
		final String[] includes = {};
		final String[] excludes = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
				ESignConstants.ESIGN_SIGNED_DOCUMENT };

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(ObjectConstants.OBJECT_ESIGN_DOCUMENT.toString())
				.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setFetchSource(includes, excludes).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		// For getting ESign document details
		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));
		andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSOCIATED_OBJECT, QueryBuilders.boolQuery()
				.must(QueryBuilders.termQuery(ESignConstants.ASSOCIATED_OBJECT_ID, objectId))));
		andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSOCIATED_OBJECT, QueryBuilders.boolQuery()
				.must(QueryBuilders.termQuery(ESignConstants.ASSOCIATED_OBJECT_REF_ID, objectRefId))));

		andBuilder.mustNot(
				QueryBuilders.termsQuery(AppConstants.OBJECT_STATUS, AppConstants.OBJECT_STATUS_INACTIVE));
		builder.setPostFilter(andBuilder);
		logger.info(firmId, "ESignatureService:invalidateExistingEsignDoc:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		if (hits != null && hits.length > 0) {
			final IdxESignDocument idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class,
					hits[0].getSourceAsString());
			// Invalidate old document
			deleteForever(firmId, idxESignDocument.geteSignDocumentId(), null, userData);
		}
	}

	/**
	 * This method used to reassign the document
	 * 
	 * @param firmId
	 * @param documentId
	 * @param signerId
	 * @param reassign
	 * @return
	 */
	public Map<String, Object> reassignDocument(final Long firmId, final Long documentId, final Long signerId,
			final String reassign) {
		final Map<String, Object> results = new HashMap<>();
		try {
			final String[] includes = {};
			final String[] excludes = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
					ESignConstants.ESIGN_SIGNED_DOCUMENT };

			final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, includes, excludes);
			final IdxESignSigner idxESignSigner = idxESignDocument.getESignSignerBySignerId(signerId);

			final IdxReassign idxReassign = AppUtil.convertFromJson(IdxReassign.class, reassign);

			if (idxESignDocument.getReassignByReqSId(signerId) != null) {
				for (int i = 0; i < idxESignDocument.getReassign().size(); i++) {
					final IdxReassign reassignData = idxESignDocument.getReassign().get(i);
					if (reassignData.getReqSId().equals(signerId)) {
						idxESignDocument.getReassign().set(i, idxReassign);
						break;
					}
				}
			} else {
				idxESignDocument.getReassign().add(idxReassign);
			}

			updateReassign(firmId, documentId, idxESignDocument.getReassign());
			final String documentUrl = getDocumentRedirectionURL(firmId, documentId, null,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, null);
			requestReassign(firmId, idxESignDocument, idxESignSigner, idxReassign, documentUrl);

			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:reassignDocument:exception:", exception);
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		}
		return results;
	}

	/**
	 * This method used to request Reassign
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param idxESignSigner
	 * @param idxReassign
	 * @param documentUrl
	 */
	public void requestReassign(final Long firmId, final IdxESignDocument idxESignDocument,
			final IdxESignSigner idxESignSigner, final IdxReassign idxReassign, final String documentUrl) {
		IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.REQUEST_REASSIGN);
		if (idxEmailTemplate == null) {
			idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.REQUEST_REASSIGN);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// Preparing mail subject for template.
		final Map<String, String> mailSubjectValues = new HashMap<>();
		final Map<String, String> mailBodyValues = new HashMap<>();

		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
		prepareESignAttrForRequestSign(idxESignDocument, idxESignSigner, documentUrl, mailSubjectValues, mailBodyValues);

		final String documentRedirectionUrl = documentUrl + "&" + ESignConstants.URL_SIGNER_ID_PARAM + "="
				+ AppEncryptionUtil.encrypt(idxESignDocument.getCreatedBy().toString()) + "&"
				+ ESignConstants.URL_REQ_SIGNER_ID_PARAM + "="
				+ AppEncryptionUtil.encrypt(idxESignSigner.geteSignSignerId().toString());
		final String reassignAprroveUrl = documentRedirectionUrl + "&" + ESignConstants.URL_REASSIGN_ACTION + "=" + "approved";
		final String reassignRejectUrl = documentRedirectionUrl + "&" + ESignConstants.URL_REASSIGN_ACTION + "=" + "declined";
		mailBodyValues.put(ESignConstants.DOCUMENT_URL, documentRedirectionUrl);
		mailBodyValues.put(ESignConstants.REASSIGN_APPROVE_URL, reassignAprroveUrl);
		mailBodyValues.put(ESignConstants.REASSIGN_REJECT_URL, reassignRejectUrl);
		mailBodyValues.remove(ESignConstants.SIGNER_NAME);
		mailBodyValues.put(ESignConstants.SIGNER_NAME_1, idxESignSigner.getObjectRefName());
		mailBodyValues.put(ESignConstants.SIGNER_NAME_2, idxReassign.getName());

		idxEmailTemplate.setToEmailId(idxESignDocument.getSenderDetails().getEmailId());

		prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

		sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);

		// Action Center - Need your Approval
		if (ObjectConstants.OBJECT_ESIGN_DOCUMENT.equals(idxESignDocument.getAssociatedObject().getObjectId())) {
			ESignEventActionService.getInstance().produceActionQueue(firmId, idxESignDocument, idxESignSigner, null,
					ESignConstants.AE_CODE_NEED_YOUR_APPROVAL);
		}
	}

	/**
	 * This method used reassignAction Approve /Reject
	 *
	 * @param firmId
	 * @param documentId
	 * @param reqSId
	 * @param request
	 * @return
	 */
	public Map<String, Object> reassignAction(final Long firmId, final Long documentId, final Long reqSId,
			final HttpServletRequest request) {
		final String action = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_RESASSIGN_ACTION,
				null);
		final String actionQueueId = AppHttpUtil.getStringParameter(request, AppConstants.STR_ACTION_QUEUE_ID, null);
		final String clientIpAddress = AppHttpUtil.getClientIPAddress(request);
		final String userAgent = AppHttpUtil.getUserAgent(request);

		final Map<String, Object> results = new HashMap<>();
		final Map<String, Object> data = new HashMap<>();
		try {
			final String[] includes = {};
			final String[] excludes = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_SIGNED_DOCUMENT };

			final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, includes, excludes);
			final IdxESignSigner idxESignSigner = idxESignDocument.getESignSignerBySignerId(reqSId);
			final IdxReassign idxReassign = idxESignDocument.getReassignByReqSId(reqSId);
			if (ESignConstants.REASSIGN_REQUESTED.equalsIgnoreCase(idxReassign.getStatus())) {
				if (ESignConstants.REASSIGN_APPROVED.equalsIgnoreCase(action)) {
					reassignApproved(firmId, documentId, reqSId, clientIpAddress, userAgent, idxESignDocument,
							idxReassign);
				} else {
					reassignDeclined(firmId, documentId, reqSId, idxESignDocument, idxReassign);
				}

				// Action Queue status changed as completed
				if (actionQueueId != null) {
					ESignEventActionDAO.getInstance().changeActionQueueStatus(firmId, actionQueueId);
				} else {
					ESignEventActionDAO.getInstance().updateActionQueueStatus(firmId,
							idxESignDocument.getAssociatedObject().getObjectId(), documentId, reqSId);
				}

				results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			} else {
				results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
				results.put(AppConstants.RESULT_REASON, ESignConstants.RESPONSE_REASON_ALREADY_RESPONDED);
				data.put(ESignConstants.RESPONSE_PARAM_REASSIGNED_SIGNER_STATUS, idxReassign.getStatus());
			}

			data.put(ESignConstants.RESPONSE_PARAM_DOCUMENT_NAME, idxESignDocument.getDocumentName());
			data.put(ESignConstants.RESPONSE_PARAM_REQUESTED_SIGNER, idxESignSigner.getObjectRefName());
			data.put(ESignConstants.RESPONSE_PARAM_REASSIGNED_SIGNER, idxReassign.getName());
			results.put(AppConstants.RESULT_DATA, data);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:reassignAction:exception:", exception);
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		}

		return results;
	}

	/**
	 * This method used to notify the status of the reassigned document
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param documentUrl
	 * @param status
	 * @param signerId
	 * @param idxReassign
	 */
	public void notifyReassignStatus(final Long firmId, final IdxESignDocument idxESignDocument,
			final String documentUrl, final String status, final Long signerId, final IdxReassign idxReassign) {
		for (int i = 0; i < idxESignDocument.getSigners().size(); i++) {
			final IdxESignSigner idxESignSigner = idxESignDocument.getSigners().get(i);
			if (idxESignSigner.geteSignSignerId().equals(signerId)) {

				// Getting email template from Sign customer configuration.
				IdxEmailTemplate idxEmailTemplate;
				if (ESignConstants.REASSIGN_APPROVED.equalsIgnoreCase(status)) {
					idxEmailTemplate = getEmailTemplateByMessageType(firmId,
							ESignConstants.REASSIGN_APPROVED_NOTIFICATION);
					if (idxEmailTemplate == null) {
						idxEmailTemplate = getEmailTemplateByName(getSignFirmId(),
								ESignConstants.REASSIGN_APPROVED_NOTIFICATION);
					} else {
						idxEmailTemplate.setCustomMessage(
								idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
					}
				} else {
					idxEmailTemplate = getEmailTemplateByMessageType(firmId,
							ESignConstants.REASSIGN_DENIED_NOTIFICATION);
					if (idxEmailTemplate == null) {
						idxEmailTemplate = getEmailTemplateByName(getSignFirmId(),
								ESignConstants.REASSIGN_DENIED_NOTIFICATION);
					} else {
						idxEmailTemplate.setCustomMessage(
								idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
					}
				}

				// Checking SPF/DKIM enabled or not.
				final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

				// Preparing mail subject for template.
				final Map<String, String> mailSubjectValues = new HashMap<>();
				final Map<String, String> mailBodyValues = new HashMap<>();
				prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
				prepareESignAttrForRequestSign(idxESignDocument, idxESignSigner, documentUrl, mailSubjectValues, mailBodyValues);
				mailBodyValues.remove(ESignConstants.SIGNER_NAME);
				mailBodyValues.put(ESignConstants.SIGNER_NAME_1, idxESignSigner.getObjectRefName());
				mailBodyValues.put(ESignConstants.SIGNER_NAME_2, idxReassign.getName());

				idxEmailTemplate.setToEmailId(idxESignSigner.getPrimaryEmailId());

				prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

				updateBrandingContent(firmId, idxESignDocument.getbId(), mailBodyValues);

				sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);
			}
		}
	}

	/**
	 * This used to update reassign fields by  Inline script
	 * @param firmId
	 * @param documentId
	 * @param reassignData
	 */
	public IdxESignDocument updateReassign(final Long firmId, final Long documentId,
			final List<IdxReassign> reassignData) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);

		try {
			scriptParams.put("reassignData",
					new ObjectMapper().readValue(AppUtil.formatUrl(reassignData), ArrayList.class));
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateReassign:exception:", exception);
		}

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		updateScript.append("ctx._source.reassign = params.reassignData;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to update document pages, latest Signer list and
	 * Reassign field
	 * 
	 * @param firmId
	 * @param documentId
	 * @param signers
	 * @param idxESignDocumentPage
	 * @return
	 */
	public IdxESignDocument updateReassignDetails(final Long firmId, final Long documentId,
			final List<IdxESignSigner> signers, final List<IdxEsignDocumentPage> idxESignDocumentPage,
			final List<IdxReassign> reassignData) {

		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);

		try {
			scriptParams.put("signers", new ObjectMapper().readValue(AppUtil.formatUrl(signers), ArrayList.class));
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateReassignDetails:signers:exception:", exception);
		}

		try {
			scriptParams.put("idxESignDocumentPage",
					new ObjectMapper().readValue(AppUtil.formatUrl(idxESignDocumentPage), ArrayList.class));
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateReassignDetails:idxESignDocumentPage:exception:", exception);
		}
		try {
			scriptParams.put("reassignData",
					new ObjectMapper().readValue(AppUtil.formatUrl(reassignData), ArrayList.class));
		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateReassignDetails:reassignData:exception:", exception);
		}

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		updateScript.append("ctx._source.documentPages = params.idxESignDocumentPage;");

		updateScript.append("ctx._source.signers = params.signers;");

		updateScript.append("ctx._source.reassign = params.reassignData;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to Request sign for reassigned document
	 * 
	 * @param firmId
	 * @param idxESignDocument
	 * @param idxSigner
	 * @param documentUrl
	 */
	public void requestSignForReassignDoc(final Long firmId, final IdxESignDocument idxESignDocument,
			final String documentUrl, final IdxReassign idxReassign, final IdxESignSigner idxSigner, final String msg) {

		IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId,
				ESignConstants.REASSIGN_DOCUMENT_FOR_ESIGN);
		if (idxEmailTemplate == null) {
			// Fetching the Email Template.
			idxEmailTemplate = getEmailTemplateByName(getSignFirmId(), ESignConstants.REASSIGN_DOCUMENT_FOR_ESIGN);
		} else {
			idxEmailTemplate.setCustomMessage(idxEmailTemplate.getCustomMessage().replace(ESignConstants.CUST_MSG, ""));
		}

		// Checking SPF/DKIM enabled or not.
		final boolean isSpfDkimEnabled = isSpfDkimEnabled(firmId, idxESignDocument.getSenderDetails());

		// For preparing mail subject and body for email template.
		final Map<String, String> mailSubjectValues = new HashMap<>();
		final Map<String, String> mailBodyValues = new HashMap<>();
		prepareCommonAttrForRequestSign(firmId, idxESignDocument, mailBodyValues);
		prepareESignAttrForRequestSign(idxESignDocument, idxSigner, documentUrl, mailSubjectValues, mailBodyValues);

		mailBodyValues.remove(ESignConstants.SIGNER_NAME);
		mailBodyValues.put(ESignConstants.SIGNER_NAME_1, idxSigner.getObjectRefName());
		mailBodyValues.put(ESignConstants.SIGNER_NAME_2, idxReassign.getName());

		if (msg != null) {
			mailBodyValues.put(ESignConstants.REASON.toUpperCase(), "You have a message from the sender. <br>" + msg);
		} else {
			mailBodyValues.put(ESignConstants.REASON.toUpperCase(), "");
		}

		// Preparing toAddress for Email Template.
		idxEmailTemplate.setToEmailId(idxSigner.getPrimaryEmailId());

		prepareEmailAddresses(idxESignDocument, idxEmailTemplate, isSpfDkimEnabled);

		// Sending Email to signers.
		sendEmailByTemplate(idxEmailTemplate, mailSubjectValues, mailBodyValues, null);
	}

	/**
	 * This method used to reassign approved scenario
	 * 
	 * @param firmId
	 * @param documentId
	 * @param reqSId
	 * @param clientIpAddress
	 * @param userAgent
	 * @param idxESignDocument
	 * @param idxReassign
	 * @return
	 */
	public Map<String, Object> reassignApproved(final Long firmId, final Long documentId, final Long reqSId,
			final String clientIpAddress, final String userAgent, final IdxESignDocument idxESignDocument,
			final IdxReassign idxReassign) {
		final Map<String, Object> results = new HashMap<>();
		try {
			final IdxESignSigner eSignSigner = idxESignDocument.getESignSignerBySignerId(reqSId);
			final Map<String, Long> employeesData = getAllActiveEmployee(firmId);

			eSignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_REASSIGNED.toUpperCase());
			eSignSigner.setSignerActions(ESignConstants.SIGNER_ACTION_RECEIVE_COPY);

			final List<IdxESignSigner> signers = new ArrayList<>();
			final IdxESignSigner idxESignSigner = new IdxESignSigner();
			idxESignSigner.setSignerStatus(ESignConstants.SIGNER_STATUS_NEW.toUpperCase());
			idxESignSigner.setSignerActions(ESignConstants.SIGNER_ACTION_NEED_SIGN);
			idxESignSigner.setPrimaryEmailId(idxReassign.getEmailId());
			idxESignSigner.setObjectRefName(idxReassign.getName());
			idxESignSigner.seteSignSignerId(
					AppBaseDAO.getInstance().getSequenceNextVal(firmId, AppConstants.APP_SEQ_ESIGN_SIGNER_ID));

			if (employeesData.get(idxReassign.getEmailId()) != null) {
				idxESignSigner.setObjectId(ObjectConstants.OBJECT_EMPLOYEE);
				idxESignSigner.setObjectRefId(employeesData.get(idxReassign.getEmailId()));
			}

			signers.add(idxESignSigner);
			idxESignDocument.getSigners().addAll(signers);
			idxReassign.setStatus(ESignConstants.REASSIGN_APPROVED);
			idxReassign.setrSId(idxESignSigner.geteSignSignerId());

			for (IdxEsignDocumentPage idxESignDocumentPage : idxESignDocument.getDocumentPages()) {
				for (IdxEsignAttribute idxESignAttribute : idxESignDocumentPage.geteSignAttributes()) {
					if (idxESignAttribute.geteSignSigner().geteSignSignerId().equals(reqSId)) {
						idxESignAttribute.seteSignSigner(idxESignSigner);
					}
				}
			}

			// signer2 as signer1
			updateReassignDetails(firmId, documentId, idxESignDocument.getSigners(),
					idxESignDocument.getDocumentPages(), idxESignDocument.getReassign());

			// Create Esignature history, Make Entry in Audit Trail
			createESignatureHistory(firmId, idxESignDocument, eSignSigner, AppConstants.ESIGN_REASSIGNED,
					AppConstants.ESIGN_DESC_REASSIGNED, clientIpAddress, userAgent, idxReassign);

			final String documentUrl = getDocumentRedirectionURL(firmId, documentId, null,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, null);
			notifyReassignStatus(firmId, idxESignDocument, documentUrl, ESignConstants.REASSIGN_APPROVED, reqSId,
					idxReassign);

			// Request sign for Reassigned Document
			requestSignForReassignDoc(firmId, idxESignDocument, documentUrl, idxReassign, idxESignSigner,
					idxReassign.getMsg());
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);

		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:reassignApproved:exception:", exception);
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		}
		return results;
	}

	/**
	 * This method used to reassign declined scenario
	 * 
	 * @param firmId
	 * @param documentId
	 * @param reqSId
	 * @param idxESignDocument
	 * @param idxReassign
	 * @return
	 */
	public Map<String, Object> reassignDeclined(final Long firmId, final Long documentId, final Long reqSId,
			final IdxESignDocument idxESignDocument, final IdxReassign idxReassign) {
		final Map<String, Object> results = new HashMap<>();
		try {
			idxReassign.setStatus(ESignConstants.REASSIGN_DECLINED);

			updateReassign(firmId, documentId, idxESignDocument.getReassign());

			final String documentUrl = getDocumentRedirectionURL(firmId, documentId, null,
					ObjectConstants.OBJECT_ESIGN_DOCUMENT, null);
			notifyReassignStatus(firmId, idxESignDocument, documentUrl, ESignConstants.REASSIGN_DECLINED, reqSId,
					idxReassign);
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:reassignDeclined:exception:", exception);
			results.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		}
		return results;
	}

	/**
	 * This method used to change business logo and Tagline in Email.
	 *
	 * @param firmId
	 * @param brandId
	 * @param mailBodyValues
	 */
	public void updateBrandingContent(final Long firmId, String brandId, final HashMap<String, Object> mailBodyValues) {
		final String planCode = getPlan(firmId);

		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

		if (brandId != null && ((idxESignConfiguration != null && idxESignConfiguration.getIbe())
				|| (ESignConstants.SPLAN_5000.equals(planCode) || ESignConstants.SPLAN_1000.equals(planCode)))) {
			final IdxFirmBranding idxFirmBranding = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxFirmBranding.class, ObjectConstants.OBJECT_FIRM_BRANDING, brandId);
			if (idxFirmBranding != null) {
				mailBodyValues.put(ESignConstants.BRANDING_LOGO, idxFirmBranding.getLogo());
				mailBodyValues.put(ESignConstants.BRANDING_NAME, idxFirmBranding.getTagLine());
			} else {
				mailBodyValues.put(ESignConstants.BRANDING_LOGO, ESignConstants.SIGN_LOGO_CF);
				mailBodyValues.put(ESignConstants.BRANDING_NAME, ESignConstants.BRANDING_NAME_SIGN);
			}
		} else {
			mailBodyValues.put(ESignConstants.BRANDING_LOGO, ESignConstants.SIGN_LOGO_CF);
			mailBodyValues.put(ESignConstants.BRANDING_NAME, ESignConstants.BRANDING_NAME_SIGN);
		}
	}

	/**
	 * This method used to change business logo and Tagline in Email.
	 *
	 * @param firmId
	 * @param brandId
	 * @param mailBodyValues
	 */
	public void updateBrandingContent(final Long firmId, String brandId, final Map<String, String> mailBodyValues) {
		final String planCode = getPlan(firmId);

		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

		if (brandId != null && ((idxESignConfiguration != null && idxESignConfiguration.getIbe())
				|| (ESignConstants.SPLAN_5000.equals(planCode) || ESignConstants.SPLAN_1000.equals(planCode)))) {
			final IdxFirmBranding idxFirmBranding = ElasticSearchDAO.getInstance().getDocument(firmId,
					IdxFirmBranding.class, ObjectConstants.OBJECT_FIRM_BRANDING, brandId);
			if (idxFirmBranding != null) {
				mailBodyValues.put(ESignConstants.BRANDING_LOGO, idxFirmBranding.getLogo());
				mailBodyValues.put(ESignConstants.BRANDING_NAME, idxFirmBranding.getTagLine());
			} else {
				mailBodyValues.put(ESignConstants.BRANDING_LOGO, ESignConstants.SIGN_LOGO);
				mailBodyValues.put(ESignConstants.BRANDING_NAME, ESignConstants.BRANDING_NAME_SIGN);
			}
		} else {
			mailBodyValues.put(ESignConstants.BRANDING_LOGO, ESignConstants.SIGN_LOGO);
			mailBodyValues.put(ESignConstants.BRANDING_NAME, ESignConstants.BRANDING_NAME_SIGN);
		}
	}

	/**
	 * This method used to get the branding details for ESign Applications.
	 *
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public List<IdxFirmBranding> getBrandingDetails(final Long firmId, UserData userData) {
		final String planCode = getPlan(firmId);

		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

		if ((idxESignConfiguration != null && idxESignConfiguration.getIbe())
				|| (ESignConstants.SPLAN_5000.equals(planCode) || ESignConstants.SPLAN_1000.equals(planCode))) {
			final List<IdxFirmBranding> firmBrandings = getFirmBranding(firmId, AppConstants.GETALL);
			if(!AppUtil.checkListisNullOrNot(firmBrandings)) {
				firmBrandings.add(createDefaultBrand(firmId, userData));
			}
			return firmBrandings;
		}
		return null;
	}

	/**
	 * This method used to get all the branding details of Sign.co Firms.
	 *
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public Map<String, Object> getAllBrandingDetails(final Long firmId, final UserData userData) {
		final Map<String, Object> result = new HashMap<>();
		try {
			final List<IdxFirmBranding> idxFirmBrandings = getFirmBranding(firmId, AppConstants.GETALL);

			// Adding Default Firm Branding.
			if(!AppUtil.checkListisNullOrNot(idxFirmBrandings)) {
				idxFirmBrandings.add(createDefaultBrand(firmId, userData));
			}

			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
			result.put(AppConstants.RESULT_DATA, idxFirmBrandings);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getBrandingDetails:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		return result;
	}

	/**
	 * This method used to get the firm Branding Data.
	 *
	 * @param firmId
	 * @param isFrom
	 * @return
	 */
	public List<IdxFirmBranding> getFirmBranding(final Long firmId, String isFrom) {
		final List<IdxFirmBranding> idxFirmBrandings = new ArrayList<>();
		try {
			final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
					.prepareSearch(ObjectConstants.OBJECT_FIRM_BRANDING.toString())
					.setSearchType(ESAPIUtil.QUERY_AND_FETCH).setExplain(false);
			builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

			final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
			andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

			if (AppConstants.GETALL.equalsIgnoreCase(isFrom)) {
				builder.setSize(5);
			} else {
				andBuilder.must(QueryBuilders.termQuery("isDefault", AppConstants.YES));
				builder.setSize(1);
			}
			builder.setQuery(andBuilder);
			builder.addSort(AppConstants.CREATION_DATE, SortOrder.ASC);

			logger.info(firmId, "EsignatureService:getFirmBranding:builder:" + builder.toString());

			SearchResponse response = builder.execute().actionGet();

			if (response.getHits().getHits().length != 0) {
				for (SearchHit hit : response.getHits().getHits()) {
					final IdxFirmBranding idxFirmBranding = AppUtil.convertFromJson(IdxFirmBranding.class,
							hit.getSourceAsString());
					idxFirmBranding.setId(hit.getId());
					idxFirmBrandings.add(idxFirmBranding);
				}
				idxFirmBrandings.sort(IdxFirmBranding.defaultBrandingComparator.reversed());
				return idxFirmBrandings;
			}
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getFirmBranding:exception:", exception);
		}
		return idxFirmBrandings;
	}

	/**
	 * This method used to create the default branding
	 *
	 * @param firmId
	 * @param userData
	 * @return
	 */
	public IdxFirmBranding createDefaultBrand(final Long firmId, final UserData userData) {
		final IdxFirmBranding idxFirmBranding = new IdxFirmBranding(firmId, ESignConstants.SIGN_LOGO,
				ESignConstants.ESIGN_FROM_EMAIL_NAME, ESignConstants.BRANDING_NAME_SIGN, ESignConstants.FAV_ICON_SIGN,
				ESignConstants.ESIGN_FROM_EMAIL_NAME.toLowerCase(), AppConstants.YES);
		final String currentDate = DateUtil.getEsDateFormat().format(new Date());

		idxFirmBranding.setCreatedBy(userData.getUserId());
		idxFirmBranding.setCreatedByName(userData.getFullName());
		idxFirmBranding.setCreationDate(currentDate);

		idxFirmBranding.setLastUpdatedBy(userData.getUserId());
		idxFirmBranding.setLastUpdatedByName(userData.getFullName());
		idxFirmBranding.setLastUpdateDate(currentDate);

		final IndexResponse response = ElasticSearchDAO.getInstance().indexDocument(firmId,
				ObjectConstants.OBJECT_FIRM_BRANDING, AppUtil.convertToJson(idxFirmBranding), true);
		idxFirmBranding.setId(response.getId());

		updateBrandConfig(firmId, true);

		return idxFirmBranding;
	}

	/**
	 * This method used to update the brand config
	 *
	 * @param firmId
	 * @param ibe
	 */
	public void updateBrandConfig(final Long firmId, final Boolean ibe) {
		final IdxESignConfiguration idxESignConfiguration = AppBaseDAO.getInstance().getConfigData(firmId,
				IdxESignConfiguration.class, ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA);

		if (idxESignConfiguration != null) {
			idxESignConfiguration.setIbe(ibe);

			ElasticSearchDAO.getInstance().indexConfigDocument(firmId, IdxESignConfiguration.class,
					ObjectConstants.OBJECT_ESIGN_CONFIGURATION_DATA, firmId,
					AppUtil.convertToJson(idxESignConfiguration));
		}
	}

	/**
	 * This method used to update branding details
	 * 
	 * @param firmId
	 * @param userData
	 * @param request
	 * @return
	 */
	public Map<String, Object> saveOrUpdateBrandingDetails(final Long firmId, final UserData userData,
			final HttpServletRequest request) {
		final String firmBrandingData = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_FIRM_BRANDING_DATA, null);

		final Map<String, Object> result = new HashMap<>();
		try {
			final IdxFirmBranding idxFirmBranding = AppUtil.convertFromJson(IdxFirmBranding.class, firmBrandingData);

			final String currentDate = DateUtil.getEsDateFormat().format(new Date());

			if (idxFirmBranding.getId() == null) {
				idxFirmBranding.setFirmId(firmId);

				idxFirmBranding.setCreatedBy(userData.getUserId());
				idxFirmBranding.setCreatedByName(userData.getFullName());
				idxFirmBranding.setCreationDate(currentDate);

				idxFirmBranding.setLastUpdatedBy(userData.getUserId());
				idxFirmBranding.setLastUpdatedByName(userData.getFullName());
				idxFirmBranding.setLastUpdateDate(currentDate);

				final IndexResponse response = ElasticSearchDAO.getInstance().indexDocument(firmId,
						ObjectConstants.OBJECT_FIRM_BRANDING, AppUtil.convertToJson(idxFirmBranding), true);
				idxFirmBranding.setId(response.getId());
				result.put(AppConstants.RESULT_DATA, idxFirmBranding);
			} else {
				final IdxFirmBranding firmBranding = ElasticSearchDAO.getInstance().getDocument(firmId,
						IdxFirmBranding.class, ObjectConstants.OBJECT_FIRM_BRANDING, idxFirmBranding.getId());
				firmBranding.setLogo(idxFirmBranding.getLogo());
				firmBranding.setFavIcon(idxFirmBranding.getFavIcon());
				firmBranding.setTagLine(idxFirmBranding.getTagLine());
				firmBranding.setDomain(idxFirmBranding.getDomain());
				firmBranding.setName(idxFirmBranding.getName());
				firmBranding.setIsDefault(idxFirmBranding.getIsDefault());

				firmBranding.setLastUpdatedBy(userData.getUserId());
				firmBranding.setLastUpdatedByName(userData.getFullName());
				firmBranding.setLastUpdateDate(currentDate);
				ElasticSearchDAO.getInstance().indexDocument(firmId, ObjectConstants.OBJECT_FIRM_BRANDING,
						idxFirmBranding.getId(), AppUtil.convertToJson(firmBranding));
				firmBranding.setId(idxFirmBranding.getId());
				result.put(AppConstants.RESULT_DATA, firmBranding);
			}
			result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_SUCCESS);
			return result;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:saveOrUpdateBrandingDetails:exception:", exception);
		}
		result.put(AppConstants.RESULT_STATUS, AppConstants.STATUS_CODE_FAILURE);
		return result;
	}

	/**
	 * This method used to remove the branding details.
	 * 
	 * @param firmId
	 * @param request
	 * @return
	 */
	public String removeBrandingDetails(final Long firmId, final HttpServletRequest request) {
		final String id = AppHttpUtil.getStringParameter(request, AppConstants.ID, null);
		final boolean isDeleted = ElasticSearchDAO.getInstance().deleteDocumentIfExists(firmId,
				ObjectConstants.OBJECT_FIRM_BRANDING.toString(), id);
		
		final Map<String, String> result = new HashMap<>();
		if(isDeleted) {
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		} else {
			result.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		}
		return AppUtil.convertToJson(result);
	}

	/**
	 * This method used for setting the label Font Color(lfc) in IdxLable(al)
	 * based on the attrFont Format - rgb(0,0,0) / #FFFFFF / #FFF
	 *
	 * @param firmId
	 * @param attrFont
	 * @param al
	 */
	public boolean setLabelFontColor(final Long firmId, String attrFont, final IdxLabel al) {
		try {
			if (AppUtil.checkStringNullOrNot(attrFont)) {
				logger.info(firmId, "ESignatureService:setLableFontColor:attrFont:" + attrFont);
				if (attrFont.contains("rgb")) {
					final String subString = attrFont.substring(4, attrFont.length() - 1);
					final String[] attrFontColor = subString.split(",");
					ArrayList<Integer> attrFontInteger = new ArrayList<>();
					attrFontInteger.add(Integer.parseInt(attrFontColor[0]));
					attrFontInteger.add(Integer.parseInt(attrFontColor[1].trim()));
					attrFontInteger.add(Integer.parseInt(attrFontColor[2].trim()));
					int[] array = ArrayUtils.toPrimitive(attrFontInteger.toArray(new Integer[0]));
					al.setLfc(array);
				} else if (attrFont.contains("#")) {
					if (attrFont.length() == 4) {
						final StringBuilder attrFonts = new StringBuilder();
						attrFonts.append(attrFont.charAt(0));
						attrFonts.append(attrFont.charAt(1));
						attrFonts.append(attrFont.charAt(1));
						attrFonts.append(attrFont.charAt(2));
						attrFonts.append(attrFont.charAt(2));
						attrFonts.append(attrFont.charAt(3));
						attrFonts.append(attrFont.charAt(3));

						attrFont = attrFonts.toString();
					}

					final Integer red = Integer.valueOf(attrFont.substring(1, 3), 16);
					final Integer green = Integer.valueOf(attrFont.substring(3, 5), 16);
					final Integer blue = Integer.valueOf(attrFont.substring(5, 7), 16);
					final List<Integer> attrHexValueInteger = new ArrayList<>();
					attrHexValueInteger.add(red);
					attrHexValueInteger.add(green);
					attrHexValueInteger.add(blue);
					int[] arrayValue = ArrayUtils.toPrimitive(attrHexValueInteger.toArray(new Integer[0]));
					al.setLfc(arrayValue);
				}
			} else {
				int[] arrayValue = { 0, 0, 0 };
				al.setLfc(arrayValue);
			}
			return true;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:setLabelFontColor:exception:", exception);
		}

		// Setting default font color
		final int[] arrayValue = { 0, 0, 0 };
		al.setLfc(arrayValue);
		return false;
	}

	/**
	 * This method used to set the esign attribute offset from file
	 * @author Sundar
	 * @date September 1, 2022
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public boolean setESignAttributeOffset() {
		try {
			if (ESignConstants.offsetByPageType != null && !ESignConstants.offsetByPageType.isEmpty()) {
				return true;
			}

			final String esignAttrOffsetData = AppFileUtil.getInstance()
					.readFileFromClassPath(ESignConstants.ESIGN_ATTR_OFFSET_FILE_PATH);
			ESignConstants.offsetByPageType = new Gson().fromJson(esignAttrOffsetData, HashMap.class);
			return true;
		} catch (Exception exception) {
			logger.error(0L, "ESignatureService:setESignAttributeOffset:exception:", exception);
		}
		return false;
	}

	/**
	 * This method used to write file in server.
	 *
	 * @param firmId
	 * @param documentId
	 * @param documentData
	 * @return
	 */
	public String writeFile(final Long firmId, final Long userId, final Long documentId, final String documentData) {
		try {
			final String inputPDFName = ApplicationProperties.getProperty(AppConstants.PDF_TEMPLATE_DIR) + "/" + firmId
					+ "_" + userId + "_" + documentId + "_" + System.currentTimeMillis() + AppConstants.PDF_FILE_EXTENSION;
			final File createdInputPDF = new File(inputPDFName);
			byte[] decodedPDF = Base64.decodeBase64(documentData.split(",")[1]);
			FileUtils.writeByteArrayToFile(createdInputPDF, decodedPDF);
			return inputPDFName;
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:writeFile:exception", exception);
		}
		return null;
	}

	/**
	 * This method used to delete the file in server side if exists.
	 *
	 * @param firmId
	 * @param filePath
	 *
	 * @author Sundar
	 * @date Sept 7, 2022
	 */
	public void deleteFileIfExists(final Long firmId, final String filePath) {
		try {
			final Path createInputPDF = Paths.get(filePath);
			Files.deleteIfExists(createInputPDF);
		} catch (Exception excpetion) {
			logger.error(firmId, "ESignatureService:deleteFileIfExists:excpetion:", excpetion);
		}
	}

	/**
	 * Add or update esignAttributes using script
	 * @param firmId
	 * @param documentId
	 * @param esignAttributeValue
	 * @param addAttribute
	 * @param updateAttribute
	 * @param isNew
	 *
	 * @reference Bug 239683
	 * @date Dec 8,2022
	 * @author  Kanishka
	 * @return
	 */
	public IdxESignDocument updateEsignAttributeByScript(final Long firmId, final Long documentId,
			final List<IdxEsignAttribute> esignAttributeValue, final List<String> addAttribute,
			final List<String> updateAttribute, final boolean isNew) {

		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
		scriptParams.put(ESignConstants.IS_NEW, isNew);
		try {

			scriptParams.put("eSignAttribute",
					new ObjectMapper().readValue(AppUtil.formatUrl(esignAttributeValue), ArrayList.class));
			scriptParams.put("addAttribute",
					new ObjectMapper().readValue(AppUtil.formatUrl(addAttribute), ArrayList.class));
			scriptParams.put("updateAttribute",
					new ObjectMapper().readValue(AppUtil.formatUrl(updateAttribute), ArrayList.class));

		} catch (IOException exception) {
			logger.error(firmId, "ESignatureService:updateEsignAttributeByScript:exception:IOException", exception);
		}

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		// Block for add attributes
		updateScript.append("if ((params.addAttribute != null  && !params.addAttribute.isEmpty()) || params.isNew) {");
		updateScript.append("for (int i = 0; i < params.eSignAttribute.size(); i++) {");
		updateScript.append("for (int j = 0; j < ctx._source.documentPages.size(); j++) {");
		updateScript.append(
				"if (params.eSignAttribute[i].pageNumber == ctx._source.documentPages[j].pageNumber && (params.addAttribute.contains(params.eSignAttribute[i].uniqueId.toString()) || params.isNew) ) {");
		updateScript.append("ctx._source.documentPages[j].eSignAttributes.add(params.eSignAttribute[i]);");
		updateScript.append("break;");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");

		// Block for update attribute details
		updateScript.append(
				"if ((params.updateAttribute != null  && !params.updateAttribute.isEmpty()) || !params.isNew ) {");
		updateScript.append("for (int i = 0; i < params.eSignAttribute.size(); i++) {");
		updateScript.append("for (int j = 0; j < ctx._source.documentPages.size(); j++) {");
		updateScript.append("if (params.eSignAttribute[i].pageNumber == ctx._source.documentPages[j].pageNumber) {");
		updateScript.append("for (int k = 0; k < ctx._source.documentPages[j].eSignAttributes.size(); k++) {");
		updateScript.append(
				"if ((params.updateAttribute.contains(params.eSignAttribute[i].uniqueId.toString()) || !params.isNew) && params.eSignAttribute[i].uniqueId.toString() == ctx._source.documentPages[j].eSignAttributes[k].uniqueId.toString() ) {");
		updateScript.append("ctx._source.documentPages[j].eSignAttributes[k].width = params.eSignAttribute[i].width;");
		updateScript
				.append("ctx._source.documentPages[j].eSignAttributes[k].height = params.eSignAttribute[i].height;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].locationX = params.eSignAttribute[i].locationX;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].locationY = params.eSignAttribute[i].locationY;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].eSignSigner = params.eSignAttribute[i].eSignSigner;");
		updateScript.append("ctx._source.documentPages[j].eSignAttributes[k].isReq = params.eSignAttribute[i].isReq;");
		updateScript
				.append("ctx._source.documentPages[j].eSignAttributes[k].isBold = params.eSignAttribute[i].isBold;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].isItalic = params.eSignAttribute[i].isItalic;");
		updateScript
				.append("ctx._source.documentPages[j].eSignAttributes[k].isUndLn = params.eSignAttribute[i].isUndLn;");
		updateScript.append("ctx._source.documentPages[j].eSignAttributes[k].font = params.eSignAttribute[i].font;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].fontSize = params.eSignAttribute[i].fontSize;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].fontColor = params.eSignAttribute[i].fontColor;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].htmlContent = params.eSignAttribute[i].htmlContent;");
		updateScript.append("ctx._source.documentPages[j].eSignAttributes[k].align = params.eSignAttribute[i].align;");
		updateScript.append(
				"ctx._source.documentPages[j].eSignAttributes[k].attrLabel = params.eSignAttribute[i].attrLabel;");
		updateScript.append("ctx._source.documentPages[j].eSignAttributes[k].lb = params.eSignAttribute[i].lb;");
		updateScript.append("break;");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");
		updateScript.append("}");

		updateScript.append("}");
		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, true, IdxESignDocument.class);

	}

	/**
	 * This method used to extend the document Expiry.
	 *
	 * @param firmId
	 * @param request
	 * @param userData
	 * @return
	 */
	public String extendDocExpiry(Long firmId, HttpServletRequest request, final UserData userData) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.DOCUMENT_ID, null);
		final String expiryDate = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_EXPIRY_DATE, null);
		final String clientIpAddress = AppHttpUtil.getClientIPAddress(request);
		final String userAgent = AppHttpUtil.getUserAgent(request);

		final String[] include = {};
		final String[] exclude = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
				ESignConstants.ESIGN_SIGNED_DOCUMENT };

		final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, include, exclude);

		// Updating the Expiry Date for the Document
		final String expDate = DateUtil.convertDateToESFormat(expiryDate, userData.getDatePattern(), userData.getTimeZone(), 2);
		updateExpDate(firmId, documentId, expDate);

		// Updating the Document Status based on the Signers - Need Review / In-Progress / Sent
		updateDocStatusForDocExtension(firmId, documentId);

		// To update the Last Updating date and Last updated by.
		final String currentDate = DateUtil.getEsDateFormat().format(new Date());
		updateLastUpdDateDoc(firmId, documentId, userData.getUserId(), userData.getFullName(), currentDate);

		// Make entry in the Audit Log for Document Expiry Extend
		for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
			if (ESignConstants.SIGNER_ACTION_NEED_SIGN.equals(idxESignSigner.getSignerActions())
					&& !ESignConstants.SIGNER_STATUS_SIGNED.equals(idxESignSigner.getSignerStatus())) {
				createESignatureHistory(firmId, idxESignDocument, idxESignSigner, AppConstants.ESIGN_EXTENDED_DOCUMENT_DATE,
						AppConstants.ESIGN_DESC_EXTENDED_DATE, clientIpAddress, userAgent, null);
			}
		}

		// Send the Mail to the Signers
		notifyDocumentExpExtension(firmId, expDate, request);
		return AppConstants.RESULT_STATUS_SUCCESS;
	}

	/**
	 * This method used to update the Exp Date in ESign Document.
	 *
	 * @param firmId
	 * @param documentId
	 * @param expDate
	 * @return
	 */
	public IdxESignDocument updateExpDate(final Long firmId, final Long documentId, final String expDate) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
		scriptParams.put(ESignConstants.EXP_DATE, expDate);

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		updateScript.append("ctx._source.expDate = params.expDate;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to send the Document Expiry Date Extension notification mail to the Signers.
	 *
	 * @param firmId
	 * @param expDate
	 * @param request
	 * @return
	 */
	public String notifyDocumentExpExtension(final Long firmId, final String expDate, final HttpServletRequest request) {
		final Long documentId = AppHttpUtil.getLongParameter(request, ESignConstants.REQUEST_PARAM_DOCUMENT_ID, null);
		final String subject = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_SUBJECT, null);
		String customMessage = AppHttpUtil.getStringParameter(request, ESignConstants.REQUEST_PARAM_CUSTOM_MESSAGE, null);

		final String[] include = {};
		final String[] exclude = { ESignConstants.ESIGN_DOCUMENT_DATA, ESignConstants.ESIGN_DOCUMENT_PAGES,
				ESignConstants.ESIGN_SIGNED_DOCUMENT };
		final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, include, exclude);

		if (idxESignDocument != null) {
			final IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.EXTEND_DOCUMENT_EXPIRY);
			idxESignDocument.setExpDate(expDate);
			idxESignDocument.setCustomSubject(subject);
			if(!AppUtil.checkStringNullOrNot(subject)) {
				idxESignDocument.setCustomSubject(idxEmailTemplate.getSubject());
			}
			if(!AppUtil.checkStringNullOrNot(customMessage)) {
				customMessage = idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1];
			}
			sendEmail(firmId, idxEmailTemplate, idxESignDocument, customMessage);

			return AppConstants.RESULT_STATUS_SUCCESS;
		}
		return AppConstants.RESULT_STATUS_FAILURE;
	}

	/**
	 * This method used to update the doc status for Expiry Extended Document.
	 *
	 * @param firmId
	 * @param documentId
	 */
	public void updateDocStatusForDocExtension(final Long firmId, final Long documentId) {
		final IdxESignDocument idxESignDocument = getDocument(firmId, documentId, null, null);

		boolean isOneSignerSigned = false;
		for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
			if (ESignConstants.SIGNER_ACTION_NEED_SIGN.equals(idxESignSigner.getSignerActions())
					&& ESignConstants.SIGNER_STATUS_SIGNED.equals(idxESignSigner.getSignerStatus())) {
				isOneSignerSigned = true;
			}
		}

		boolean isOwnerAsSigner = false;
		boolean isOwnerAsSignerSigned = false;
		for (IdxESignSigner idxESignSigner : idxESignDocument.getSigners()) {
			if (idxESignDocument.getSenderDetails().getEmailId().equals(idxESignSigner.getPrimaryEmailId())
					&& ESignConstants.SIGNER_ACTION_NEED_SIGN.equals(idxESignSigner.getSignerActions())) {
				isOwnerAsSigner = true;
				if (ESignConstants.SIGNER_STATUS_SIGNED.equals(idxESignSigner.getSignerStatus())) {
					isOwnerAsSignerSigned = true;
				}
			}
		}

		String documentStatus = ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING;
		if (isOneSignerSigned || (isOwnerAsSigner && isOwnerAsSignerSigned)) {
			documentStatus = ESignConstants.ESIGN_DOCUMENT_STATUS_PENDING;
		} else if (isOwnerAsSigner && !isOwnerAsSignerSigned) {
			documentStatus = ESignConstants.ESIGN_DOCUMENT_STATUS_NEW;
		} else if (!isOwnerAsSigner && !isOneSignerSigned) {
			documentStatus = ESignConstants.ESIGN_DOCUMENT_STATUS_SENT;
		}

		updateStatusFieldByDocId(firmId, documentId, documentStatus);
	}

	/**
	 * This method used to update the last updated date in idxESignDocument
	 *
	 * @param firmId
	 * @param documentId
	 * @param lastUpdateBy
	 * @param lastUpdateByName
	 * @param lastUpdateDate
	 * @return
	 */
	public IdxESignDocument updateLastUpdDateDoc(final Long firmId, final Long documentId, final Long lastUpdateBy,
			final String lastUpdateByName, final String lastUpdateDate) {
		final Map<String, Object> scriptParams = new HashMap<>();
		scriptParams.put(AppConstants.FIRM_ID, firmId);
		scriptParams.put(ESignConstants.ESIGN_DOCUMENT_ID, documentId);
		scriptParams.put(AppConstants.LAST_UPDATED_BY, lastUpdateBy);
		scriptParams.put(AppConstants.LAST_UPDATED_BY_NAME_STR, lastUpdateByName);
		scriptParams.put(AppConstants.LAST_UPDATE_DATE, lastUpdateDate);

		final StringBuilder updateScript = new StringBuilder();
		updateScript.append("if(ctx._source.firmId == params." + AppConstants.FIRM_ID
				+ " && ctx._source.eSignDocumentId == params." + ESignConstants.ESIGN_DOCUMENT_ID + ") {");

		updateScript.append("ctx._source.lastUpdatedBy = params.lastUpdatedBy;");
		updateScript.append("ctx._source.lastUpdatedByName = params.lastUpdatedByName;");
		updateScript.append("ctx._source.lastUpdateDate = params.lastUpdateDate;");

		updateScript.append("}");

		return updateDocumentByScript(firmId, ObjectConstants.OBJECT_ESIGN_DOCUMENT, documentId.toString(),
				updateScript.toString(), scriptParams, false, IdxESignDocument.class);
	}

	/**
	 * This method used to get the Expiry Extension Email Subject and Message.
	 *
	 * @param firmId
	 * @return
	 */
	public String getExpiryMailSubAndMsg(final Long firmId) {
		final Map<String, Object> resultMap = new HashMap<>();
		try {
			final IdxEmailTemplate idxEmailTemplate = getEmailTemplateByMessageType(firmId, ESignConstants.EXTEND_DOCUMENT_EXPIRY);
			resultMap.put(ESignConstants.REQUEST_PARAM_CUSTOM_MESSAGE,
					idxEmailTemplate.getCustomMessage().split(ESignConstants.CUST_MSG)[1]);
			resultMap.put(ESignConstants.REQUEST_PARAM_CUSTOM_SUBJECT, idxEmailTemplate.getSubject());
			resultMap.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_SUCCESS);
		} catch (Exception exception) {
			logger.error(firmId, "ESignatureService:getExpiryMailSub&Msg:exception", exception);
			resultMap.put(AppConstants.RESULT_STATUS, AppConstants.RESULT_STATUS_FAILURE);
		}
		return AppUtil.convertToJson(resultMap);

	}

	/**
	 * This method is used to search the Document by Status Criteria.
	 *
	 * @param firmId
	 * @param objectId
	 * @param userData
	 * @param documentName
	 * @param signerName
	 * @param employeeId
	 * @param selectedFilter
	 * @param startDate
	 * @param endDate
	 * @param expiry
	 * @return
	 */
	public Map<String, Object> searchDocument(final Long firmId, final Long objectId, final Integer startIndex,
			final Integer numRecords, final String sortColumn, final String sortDir, final UserData userData,
			final String objectStatus, final String documentName, final String signerName, final String employeeId,
			final String status, final String startDate, final String endDate, final int expiry) {
		final Map<String, Object> result = new HashMap<>();
		final String[] includes = { AppConstants.FIRM_ID, ESignConstants.ESIGN_DOCUMENT_ID, ESignConstants.DOC_NAME,
				ESignConstants.TEMPLATE_NAME, ESignConstants.SIGN_TYPE, ESignConstants.IS_ENABLED,
				ESignConstants.STATUS_NAME, ESignConstants.STATUS_CODE, ESignConstants.IS_SENT,
				AppConstants.CREATED_BY_NAME, AppConstants.CREATION_DATE, ESignConstants.SENDER_DETAILS,
				ESignConstants.ASSOCIATED_OBJECT };
		final String[] excludes = {};

		final SearchRequestBuilder builder = ElasticSearchDAO.getInstance().getClient(firmId)
				.prepareSearch(objectId.toString()).setSearchType(ESAPIUtil.QUERY_AND_FETCH)
				.setFetchSource(includes, excludes).setExplain(false);
		builder.setRouting(AppBaseDAO.getInstance().getShardId(firmId));

		final BoolQueryBuilder andBuilder = QueryBuilders.boolQuery();
		andBuilder.must(QueryBuilders.termQuery(AppConstants.FIRM_ID, firmId));

		// Check the Status is Not null and Not Empty
		if (AppUtil.checkStringNullOrNot(status)) {
			andBuilder.must(QueryBuilders.termQuery(ESignConstants.STATUS_CODE, status));
		}

		// Check the ObjectStatus is not null.(Used for the delete action)
		if (objectStatus != null) {
			andBuilder.must(QueryBuilders.termQuery(AppConstants.OBJECT_STATUS, objectStatus));
		}

		// Document Search - Code Changes Starts here
		// Searching Document By Start Date / End Date.
		if (AppUtil.checkStringNullOrNot(startDate) && AppUtil.checkStringNullOrNot(endDate)) {
			final String startDateConvertESFormat = DateUtil.convertDateToESFormat(startDate, userData.getDatePattern(),
					userData.getTimeZone(), DateUtil.ADJUST_START_OF_DAY);
			String endDateConvertESFormat = DateUtil.convertDateToESFormat(endDate, userData.getDatePattern(),
					userData.getTimeZone(), DateUtil.ADJUST_END_OF_DAY);

			final QueryBuilder rangeBuilder = QueryBuilders.rangeQuery(AppConstants.CREATION_DATE)
					.gte(startDateConvertESFormat).includeLower(true).lte(endDateConvertESFormat).includeUpper(true);
			andBuilder.must(rangeBuilder);
		}

		// Searching Document By Name.
		if (AppUtil.checkStringNullOrNot(documentName)) {
			andBuilder.must(QueryBuilders.matchPhrasePrefixQuery(ESignConstants.DOC_NAME, documentName));
		}

		// Searching Document By Signer Name.
		if (AppUtil.checkStringNullOrNot(signerName)) {
			final QueryBuilder objectRefNameNestedQuery = QueryBuilders.boolQuery()
					.must(QueryBuilders.termQuery(ESignConstants.SIGNERS_OBJECT_REF_NAME, signerName));
			andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.SIGNERS, objectRefNameNestedQuery));
		}

		// Searching Document By Employee Id.
		if (AppUtil.checkStringNullOrNot(employeeId)) {
			final List<Long> employeeIds = AppUtil.convertFromJsonToLongList(employeeId);
			final QueryBuilder objectRefIdNestedQuery = QueryBuilders.boolQuery()
					.must(QueryBuilders.termsQuery(ESignConstants.ASSIGNEES_OBJECT_REF_ID, employeeIds));
			andBuilder.must(ESAPIUtil.nestedQuery(ESignConstants.ASSIGNEES, objectRefIdNestedQuery));
		}

		// Searching Document By Expiry Date.
		if (expiry > 0) {
			// User's timezone
			ZoneId userTimeZone = ZoneId.of(userData.getTimeZone().getID());

			// PST timezone
			ZoneId pstTimeZone = ZoneId.of(TimeZone.getDefault().getID());

			// Today's date in user's timezone
			LocalDate userToday = LocalDate.now(userTimeZone);
			LocalDate userFutureDate = userToday.plusDays(expiry);

			// Start of the day in user's timezone
			ZonedDateTime userStartOfDay = userFutureDate.atStartOfDay(userTimeZone);

			// Convert to PST timezone
			ZonedDateTime pstStartOfDay = userStartOfDay.withZoneSameInstant(pstTimeZone);

			// End of the day in user's timezone
			ZonedDateTime userEndOfDay = userFutureDate.atTime(LocalTime.MAX).atZone(userTimeZone);

			// Convert to PST timezone
			ZonedDateTime pstEndOfDay = userEndOfDay.withZoneSameInstant(pstTimeZone);

			// Format the dates using a DateTimeFormatter
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(DateUtil.format_mdyhms);

			final QueryBuilder rangeBuilder = QueryBuilders.rangeQuery(ESignConstants.EXP_DATE)
					.gte(pstStartOfDay.format(formatter)).includeLower(true).lte(pstEndOfDay.format(formatter))
					.includeUpper(true);
			andBuilder.must(rangeBuilder);
		}

		andBuilder.mustNot(QueryBuilders.termQuery(ESignConstants.IS_TEMPLATE, true));

		// Checking the Access level.
		generateBuilderByAccessLevel(firmId, userData, andBuilder);

		builder.setPostFilter(andBuilder);
		setSortSizeToBuilder(builder, sortColumn, sortDir, startIndex, numRecords);

		logger.info(firmId, "ESignatureService:searchDocument:builder:" + builder.toString());

		final SearchResponse response = builder.execute().actionGet();
		final SearchHit[] hits = response.getHits().getHits();

		final List<IdxESignDocument> idxESignDocuments = new ArrayList<>();
		if (hits != null && hits.length > 0) {
			for (final SearchHit hit : hits) {
				final IdxESignDocument idxESignDocument = AppUtil.convertFromJson(IdxESignDocument.class,
						hit.getSourceAsString());
				idxESignDocument.formatDateValues(userData.getTimeZone(), null);
				idxESignDocuments.add(idxESignDocument);
			}
		}
		logger.info(firmId,
				"Esignatureservice:searchDocument:response:totalHits:" + response.getHits().getTotalHits().value);
		result.put(ESignConstants.RESPONSE_PARAM_COUNT, response.getHits().getTotalHits().value);
		result.put(ESignConstants.RESPONSE_PARAM_DOCUMENTS, idxESignDocuments);
		return result;
	}

	/**
	 * This Method is used for the save Dalvik and Darwin Mobile browser in Esign history.
	 *
	 * @param idxEsignatureHistory
	 * @param userAgent
	 * @param os
	 * @param version
	 * @param browser
	 */
	public void mobileUserAgentForInBuild(final IdxEsignatureHistory idxEsignatureHistory, final String userAgent,
			String os, String version, String browser) {
		// final String userAgent = "Dalvik/2.1.0 (Linux; U; Android 9; SM-T510 Build/PPR1.180610.011)";
		// final String userAgent = "Darwin/19.6.0(iOS/14.3; A2275; iPhone SE (2nd generation); CFNetwork/1209; Sign.co/1.0)";

		final String[] modUserAgent = userAgent.split("\\(");
		final String[] userAgentDet = modUserAgent[1].split(";");

		if (userAgent.contains("Android")) {
			os = userAgentDet[2].trim();
			version = userAgentDet[3].split(" ")[1].trim();
			browser = "Dalvik";
		} else if (userAgent.contains("iPhone")) {
			os = userAgentDet[0].replace("/", " ").trim();
			version = userAgentDet[1].trim();
			browser = "Darwin";
		}

		idxEsignatureHistory.setOs(os);
		idxEsignatureHistory.setVersion(version);
		idxEsignatureHistory.setBrowser(browser);
	}

	/**
	 * This Method is used for the save Android mobile details in Esign history.
	 *
	 * @param idxEsignatureHistory
	 * @param userAgent
	 * @param os
	 * @param version
	 * @param browser
	 */
	public void mobileUserAgentForAndroid(final IdxEsignatureHistory idxEsignatureHistory, final String userAgent,
			String os, String version, String browser) {

		// OS detection
		Pattern pattern = Pattern.compile("\\((.*?)\\)");
		Matcher matcher = pattern.matcher(userAgent);
		if (matcher.find()) {
			os = matcher.group(1);
		}

		// Version detection
		if (userAgent.contains("OPR/")) {
			pattern = Pattern.compile("OPR/([0-9\\.]+)");
			matcher = pattern.matcher(userAgent);
			if (matcher.find()) {
				version = matcher.group(1);
			}
		} else if (userAgent.contains("EdgA/")) {
			pattern = Pattern.compile("EdgA/([0-9\\.]+)");
			matcher = pattern.matcher(userAgent);
			if (matcher.find()) {
				version = matcher.group(1);
			}
		} else if (userAgent.contains("Chrome/")) {
			pattern = Pattern.compile("Chrome/([0-9\\.]+)");
			matcher = pattern.matcher(userAgent);
			if (matcher.find()) {
				version = matcher.group(1);
			}
		} else if (userAgent.contains("Firefox/")) {
			pattern = Pattern.compile("Firefox/([0-9\\.]+)");
			matcher = pattern.matcher(userAgent);
			if (matcher.find()) {
				version = matcher.group(1);
			}
		}

		// Browser detection
		if (userAgent.contains("OPR/")) {
			browser = "Opera";
		} else if (userAgent.contains("EdgA/")) {
			browser = "Edge";
		} else if (userAgent.contains("Chrome/")) {
			browser = "Chrome";
		} else if (userAgent.contains("Firefox/")) {
			browser = "Firefox";
		}
		idxEsignatureHistory.setOs(os);
		idxEsignatureHistory.setVersion(version);
		idxEsignatureHistory.setBrowser(browser);
	}

	/**
	 * This Method is used for the save iPhone mobile details in Esign history.
	 *
	 * @param idxEsignatureHistory
	 * @param userAgent
	 * @param os
	 * @param version
	 * @param browser
	 */
	public void mobileUserAgentForiPhone(final IdxEsignatureHistory idxEsignatureHistory, final String userAgent,
			String os, String version, String browser) {

		// Define regular expressions for each browser
		Pattern firefoxPattern = Pattern.compile(".*(?:Firefox|FxiOS)\\/([0-9]+\\.[0-9]+).*");
		Pattern chromePattern = Pattern.compile(".*(?:Chrome|CriOS)\\/([0-9]+\\.[0-9]+(?:\\.[0-9]+\\.[0-9]+)?).*");
		Pattern operaPattern = Pattern.compile(".*(?:OPR|OPiOS)\\/([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+).*");
		Pattern edgePattern = Pattern.compile(".*(?:Edg|EdgiOS)\\/([0-9]+\\.[0-9]+\\.[0-9]+).*");

		// Match the user agent string against each browser pattern
		Matcher firefoxMatcher = firefoxPattern.matcher(userAgent);
		Matcher chromeMatcher = chromePattern.matcher(userAgent);
		Matcher operaMatcher = operaPattern.matcher(userAgent);
		Matcher edgeMatcher = edgePattern.matcher(userAgent);

		// Extract the OS and version information from the user agent string
		if (userAgent.contains("iPhone")) {
			os = "iOS";
		}

		// Determine the browser and extract the version information
		if (firefoxMatcher.find()) {
			browser = "Firefox";
			version = firefoxMatcher.group(1);
		} else if (chromeMatcher.find()) {
			browser = "Chrome";
			version = chromeMatcher.group(1);
		} else if (operaMatcher.find()) {
			browser = "Opera";
			version = operaMatcher.group(1);
		} else if (edgeMatcher.find()) {
			browser = "Edge";
			version = edgeMatcher.group(1);
		}

		idxEsignatureHistory.setOs(os);
		idxEsignatureHistory.setVersion(version);
		idxEsignatureHistory.setBrowser(browser);
	}

	/**
	 * This method used to send the data to the Custoemr Server.
	 *
	 * @param firmId
	 * @param idxESignDocument
	 * @param currentSigner
	 * @param completedPDFBaseValue
	 */
	public void sendDataToCustomerServer(final Long firmId, final IdxESignDocument idxESignDocument,
			final IdxESignSigner currentSigner, final String completedPDFBaseValue) {
		logger.info(firmId, "ESignatureService:sendDataToCustomerServer:starts");
		logger.info(firmId, "ESignatureService:sendDataToCustomerServer:eSignDocumentId:" + idxESignDocument.geteSignDocumentId());

		// Getting Callback URI for Inhabitr.
		final String callBackUriInhabitr = AppBaseDAO.getInstance()
				.getEnvProperty(ESignConstants.SIGN_CALLBACK_URI_INHABITR, AppConstants.YES);

		// Getting call back URL based on the firmId.
		final Map<Long, String> callBackURIbyFirmId = Arrays.stream(callBackUriInhabitr.split(","))
		        .map(pair -> pair.split("="))
		        .filter(keyValue -> keyValue.length == 2)
		        .collect(Collectors.toMap(keyValue -> Long.valueOf(keyValue[0]), keyValue -> keyValue[1]));
		logger.info(firmId, "ESignatureService:sendDataToCustomerServer:callbackURI:" + callBackURIbyFirmId.get(firmId));

		// creating Closeable Http Client.
		final CloseableHttpClient httpClient = HttpClients.createDefault();

		// create a HTTP POST request
		final HttpPost httpPost = new HttpPost(callBackURIbyFirmId.get(firmId));

		// create a multipart entity builder
		final MultipartEntityBuilder builder = MultipartEntityBuilder.create();

		// Generate a random boundary value
		final String boundary = UUID.randomUUID().toString();
		builder.setBoundary(boundary);

		// add the file to the entity builder
		final String fileName = writeFile(firmId, idxESignDocument.getCreatedBy(),
				idxESignDocument.geteSignDocumentId(), completedPDFBaseValue);
		final File file = new File(fileName);

		builder.addBinaryBody("documentFile", file, ContentType.create(AppConstants.CONTENTTYPE_PDF), file.getName());

		// add the other fields to the entity builder
		builder.addTextBody(ESignConstants.DOCUMENT_ID, idxESignDocument.geteSignDocumentId().toString());
		builder.addTextBody(ESignConstants.REQUEST_PARAM_STATUS, idxESignDocument.getStatusName());
		builder.addTextBody("sender", AppUtil.convertToJson(idxESignDocument.getSenderDetails()));
		builder.addTextBody("signer", AppUtil.convertToJson(currentSigner));

		// build the entity and set it to the request
		final HttpEntity entity = builder.build();
		httpPost.setEntity(entity);

		// Setting header with multipart content type and boundary.
		httpPost.setHeader("Content-Type", "multipart/form-data; boundary=" + boundary);

		try {
			// execute the request
			final CloseableHttpResponse response = httpClient.execute(httpPost);
			final int statusCode = response.getStatusLine().getStatusCode();
			logger.info(firmId, "ESignatureService:sendDataToCustomerServer:status code:" + statusCode);

			final String responseBody = EntityUtils.toString(response.getEntity());
			logger.info(firmId, "ESignatureService:sendDataToCustomerServer:Response Body:" + responseBody);
		} catch (Exception e) {
			logger.error(firmId, "ESignatureService:sendDataToCustomerServer:exception:", e);
		} finally {
			try {
				// close the HTTP client
				httpClient.close();
				deleteFileIfExists(firmId, fileName);
			} catch (IOException exception) {
				logger.error(firmId, "ESignatureService:sendDataToCustomerServer:exception:", exception);
			}
		}
		logger.info(firmId, "ESignatureService:sendDataToCustomerServer:ends");
	}
}
